//# publish
module 0x42.Test {
    import 0x1.signer;

    struct Config has copy, drop, store { b: bool }

    // A current or prospective validator should publish one of these under their address
    struct T has key, store {
        config: Self.Config,
    }

    public publish_config(account: &signer, b: bool) {
    label b0:
        move_to<T>(move(account), T { config: Config { b: move(b) } });
        return;
    }

    // Retrieve a read-only instance of a specific accounts ValidatorConfig.ValidatorConfig.config
    public config(addr: address): Self.Config acquires T {
        let t_ref: &Self.T;
    label b0:
        t_ref = borrow_global<T>(move(addr));
        return *&move(t_ref).T::config;
    }

    public value(config: &Self.Config): bool {
    label b0:
        return *&move(config).Config::b;
    }

    public set(account: &signer, b: bool) acquires T {
        let t_ref: &mut Self.T;
        let config_ref: &mut Self.Config;
        let b_ref: &mut bool;
    label b0:
        t_ref = borrow_global_mut<T>(signer.address_of(move(account)));
        config_ref = &mut move(t_ref).T::config;
        b_ref = &mut move(config_ref).Config::b;
        *move(b_ref) = move(b);

        return;
    }

}


//# run --signers 0x1
import 0x42.Test;
import 0x1.signer;

main(account: signer) {
    let sender: address;
    let config: Test.Config;
    let config1: Test.Config;
label b0:
    Test.publish_config(&account, false);

    sender = signer.address_of(&account);
    config = Test.config(copy(sender));
    assert(Test.value(&config) == false, 77);

    Test.set(&account, true); // shouldn't affect local config variable
    assert(Test.value(&config) == false, 88);

    config1 = Test.config(move(sender));
    assert(Test.value(&config1) == true, 99);

    return;
}
