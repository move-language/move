/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "A2_M" {
    code {
        codecopy(0, dataoffset("A2_M_deployed"), datasize("A2_M_deployed"))
        return(0, datasize("A2_M_deployed"))
    }
    object "A2_M_deployed" {
        code {
            mstore(0, memoryguard(160))
            if iszero(lt(calldatasize(), 4))
            {
                let selector := $Shr(calldataload(0), 224)
                switch selector
                case 0x27a15f43
                {
                    // add_two_number(uint64,uint64)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1 := abi_decode_tuple_$uint64_uint64$_$u64_u64$(4, calldatasize())
                    let ret_0, ret_1 := A2_M_add_two_number(param_0, param_1)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$uint64_uint64$_$u64_u64$(memPos, ret_0, ret_1)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x30df35a9
                {
                    // arithmetic_ops(uint64)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0 := abi_decode_tuple_$uint64$_$u64$(4, calldatasize())
                    let ret_0, ret_1 := A2_M_arithmetic_ops(param_0)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$uint64_uint64$_$u64_u64$(memPos, ret_0, ret_1)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0xae7d00ae
                {
                    // bool_ops(uint64,uint64)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1 := abi_decode_tuple_$uint64_uint64$_$u64_u64$(4, calldatasize())
                    let ret_0, ret_1 := A2_M_bool_ops(param_0, param_1)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$bool_bool$_$bool_bool$(memPos, ret_0, ret_1)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0xf1a0a85c
                {
                    // div(uint64,uint64)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1 := abi_decode_tuple_$uint64_uint64$_$u64_u64$(4, calldatasize())
                    let ret_0, ret_1 := A2_M_div(param_0, param_1)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$uint64_uint64$_$u64_u64$(memPos, ret_0, ret_1)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x4c275efc
                {
                    // multiple_ops(uint64,uint64,uint64)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1, param_2 := abi_decode_tuple_$uint64_uint64_uint64$_$u64_u64_u64$(4, calldatasize())
                    let ret_0 := A2_M_multiple_ops(param_0, param_1, param_2)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$uint64$_$u64$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0xdc75bec7
                {
                    // underflow()
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let ret_0 := A2_M_underflow()
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$uint64$_$u64$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                default {}
            }
            $Abort(97)
            function A2_M_add_two_number(x, y) -> $result0, $result1 {
                let res, z, $t4, $t5
                // $t4 := +($t0, $t1)
                $t4 := $AddU64(x, y)
                // $t5 := 3
                $t5 := 3
                // return ($t5, $t4)
                $result0 := $t5
                $result1 := $t4
            }

            function A2_M_arithmetic_ops(a) -> $result0, $result1 {
                let c, $t2, $t3, $t4, $t5
                let $block := 4
                for {} true {} {
                    switch $block
                    case 2 {
                        // label L0
                        // $t5 := 42
                        $t5 := 42
                        // abort($t5)
                        $Abort($t5)
                    }
                    case 3 {
                        // label L2
                        // return ($t2, $t0)
                        $result0 := $t2
                        $result1 := a
                        leave
                    }
                    case 4 {
                        // $t2 := 2
                        $t2 := 2
                        // $t3 := 2
                        $t3 := 2
                        // $t4 := !=($t2, $t3)
                        $t4 := $Neq($t2, $t3)
                        // if ($t4) goto L0 else goto L2
                        switch $t4
                        case 0  { $block := 3 }
                        default { $block := 2 }
                    }
                }
            }

            function A2_M_bool_ops(a, b) -> $result0, $result1 {
                let tmp_$2, tmp_$3, c, d, $t6, $t7, $t8, $t9, $t10, $t11, $t12
                let $block := 4
                for {} true {} {
                    switch $block
                    case 2 {
                        // label L0
                        // $t2 := >=($t0, $t1)
                        tmp_$2 := $GtEq(a, b)
                        // goto L3
                        $block := 5
                    }
                    case 3 {
                        // label L2
                        // $t7 := false
                        $t7 := false
                        // $t2 := $t7
                        tmp_$2 := $t7
                        // goto L3
                        $block := 5
                    }
                    case 4 {
                        // $t6 := >($t0, $t1)
                        $t6 := $Gt(a, b)
                        // if ($t6) goto L0 else goto L2
                        switch $t6
                        case 0  { $block := 3 }
                        default { $block := 2 }
                    }
                    case 5 {
                        // label L3
                        // $t8 := <($t0, $t1)
                        $t8 := $Lt(a, b)
                        // if ($t8) goto L4 else goto L6
                        switch $t8
                        case 0  { $block := 7 }
                        default { $block := 6 }
                    }
                    case 6 {
                        // label L4
                        // $t9 := true
                        $t9 := true
                        // $t3 := $t9
                        tmp_$3 := $t9
                        // goto L7
                        $block := 8
                    }
                    case 7 {
                        // label L6
                        // $t3 := <=($t0, $t1)
                        tmp_$3 := $LtEq(a, b)
                        // goto L7
                        $block := 8
                    }
                    case 8 {
                        // label L7
                        // $t10 := !=($t2, $t3)
                        $t10 := $Neq(tmp_$2, tmp_$3)
                        // $t11 := !($t10)
                        $t11 := $LogicalNot($t10)
                        // if ($t11) goto L8 else goto L10
                        switch $t11
                        case 0  { $block := 10 }
                        default { $block := 9 }
                    }
                    case 9 {
                        // label L8
                        // $t12 := 42
                        $t12 := 42
                        // abort($t12)
                        $Abort($t12)
                    }
                    case 10 {
                        // label L10
                        // return ($t2, $t3)
                        $result0 := tmp_$2
                        $result1 := tmp_$3
                        leave
                    }
                }
            }

            function A2_M_div(x, y) -> $result0, $result1 {
                let $t2, $t3
                // $t2 := /($t0, $t1)
                $t2 := $Div(x, y)
                // $t3 := %($t0, $t1)
                $t3 := $Mod(x, y)
                // return ($t2, $t3)
                $result0 := $t2
                $result1 := $t3
            }

            function A2_M_multiple_ops(x, y, z) -> $result {
                let $t3, $t4
                // $t3 := *($t1, $t2)
                $t3 := $MulU64(y, z)
                // $t4 := +($t0, $t3)
                $t4 := $AddU64(x, $t3)
                // return $t4
                $result := $t4
            }

            function A2_M_underflow() -> $result {
                let x, $t1, $t2, $t3
                // $t1 := 0
                $t1 := 0
                // $t2 := 1
                $t2 := 1
                // $t3 := -($t1, $t2)
                $t3 := $Sub($t1, $t2)
                // return $t3
                $result := $t3
            }

            function abi_encode_tuple_$uint64$_$u64$(headStart ,value_0) -> tail {
                tail := add(headStart, 32)
                abi_encode_uint64(value_0, add(headStart, 0))
            }
            function abi_encode_uint64(value, pos) {
                mstore(pos, cleanup_uint64(value))
            }
            function cleanup_uint64(value) -> cleaned {
                cleaned := and(value, 0xffffffffffffffff)
            }
            function abi_decode_tuple_$uint64_uint64_uint64$_$u64_u64_u64$(headStart, dataEnd) -> value_0, value_1, value_2 {
                if slt(sub(dataEnd, headStart), 96) { $Abort(96) }
                {
                    let offset := 0
                    value_0 := abi_decode_uint64(add(headStart, offset), dataEnd)
                }
                {
                    let offset := 32
                    value_1 := abi_decode_uint64(add(headStart, offset), dataEnd)
                }
                {
                    let offset := 64
                    value_2 := abi_decode_uint64(add(headStart, offset), dataEnd)
                }
            }
            function abi_decode_uint64(offset, end) -> value {
                value := calldataload(offset)
                validator_uint64(value)
            }
            function validator_uint64(value) {
                if iszero(eq(value, cleanup_uint64(value))) { $Abort(95) }
            }
            function abi_encode_tuple_$uint64_uint64$_$u64_u64$(headStart ,value_0, value_1) -> tail {
                tail := add(headStart, 64)
                abi_encode_uint64(value_0, add(headStart, 0))
                abi_encode_uint64(value_1, add(headStart, 32))
            }
            function abi_decode_tuple_$uint64_uint64$_$u64_u64$(headStart, dataEnd) -> value_0, value_1 {
                if slt(sub(dataEnd, headStart), 64) { $Abort(96) }
                {
                    let offset := 0
                    value_0 := abi_decode_uint64(add(headStart, offset), dataEnd)
                }
                {
                    let offset := 32
                    value_1 := abi_decode_uint64(add(headStart, offset), dataEnd)
                }
            }
            function abi_encode_tuple_$bool_bool$_$bool_bool$(headStart ,value_0, value_1) -> tail {
                tail := add(headStart, 64)
                abi_encode_bool(value_0, add(headStart, 0))
                abi_encode_bool(value_1, add(headStart, 32))
            }
            function abi_encode_bool(value, pos) {
                mstore(pos, cleanup_bool(value))
            }
            function cleanup_bool(value) -> cleaned {
                cleaned := and(value, 0xff)
            }
            function abi_decode_tuple_$uint64$_$u64$(headStart, dataEnd) -> value_0 {
                if slt(sub(dataEnd, headStart), 32) { $Abort(96) }
                {
                    let offset := 0
                    value_0 := abi_decode_uint64(add(headStart, offset), dataEnd)
                }
            }
            function $Abort(code) {
                mstore(0, code)
                revert(24, 8) // TODO: store code as a string?
            }
            function $AbortBuiltin() {
                $Abort(sub(0, 1))
            }
            function $AddU64(x, y) -> r {
                if lt(sub(0xffffffffffffffff, x), y) { $AbortBuiltin() }
                r := add(x, y)
            }
            function $MulU64(x, y) -> r {
                if gt(y, div(0xffffffffffffffff, x)) { $AbortBuiltin() }
                r := mul(x, y)
            }
            function $Sub(x, y) -> r {
                if lt(x, y) { $AbortBuiltin() }
                r := sub(x, y)
            }
            function $Div(x, y) -> r {
                if eq(y, 0) { $AbortBuiltin() }
                r := div(x, y)
            }
            function $Mod(x, y) -> r {
                if eq(y, 0) { $AbortBuiltin() }
                r := mod(x, y)
            }
            function $Shr(x, y) -> r {
                r := shr(y, x)
            }
            function $Gt(x, y) -> r {
                r := gt(x, y)
            }
            function $Lt(x, y) -> r {
                r := lt(x, y)
            }
            function $GtEq(x, y) -> r {
                r := or(gt(x, y), eq(x, y))
            }
            function $LtEq(x, y) -> r {
                r := or(lt(x, y), eq(x, y))
            }
            function $Neq(x, y) -> r {
                r := $LogicalNot(eq(x, y))
            }
            function $LogicalNot(x) -> r {
                r := iszero(x)
            }
        }
    }
}


!! Succeeded compiling Yul


!! Unit tests

// test of M::test_add_two_number
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "test_A2_M_test_add_two_number" {
    code {
        mstore(0, memoryguard(160))
        A2_M_test_add_two_number()
        return (0, 0)
        function A2_M_test_add_two_number() {
            let res, z, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // $t8 := 100
                    $t8 := 100
                    // abort($t8)
                    $Abort($t8)
                }
                case 3 {
                    // label L0
                    // $t9 := 7
                    $t9 := 7
                    // $t10 := ==($t5, $t9)
                    $t10 := $Eq($t5, $t9)
                    // if ($t10) goto L2 else goto L3
                    switch $t10
                    case 0  { $block := 5 }
                    default { $block := 6 }
                }
                case 4 {
                    // $t2 := 2
                    $t2 := 2
                    // $t3 := 5
                    $t3 := 5
                    // ($t4, $t5) := M::add_two_number($t2, $t3)
                    $t4, $t5 := A2_M_add_two_number($t2, $t3)
                    // $t6 := 3
                    $t6 := 3
                    // $t7 := ==($t4, $t6)
                    $t7 := $Eq($t4, $t6)
                    // if ($t7) goto L0 else goto L1
                    switch $t7
                    case 0  { $block := 2 }
                    default { $block := 3 }
                }
                case 5 {
                    // label L3
                    // $t11 := 101
                    $t11 := 101
                    // abort($t11)
                    $Abort($t11)
                }
                case 6 {
                    // label L2
                    // return ()
                    leave
                }
            }
        }

        function A2_M_add_two_number(x, y) -> $result0, $result1 {
            let res, z, $t4, $t5
            // $t4 := +($t0, $t1)
            $t4 := $AddU64(x, y)
            // $t5 := 3
            $t5 := 3
            // return ($t5, $t4)
            $result0 := $t5
            $result1 := $t4
        }

        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $AddU64(x, y) -> r {
            if lt(sub(0xffffffffffffffff, x), y) { $AbortBuiltin() }
            r := add(x, y)
        }
        function $Eq(x, y) -> r {
            r := eq(x, y)
        }
    }
}
===> Test result of M::test_add_two_number: Succeed(Stopped) (used_gas=355): []

// test of M::test_add_two_number_overflow
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "test_A2_M_test_add_two_number_overflow" {
    code {
        mstore(0, memoryguard(160))
        A2_M_test_add_two_number_overflow()
        return (0, 0)
        function A2_M_test_add_two_number_overflow() {
            let _res, _z, $t2, $t3, $t4, $t5
            // $t2 := 18446744073709551615
            $t2 := 18446744073709551615
            // $t3 := 1
            $t3 := 1
            // ($t4, $t5) := M::add_two_number($t2, $t3)
            $t4, $t5 := A2_M_add_two_number($t2, $t3)
            // destroy($t5)
            // destroy($t4)
            // return ()
        }

        function A2_M_add_two_number(x, y) -> $result0, $result1 {
            let res, z, $t4, $t5
            // $t4 := +($t0, $t1)
            $t4 := $AddU64(x, y)
            // $t5 := 3
            $t5 := 3
            // return ($t5, $t4)
            $result0 := $t5
            $result1 := $t4
        }

        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $AddU64(x, y) -> r {
            if lt(sub(0xffffffffffffffff, x), y) { $AbortBuiltin() }
            r := add(x, y)
        }
    }
}
===> Test result of M::test_add_two_number_overflow: Revert(Reverted) (used_gas=21): [255, 255, 255, 255, 255, 255, 255, 255]

// test of M::test_add_two_number_wrong_assert
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "test_A2_M_test_add_two_number_wrong_assert" {
    code {
        mstore(0, memoryguard(160))
        A2_M_test_add_two_number_wrong_assert()
        return (0, 0)
        function A2_M_test_add_two_number_wrong_assert() {
            let res, z, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // $t8 := 100
                    $t8 := 100
                    // abort($t8)
                    $Abort($t8)
                }
                case 3 {
                    // label L0
                    // $t9 := 6
                    $t9 := 6
                    // $t10 := ==($t5, $t9)
                    $t10 := $Eq($t5, $t9)
                    // if ($t10) goto L2 else goto L3
                    switch $t10
                    case 0  { $block := 5 }
                    default { $block := 6 }
                }
                case 4 {
                    // $t2 := 2
                    $t2 := 2
                    // $t3 := 5
                    $t3 := 5
                    // ($t4, $t5) := M::add_two_number($t2, $t3)
                    $t4, $t5 := A2_M_add_two_number($t2, $t3)
                    // $t6 := 3
                    $t6 := 3
                    // $t7 := ==($t4, $t6)
                    $t7 := $Eq($t4, $t6)
                    // if ($t7) goto L0 else goto L1
                    switch $t7
                    case 0  { $block := 2 }
                    default { $block := 3 }
                }
                case 5 {
                    // label L3
                    // $t11 := 101
                    $t11 := 101
                    // abort($t11)
                    $Abort($t11)
                }
                case 6 {
                    // label L2
                    // return ()
                    leave
                }
            }
        }

        function A2_M_add_two_number(x, y) -> $result0, $result1 {
            let res, z, $t4, $t5
            // $t4 := +($t0, $t1)
            $t4 := $AddU64(x, y)
            // $t5 := 3
            $t5 := 3
            // return ($t5, $t4)
            $result0 := $t5
            $result1 := $t4
        }

        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $AddU64(x, y) -> r {
            if lt(sub(0xffffffffffffffff, x), y) { $AbortBuiltin() }
            r := add(x, y)
        }
        function $Eq(x, y) -> r {
            r := eq(x, y)
        }
    }
}
===> Test result of M::test_add_two_number_wrong_assert: Revert(Reverted) (used_gas=356): [0, 0, 0, 0, 0, 0, 0, 101]

// test of M::test_arithmetic_ops_aborts
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "test_A2_M_test_arithmetic_ops_aborts" {
    code {
        mstore(0, memoryguard(160))
        A2_M_test_arithmetic_ops_aborts()
        return (0, 0)
        function A2_M_test_arithmetic_ops_aborts() {
            let r1, r2, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // $t7 := 100
                    $t7 := 100
                    // abort($t7)
                    $Abort($t7)
                }
                case 3 {
                    // label L0
                    // $t8 := 3
                    $t8 := 3
                    // $t9 := ==($t4, $t8)
                    $t9 := $Eq($t4, $t8)
                    // if ($t9) goto L2 else goto L3
                    switch $t9
                    case 0  { $block := 5 }
                    default { $block := 6 }
                }
                case 4 {
                    // $t2 := 3
                    $t2 := 3
                    // ($t3, $t4) := M::arithmetic_ops($t2)
                    $t3, $t4 := A2_M_arithmetic_ops($t2)
                    // $t5 := 1
                    $t5 := 1
                    // $t6 := ==($t3, $t5)
                    $t6 := $Eq($t3, $t5)
                    // if ($t6) goto L0 else goto L1
                    switch $t6
                    case 0  { $block := 2 }
                    default { $block := 3 }
                }
                case 5 {
                    // label L3
                    // $t10 := 101
                    $t10 := 101
                    // abort($t10)
                    $Abort($t10)
                }
                case 6 {
                    // label L2
                    // return ()
                    leave
                }
            }
        }

        function A2_M_arithmetic_ops(a) -> $result0, $result1 {
            let c, $t2, $t3, $t4, $t5
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L0
                    // $t5 := 42
                    $t5 := 42
                    // abort($t5)
                    $Abort($t5)
                }
                case 3 {
                    // label L2
                    // return ($t2, $t0)
                    $result0 := $t2
                    $result1 := a
                    leave
                }
                case 4 {
                    // $t2 := 2
                    $t2 := 2
                    // $t3 := 2
                    $t3 := 2
                    // $t4 := !=($t2, $t3)
                    $t4 := $Neq($t2, $t3)
                    // if ($t4) goto L0 else goto L2
                    switch $t4
                    case 0  { $block := 3 }
                    default { $block := 2 }
                }
            }
        }

        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $Eq(x, y) -> r {
            r := eq(x, y)
        }
        function $Neq(x, y) -> r {
            r := $LogicalNot(eq(x, y))
        }
        function $LogicalNot(x) -> r {
            r := iszero(x)
        }
    }
}
===> Test result of M::test_arithmetic_ops_aborts: Revert(Reverted) (used_gas=404): [0, 0, 0, 0, 0, 0, 0, 100]

// test of M::test_bool_ops
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "test_A2_M_test_bool_ops" {
    code {
        mstore(0, memoryguard(160))
        A2_M_test_bool_ops()
        return (0, 0)
        function A2_M_test_bool_ops() {
            let r1, r2, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // $t8 := 100
                    $t8 := 100
                    // abort($t8)
                    $Abort($t8)
                }
                case 3 {
                    // label L0
                    // $t9 := false
                    $t9 := false
                    // $t10 := ==($t5, $t9)
                    $t10 := $Eq($t5, $t9)
                    // if ($t10) goto L2 else goto L3
                    switch $t10
                    case 0  { $block := 5 }
                    default { $block := 6 }
                }
                case 4 {
                    // $t2 := 3
                    $t2 := 3
                    // $t3 := 2
                    $t3 := 2
                    // ($t4, $t5) := M::bool_ops($t2, $t3)
                    $t4, $t5 := A2_M_bool_ops($t2, $t3)
                    // $t6 := true
                    $t6 := true
                    // $t7 := ==($t4, $t6)
                    $t7 := $Eq($t4, $t6)
                    // if ($t7) goto L0 else goto L1
                    switch $t7
                    case 0  { $block := 2 }
                    default { $block := 3 }
                }
                case 5 {
                    // label L3
                    // $t11 := 101
                    $t11 := 101
                    // abort($t11)
                    $Abort($t11)
                }
                case 6 {
                    // label L2
                    // return ()
                    leave
                }
            }
        }

        function A2_M_bool_ops(a, b) -> $result0, $result1 {
            let tmp_$2, tmp_$3, c, d, $t6, $t7, $t8, $t9, $t10, $t11, $t12
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L0
                    // $t2 := >=($t0, $t1)
                    tmp_$2 := $GtEq(a, b)
                    // goto L3
                    $block := 5
                }
                case 3 {
                    // label L2
                    // $t7 := false
                    $t7 := false
                    // $t2 := $t7
                    tmp_$2 := $t7
                    // goto L3
                    $block := 5
                }
                case 4 {
                    // $t6 := >($t0, $t1)
                    $t6 := $Gt(a, b)
                    // if ($t6) goto L0 else goto L2
                    switch $t6
                    case 0  { $block := 3 }
                    default { $block := 2 }
                }
                case 5 {
                    // label L3
                    // $t8 := <($t0, $t1)
                    $t8 := $Lt(a, b)
                    // if ($t8) goto L4 else goto L6
                    switch $t8
                    case 0  { $block := 7 }
                    default { $block := 6 }
                }
                case 6 {
                    // label L4
                    // $t9 := true
                    $t9 := true
                    // $t3 := $t9
                    tmp_$3 := $t9
                    // goto L7
                    $block := 8
                }
                case 7 {
                    // label L6
                    // $t3 := <=($t0, $t1)
                    tmp_$3 := $LtEq(a, b)
                    // goto L7
                    $block := 8
                }
                case 8 {
                    // label L7
                    // $t10 := !=($t2, $t3)
                    $t10 := $Neq(tmp_$2, tmp_$3)
                    // $t11 := !($t10)
                    $t11 := $LogicalNot($t10)
                    // if ($t11) goto L8 else goto L10
                    switch $t11
                    case 0  { $block := 10 }
                    default { $block := 9 }
                }
                case 9 {
                    // label L8
                    // $t12 := 42
                    $t12 := 42
                    // abort($t12)
                    $Abort($t12)
                }
                case 10 {
                    // label L10
                    // return ($t2, $t3)
                    $result0 := tmp_$2
                    $result1 := tmp_$3
                    leave
                }
            }
        }

        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $Gt(x, y) -> r {
            r := gt(x, y)
        }
        function $Lt(x, y) -> r {
            r := lt(x, y)
        }
        function $GtEq(x, y) -> r {
            r := or(gt(x, y), eq(x, y))
        }
        function $LtEq(x, y) -> r {
            r := or(lt(x, y), eq(x, y))
        }
        function $Eq(x, y) -> r {
            r := eq(x, y)
        }
        function $Neq(x, y) -> r {
            r := $LogicalNot(eq(x, y))
        }
        function $LogicalNot(x) -> r {
            r := iszero(x)
        }
    }
}
===> Test result of M::test_bool_ops: Succeed(Stopped) (used_gas=1228): []

// test of M::test_bool_ops_aborts
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "test_A2_M_test_bool_ops_aborts" {
    code {
        mstore(0, memoryguard(160))
        A2_M_test_bool_ops_aborts()
        return (0, 0)
        function A2_M_test_bool_ops_aborts() {
            let r1, r2, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // $t6 := 100
                    $t6 := 100
                    // abort($t6)
                    $Abort($t6)
                }
                case 3 {
                    // label L0
                    // $t7 := !=($t2, $t3)
                    $t7 := $Neq($t2, $t3)
                    // if ($t7) goto L2 else goto L3
                    switch $t7
                    case 0  { $block := 5 }
                    default { $block := 6 }
                }
                case 4 {
                    // $t2 := true
                    $t2 := true
                    // $t3 := false
                    $t3 := false
                    // $t4 := ==($t2, $t3)
                    $t4 := $Eq($t2, $t3)
                    // $t5 := !($t4)
                    $t5 := $LogicalNot($t4)
                    // if ($t5) goto L0 else goto L1
                    switch $t5
                    case 0  { $block := 2 }
                    default { $block := 3 }
                }
                case 5 {
                    // label L3
                    // $t8 := 101
                    $t8 := 101
                    // abort($t8)
                    $Abort($t8)
                }
                case 6 {
                    // label L2
                    // $t9 := !($t2)
                    $t9 := $LogicalNot($t2)
                    // $t10 := !($t3)
                    $t10 := $LogicalNot($t3)
                    // $t11 := !=($t9, $t10)
                    $t11 := $Neq($t9, $t10)
                    // if ($t11) goto L4 else goto L5
                    switch $t11
                    case 0  { $block := 7 }
                    default { $block := 8 }
                }
                case 7 {
                    // label L5
                    // $t12 := 102
                    $t12 := 102
                    // abort($t12)
                    $Abort($t12)
                }
                case 8 {
                    // label L4
                    // $t13 := !($t3)
                    $t13 := $LogicalNot($t3)
                    // if ($t13) goto L6 else goto L7
                    switch $t13
                    case 0  { $block := 9 }
                    default { $block := 10 }
                }
                case 9 {
                    // label L7
                    // $t14 := 103
                    $t14 := 103
                    // abort($t14)
                    $Abort($t14)
                }
                case 10 {
                    // label L6
                    // $t15 := !($t2)
                    $t15 := $LogicalNot($t2)
                    // if ($t15) goto L8 else goto L9
                    switch $t15
                    case 0  { $block := 11 }
                    default { $block := 12 }
                }
                case 11 {
                    // label L9
                    // $t16 := 104
                    $t16 := 104
                    // abort($t16)
                    $Abort($t16)
                }
                case 12 {
                    // label L8
                    // return ()
                    leave
                }
            }
        }

        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $Eq(x, y) -> r {
            r := eq(x, y)
        }
        function $Neq(x, y) -> r {
            r := $LogicalNot(eq(x, y))
        }
        function $LogicalNot(x) -> r {
            r := iszero(x)
        }
    }
}
===> Test result of M::test_bool_ops_aborts: Revert(Reverted) (used_gas=1081): [0, 0, 0, 0, 0, 0, 0, 104]

// test of M::test_div
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "test_A2_M_test_div" {
    code {
        mstore(0, memoryguard(160))
        A2_M_test_div()
        return (0, 0)
        function A2_M_test_div() {
            let r1, r2, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // $t8 := 100
                    $t8 := 100
                    // abort($t8)
                    $Abort($t8)
                }
                case 3 {
                    // label L0
                    // $t9 := 3
                    $t9 := 3
                    // $t10 := ==($t5, $t9)
                    $t10 := $Eq($t5, $t9)
                    // if ($t10) goto L2 else goto L3
                    switch $t10
                    case 0  { $block := 5 }
                    default { $block := 6 }
                }
                case 4 {
                    // $t2 := 7
                    $t2 := 7
                    // $t3 := 4
                    $t3 := 4
                    // ($t4, $t5) := M::div($t2, $t3)
                    $t4, $t5 := A2_M_div($t2, $t3)
                    // $t6 := 1
                    $t6 := 1
                    // $t7 := ==($t4, $t6)
                    $t7 := $Eq($t4, $t6)
                    // if ($t7) goto L0 else goto L1
                    switch $t7
                    case 0  { $block := 2 }
                    default { $block := 3 }
                }
                case 5 {
                    // label L3
                    // $t11 := 101
                    $t11 := 101
                    // abort($t11)
                    $Abort($t11)
                }
                case 6 {
                    // label L2
                    // return ()
                    leave
                }
            }
        }

        function A2_M_div(x, y) -> $result0, $result1 {
            let $t2, $t3
            // $t2 := /($t0, $t1)
            $t2 := $Div(x, y)
            // $t3 := %($t0, $t1)
            $t3 := $Mod(x, y)
            // return ($t2, $t3)
            $result0 := $t2
            $result1 := $t3
        }

        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $Div(x, y) -> r {
            if eq(y, 0) { $AbortBuiltin() }
            r := div(x, y)
        }
        function $Mod(x, y) -> r {
            if eq(y, 0) { $AbortBuiltin() }
            r := mod(x, y)
        }
        function $Eq(x, y) -> r {
            r := eq(x, y)
        }
    }
}
===> Test result of M::test_div: Succeed(Stopped) (used_gas=355): []

// test of M::test_div_by_zero
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "test_A2_M_test_div_by_zero" {
    code {
        mstore(0, memoryguard(160))
        A2_M_test_div_by_zero()
        return (0, 0)
        function A2_M_test_div_by_zero() {
            let _r1, _r2, $t2, $t3, $t4, $t5
            // $t2 := 7
            $t2 := 7
            // $t3 := 0
            $t3 := 0
            // ($t4, $t5) := M::div($t2, $t3)
            $t4, $t5 := A2_M_div($t2, $t3)
            // destroy($t5)
            // destroy($t4)
            // return ()
        }

        function A2_M_div(x, y) -> $result0, $result1 {
            let $t2, $t3
            // $t2 := /($t0, $t1)
            $t2 := $Div(x, y)
            // $t3 := %($t0, $t1)
            $t3 := $Mod(x, y)
            // return ($t2, $t3)
            $result0 := $t2
            $result1 := $t3
        }

        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $Div(x, y) -> r {
            if eq(y, 0) { $AbortBuiltin() }
            r := div(x, y)
        }
        function $Mod(x, y) -> r {
            if eq(y, 0) { $AbortBuiltin() }
            r := mod(x, y)
        }
    }
}
===> Test result of M::test_div_by_zero: Revert(Reverted) (used_gas=21): [255, 255, 255, 255, 255, 255, 255, 255]

// test of M::test_div_wrong_assert
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "test_A2_M_test_div_wrong_assert" {
    code {
        mstore(0, memoryguard(160))
        A2_M_test_div_wrong_assert()
        return (0, 0)
        function A2_M_test_div_wrong_assert() {
            let r1, r2, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // $t8 := 100
                    $t8 := 100
                    // abort($t8)
                    $Abort($t8)
                }
                case 3 {
                    // label L0
                    // $t9 := 2
                    $t9 := 2
                    // $t10 := ==($t5, $t9)
                    $t10 := $Eq($t5, $t9)
                    // if ($t10) goto L2 else goto L3
                    switch $t10
                    case 0  { $block := 5 }
                    default { $block := 6 }
                }
                case 4 {
                    // $t2 := 7
                    $t2 := 7
                    // $t3 := 4
                    $t3 := 4
                    // ($t4, $t5) := M::div($t2, $t3)
                    $t4, $t5 := A2_M_div($t2, $t3)
                    // $t6 := 1
                    $t6 := 1
                    // $t7 := ==($t4, $t6)
                    $t7 := $Eq($t4, $t6)
                    // if ($t7) goto L0 else goto L1
                    switch $t7
                    case 0  { $block := 2 }
                    default { $block := 3 }
                }
                case 5 {
                    // label L3
                    // $t11 := 101
                    $t11 := 101
                    // abort($t11)
                    $Abort($t11)
                }
                case 6 {
                    // label L2
                    // return ()
                    leave
                }
            }
        }

        function A2_M_div(x, y) -> $result0, $result1 {
            let $t2, $t3
            // $t2 := /($t0, $t1)
            $t2 := $Div(x, y)
            // $t3 := %($t0, $t1)
            $t3 := $Mod(x, y)
            // return ($t2, $t3)
            $result0 := $t2
            $result1 := $t3
        }

        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $Div(x, y) -> r {
            if eq(y, 0) { $AbortBuiltin() }
            r := div(x, y)
        }
        function $Mod(x, y) -> r {
            if eq(y, 0) { $AbortBuiltin() }
            r := mod(x, y)
        }
        function $Eq(x, y) -> r {
            r := eq(x, y)
        }
    }
}
===> Test result of M::test_div_wrong_assert: Revert(Reverted) (used_gas=348): [0, 0, 0, 0, 0, 0, 0, 101]

// test of M::test_multiple_ops
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "test_A2_M_test_multiple_ops" {
    code {
        mstore(0, memoryguard(160))
        A2_M_test_multiple_ops()
        return (0, 0)
        function A2_M_test_multiple_ops() {
            let r, $t1, $t2, $t3, $t4, $t5, $t6, $t7
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // $t7 := 100
                    $t7 := 100
                    // abort($t7)
                    $Abort($t7)
                }
                case 3 {
                    // label L0
                    // return ()
                    leave
                }
                case 4 {
                    // $t1 := 3
                    $t1 := 3
                    // $t2 := 2
                    $t2 := 2
                    // $t3 := 5
                    $t3 := 5
                    // $t4 := M::multiple_ops($t1, $t2, $t3)
                    $t4 := A2_M_multiple_ops($t1, $t2, $t3)
                    // $t5 := 13
                    $t5 := 13
                    // $t6 := ==($t4, $t5)
                    $t6 := $Eq($t4, $t5)
                    // if ($t6) goto L0 else goto L1
                    switch $t6
                    case 0  { $block := 2 }
                    default { $block := 3 }
                }
            }
        }

        function A2_M_multiple_ops(x, y, z) -> $result {
            let $t3, $t4
            // $t3 := *($t1, $t2)
            $t3 := $MulU64(y, z)
            // $t4 := +($t0, $t3)
            $t4 := $AddU64(x, $t3)
            // return $t4
            $result := $t4
        }

        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $AddU64(x, y) -> r {
            if lt(sub(0xffffffffffffffff, x), y) { $AbortBuiltin() }
            r := add(x, y)
        }
        function $MulU64(x, y) -> r {
            if gt(y, div(0xffffffffffffffff, x)) { $AbortBuiltin() }
            r := mul(x, y)
        }
        function $Eq(x, y) -> r {
            r := eq(x, y)
        }
    }
}
===> Test result of M::test_multiple_ops: Succeed(Stopped) (used_gas=176): []

// test of M::test_multiple_overflow
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "test_A2_M_test_multiple_overflow" {
    code {
        mstore(0, memoryguard(160))
        A2_M_test_multiple_overflow()
        return (0, 0)
        function A2_M_test_multiple_overflow() {
            let r, $t1, $t2, $t3, $t4, $t5, $t6, $t7
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // $t7 := 100
                    $t7 := 100
                    // abort($t7)
                    $Abort($t7)
                }
                case 3 {
                    // label L0
                    // return ()
                    leave
                }
                case 4 {
                    // $t1 := 0
                    $t1 := 0
                    // $t2 := 18446744073709551615
                    $t2 := 18446744073709551615
                    // $t3 := 2
                    $t3 := 2
                    // $t4 := M::multiple_ops($t1, $t2, $t3)
                    $t4 := A2_M_multiple_ops($t1, $t2, $t3)
                    // $t5 := 0
                    $t5 := 0
                    // $t6 := ==($t4, $t5)
                    $t6 := $Eq($t4, $t5)
                    // if ($t6) goto L0 else goto L1
                    switch $t6
                    case 0  { $block := 2 }
                    default { $block := 3 }
                }
            }
        }

        function A2_M_multiple_ops(x, y, z) -> $result {
            let $t3, $t4
            // $t3 := *($t1, $t2)
            $t3 := $MulU64(y, z)
            // $t4 := +($t0, $t3)
            $t4 := $AddU64(x, $t3)
            // return $t4
            $result := $t4
        }

        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $AddU64(x, y) -> r {
            if lt(sub(0xffffffffffffffff, x), y) { $AbortBuiltin() }
            r := add(x, y)
        }
        function $MulU64(x, y) -> r {
            if gt(y, div(0xffffffffffffffff, x)) { $AbortBuiltin() }
            r := mul(x, y)
        }
        function $Eq(x, y) -> r {
            r := eq(x, y)
        }
    }
}
===> Test result of M::test_multiple_overflow: Revert(Reverted) (used_gas=21): [255, 255, 255, 255, 255, 255, 255, 255]

// test of M::test_underflow
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "test_A2_M_test_underflow" {
    code {
        mstore(0, memoryguard(160))
        A2_M_test_underflow()
        return (0, 0)
        function A2_M_test_underflow() {
            let _r, $t1
            // $t1 := M::underflow()
            $t1 := A2_M_underflow()
            // destroy($t1)
            // return ()
        }

        function A2_M_underflow() -> $result {
            let x, $t1, $t2, $t3
            // $t1 := 0
            $t1 := 0
            // $t2 := 1
            $t2 := 1
            // $t3 := -($t1, $t2)
            $t3 := $Sub($t1, $t2)
            // return $t3
            $result := $t3
        }

        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $Sub(x, y) -> r {
            if lt(x, y) { $AbortBuiltin() }
            r := sub(x, y)
        }
    }
}
===> Test result of M::test_underflow: Revert(Reverted) (used_gas=21): [255, 255, 255, 255, 255, 255, 255, 255]
