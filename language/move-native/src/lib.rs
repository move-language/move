// Copyright (c) The Diem Core Contributors
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0

//! A Move native runtime prototype.
//!
//! This crate is part of the Solana project to port Move to LLVM and SBF.
//!
//! It contains three types of definitions
//!
//! - Types with layouts known to the compiler for the purposes of calling
//!   runtime functions. These have simple C-ABI layouts.
//! - "Native" library functions required by the Move standard library, calls to
//!   which are generated by the LLVM backend.
//! - Runtime functions specific to the LLVM port as necessary to dynamically
//!   implement Move semantics.
//!
//! As of now this crate is concerned only with implementing Move "natives"
//! required by the Move standard library. The basic strategy is to define
//! simple data types for primitives like scalars and vectors, and runtime types
//! like type descriptors; and naming and calling conventions for translating
//! Move native calls to C-ABI calls. The native implementations convert the
//! Move types to existing Rust types like `Vec` to do their work.
//!
//! It contains several modules dividing the crate by concerns:
//!
//! - `rt_types` defines the types shared between LLVM and the runtime.
//! - `rt` defines other runtime calls emitted by the compiler
//! - `std` defines the native functions called declared by Move `std`.
//! - `conv` defines conversions between Move types and Rust types.
//! - `target_defs` defines Solana-specific definitions that differ from Move VM
//!   or might reasonably differ for non-Solana targets.
//!
//!
//! # Native functions background
//!
//! Native functions in Move are functions that the standard library relies on
//! the runtime to provide. They are declared with the `native` keyword and no
//! implementation. They are similar to `extern` functions in Rust.
//!
//! Here are some examples:
//!
//! ```move
//!    native public fun sha2_256(data: vector<u8>): vector<u8>;
//!
//!    /// Add element `e` to the end of the vector `v`.
//!    native public fun push_back<Element>(v: &mut vector<Element>, e: Element);
//!
//!    /// Pop an element from the end of vector `v`.
//!    /// Aborts if `v` is empty.
//!    native public fun pop_back<Element>(v: &mut vector<Element>): Element;
//!
//!    /// Return the binary representation of `v` in BCS (Binary Canonical Serialization) format
//!    native public fun to_bytes<MoveValue>(v: &MoveValue): vector<u8>;
//! ```
//!
//! In the Move VM these are implemented in Rust and registered with the VM at
//! runtime. These implementations are tightly tied to VM internals, and include
//! features like gas accounting that are irrelevant for the LLVM port. They are
//! not directly reusable by the LLVM port at this time.
//!
//!
//! # Generics and type interpretation
//!
//! The translation between Move native declarations and the C ABI is relatively
//! straightforward, with conventions described further in this document.
//!
//! The big complication is that many natives are generic, so there are choices
//! to be made about how to interpret type descriptors.
//!
//! This implementation interprets types at runtime by passing a [`MoveType`]
//! reference for every generic type. The `MoveType` definition closely mirrors
//! the Move compiler's `runtime_type::Type` definition.
//!
//! It appears that the native calls mostly need to know about size and
//! alignment of types to implement things like generic vector operations. There
//! are though functions for serialization and debug printing that would appear
//! to require fully interpreting arbitrary Move types. It is not yet clear
//! what challenges this will entail.
//!
//! Embedding full type interpreters into the runtime means that every Move
//! program will contain code for interpreting every possible type, including
//! those it does not need. There may be ways to mitigate this bloat with clever
//! structure and LTO, but it is unclear.
//!
//! The alternative to runtime type interpretation is to have the compiler emit
//! monomorphizations of native calls. This would appear to be a challenging
//! problem, one that might be easiest solved by having the compiler emit Rust
//! code to instantiate generic natives. This approach could be left to a future
//! optimization.
//!
//!
//! # Reusing move crates and `no-std`
//!
//! For portability it could be desirable to not depend on `std`.
//!
//! It may be necessary to reuse existing move crates, which will force this
//! crate to depend on Rust `std`. For Solana this probably won't present a
//! problem as Solana has a mostly-complete port of `std`.
//!
//! Move serialization at least depends ot the [`bcs`] crate, which has relatively
//! few dependencies, but does depend on `std`. It could conceivably be adopted
//! to a `no-std` environment.
//!
//! This crate itself doesn't directly use `std`.
//!
//!
//! # Platform compatibility
//!
//! Some definitions are different on Solana than on Move VM.
//!
//! - An address is 32 bytes to match Solana pubkeys. On Move VM an address is
//!   16 bytes by default but can be configured as 20 or 32 bytes at compile
//!   time.
//!
//!
//! # Naming conventions
//!
//! Within the Move VM natives are identified by a module name plus a function
//! name, like "vector" + "push_back". They do not appear to additionally be
//! identified by a library name like "std".
//!
//! Our native symbol names are a concatenation of the prefix "move_native_",
//! plus the module name and function name. So the vector `push_back` function
//! symbol is
//!
//! > `move_native_vector_push_back`
//!
//! In Rust code, native functions are defined under the `std` module, in
//! submodules that mirror the module heirarchy of the Move standard library,
//! and their final symbol names are given through the `export_name` attribute.
//!
//! Runtime functions needed by the compiler are prefixed "move_rt_",
//! like `move_rt_abort`.
//!
//!
//! # Data types
//!
//! Data types known to both the compiler and the runtime are defined in [`rt_types`].
//! They are all declared with explicit `repr` attributes to have a defined layout that
//! is easy to codegen.
//!
//! The most important types for the compiler and the vector type,
//! [`MoveUntypedVector`] here, and the type descriptor, here [`MoveType`].
//!
//! `MoveType` is similar to `move_vm_types::runtime_types::Type`, but with a
//! structure that does not rely on Rust-specific type layout. `MoveType`
//! contains recursive `&'static` references to other `MoveType`s, necessitating
//! that binaries contain a static table of all needed type descriptors.
//!
//! Generic values are represented by references or pointers to [`AnyType`],
//! which is simply a transparent wrapper around a u8, pointers to which must
//! be unsafely casted based on an accompanying `MoveType`.
//!
//! Move references as interpreted by `TypeDesc` are assumed to always be
//! pointers - no fat pointers.
//!
//! The types defined in `rt_types` will change. The exact definitions will
//! depend on decisions made for code generation.
//!
//!
//! ## Vectors and strings
//!
//! Move vectors are operated on by casting to Rust vectors and reusing the Rust
//! methods. Move vectors have the same layout as Rust vecs, on the theory this
//! may save a few instructions during conversions.
//!
//! Move strings are a library type and not known to the Move compiler†.
//! They are a wrapper around byte vectors, and native string calls are
//! operations on `MoveByteVector`.
//!
//! Vectors must be allocated with the [`move_native_vec_empty`] and deallocated
//! with the [`move_native_vec_destroy_empty`] runtime calls.
//!
//! † - note that although `String` is a library type, the ASCII `String` (move
//! has UTF-8 and ASCII strings) is exposed to the runtime via the `TypeName`
//! library type, which is passed by value in the [`move_native_type_name_get`]
//! native function, the code generator and the runtime need to agree on its
//! layout.
//!
//!
//! ## Structs
//!
//! Structs are difficult for the runtime to handle. Since they have arbitrary
//! layout the runtime has to interpret them dynamically.
//!
//! The struct type descriptor specifies the struct's size, including
//! post-padding as needed for side-by-side layout in arrays, and its alignment;
//! and it specifies the types and offsets of every field.
//!
//! Requirements:
//!
//! - Size must be > 0
//! - Alignment must be > 0
//! - Alignment must be a power of 2
//! - Size rounded up to alignment must not overflow a pointer-sized signed integer
//!
//! Since the vector-of-struct code is necessarily very low level, not reusing
//! the actual Rust Vec methods, we may end up just doing the same for vecs of
//! all types. Super unsafe but more efficient than using typed Rust vectors.
//!
//!
//! # Calling conventions
//!
//! The calling conventions are straightforword, following the C ABI, with some
//! extra patterns necessary for things like Move type parameters and unsized
//! generic values.
//!
//! - type parameters
//!   - passed as `&MoveType`
//! - by-ref generic types
//!   - passed by `&AnyType`
//! - by-value generic types
//!   - passed by `*mut AnyType`
//!   - examples: `write_to_event_store`
//! - by-value generic return types
//!   - stack-allocated return pointer of `*mut AnyType`
//!   - examples: `pop_back`
//!
//!
//! # Panic handling
//!
//! This crate does not handle panics at the FFI boundary. When used in a
//! runtime context it should be compiled such that panics trigger an abort.
//!
//! At this time it does not define its own panic handler, but probably will in
//! the future.
//!
//!
//! # References
//!
//! Useful Move code to read.
//!
//! - `move-stdlib::natives`
//! - `move-vm-types::loaded_data::Type`
//! - `move-vm-types::values::Value`
//! - `move-core-types::value`
//!
//!
//! # todo
//!
//! - type constraints
//!   - `write_to_event_store<T: drop + store>`
//!   - may not matter at runtime
//! - generic by-value and return arguments might instead be `&mut MaybeUninit<SomeUnsizedPlaceholder>`
//!   - llvm would need to write a fat pointer - do they have defined layout?
//! - should serialization maintain compatibility with move vm?
//! - add context to unwrapped errors
//! - vec_empty/destroy_empty can be implemented unsafely for all cases, is in the struct case
//! - _all_ vec ops for all cases can probably be implemented using an
//!   adaptation of the vector-of-struct case, at which point we probably don't
//!   even need to use Rust vecs at all, at the expense of some readability.
//! - struct serialize / debug don't include struct / field names
//! - add a full test suite
//! - make sure tests can be run under miri
//! - todo add drop-bombs to other rt_types with allocations
//! - remove transmutes to make the semantics clearer to miri?

#![no_std]

// NB Solana's Rust seems to allow use of unstable features.
// This wouldn't normally be allowed.
#![cfg_attr(feature = "solana", feature(default_alloc_error_handler))]

extern crate alloc;

mod serialization;

/// Types literally shared with the compiler through crate linkage.
pub mod shared {
    pub use crate::rt_types::TypeDesc;
    pub use crate::rt_types::MOVE_UNTYPED_VEC_DESC_SIZE;
    pub use crate::rt_types::MOVE_TYPE_DESC_SIZE;
}

/// Types known to the compiler.
mod rt_types;

/// Runtime calls emitted by the compiler.
/// Reference: move/language/documentation/book/src/abort-and-assert.md
mod rt;

/// Implementations of native calls for `std`.
mod std;

/// Conversion from move types to rust types.
mod conv;

/// Move vector support, used by both `rt` and `std`.
mod vector;

/// Move struct support.
mod structs;

/// Compatibility with the target platform, e.g. Solana.
mod target_defs;

#[cfg(test)]
mod tests;
