// Copyright © Aptos Foundation
// Parts of the project are originally copyright © Meta Platforms, Inc.
// SPDX-License-Identifier: Apache-2.0

use codespan_reporting::diagnostic::Severity;
use ethnum::U256;
use move_model::{
    ast::{Exp, ExpData, Operation, TempIndex, Value},
    model::{FunId, FunctionEnv, GlobalEnv, Loc, NodeId, Parameter, QualifiedId},
    symbol::Symbol,
    ty::{PrimitiveType, Type},
};
use move_stackless_bytecode::{
    function_target::FunctionData,
    stackless_bytecode::{AssignKind, AttrId, Bytecode, Constant, Operation as BytecodeOperation},
};
use num::ToPrimitive;
use std::collections::{BTreeMap, BTreeSet, VecDeque};

// ======================================================================================
// Entry

/// Generate code for the given function from it's AST representation in the env.
/// This returns `FunctionData` suitable for the bytecode processing pipeline.
pub fn generate_bytecode(env: &GlobalEnv, fid: QualifiedId<FunId>) -> FunctionData {
    let func_env = env.get_function(fid);
    let mut gen = Generator {
        func_env,
        temps: Default::default(),
        scopes: Default::default(),
        attr_table: Default::default(),
        code: vec![],
    };
    let mut scope = BTreeMap::new();
    for Parameter(name, ty) in gen.func_env.get_parameters() {
        let temp = gen.new_temp(ty);
        scope.insert(name, temp);
    }
    let mut results = vec![];
    for ty in gen.func_env.get_result_type().flatten() {
        let temp = gen.new_temp(ty);
        results.push(temp)
    }
    gen.scopes.push_back(scope);
    if let Some(def) = gen.func_env.get_def().cloned() {
        // Need to clone expression if present because of sharing issues with `gen`. However, because
        // of internalization, clone is cheap.
        gen.gen(results.clone(), &def);
        gen.emit_with(def.node_id(), |attr| Bytecode::Ret(attr, results))
    }
    let Generator {
        func_env,
        temps,
        scopes: _,
        attr_table,
        code,
    } = gen;
    FunctionData::new(
        &func_env,
        code,
        temps,
        func_env.get_result_type(),
        attr_table,
        BTreeMap::default(),
        vec![],
        BTreeMap::default(),
        BTreeSet::default(),
    )
}

// ======================================================================================
// Generator state and helpers

/// Internal state of the code generator
struct Generator<'env> {
    /// Access to the function env and its parent.
    func_env: FunctionEnv<'env>,
    /// The temporaries allocated so far.
    temps: Vec<Type>,
    /// A list of scopes, where each scope is a map from symbol to  assigned temporary.
    scopes: VecDeque<BTreeMap<Symbol, TempIndex>>,
    /// A table for attributes of generated bytecode. Contains source location info.
    attr_table: BTreeMap<AttrId, Loc>,
    /// The bytecode, as generated so far.
    code: Vec<Bytecode>,
    // TODO: location_table,
    //  loop_unrolling,
    //  loop_invariants,
    //  fallthrough_labels
}

impl<'env> Generator<'env> {
    /// Shortcut to access global env.
    fn env(&self) -> &GlobalEnv {
        self.func_env.module_env.env
    }

    /// Emit a bytecode.
    fn emit(&mut self, b: Bytecode) {
        self.code.push(b)
    }

    // Emit bytecode with attribute derived from node_id.
    fn emit_with(&mut self, id: NodeId, mk: impl FnOnce(AttrId) -> Bytecode) {
        let bytecode = mk(self.new_loc_attr(id));
        self.emit(bytecode)
    }

    /// Create a new attribute id and populate location table.
    fn new_loc_attr(&mut self, id: NodeId) -> AttrId {
        let loc = self.env().get_node_loc(id);
        let attr = AttrId::new(self.attr_table.len());
        self.attr_table.insert(attr, loc);
        attr
    }

    /// Create a new temporary of type.
    fn new_temp(&mut self, ty: Type) -> TempIndex {
        let next_idx = self.temps.len();
        self.temps.insert(next_idx, ty);
        next_idx
    }

    /// Require unary target
    fn require_unary_target(&mut self, id: NodeId, target: Vec<TempIndex>) -> TempIndex {
        if target.len() != 1 {
            self.internal_error(id, "inconsistent expression target arity");
            0
        } else {
            target[0]
        }
    }

    /// Report an (internal) error at the location associated with the node.
    fn internal_error(&self, id: NodeId, msg: impl AsRef<str>) {
        let env = self.env();
        let loc = env.get_node_loc(id);
        env.diag(
            Severity::Bug,
            &loc,
            &format!("[bytecode-generator] {}", msg.as_ref()),
        )
    }
}

// ======================================================================================
// Dispatcher

impl<'env> Generator<'env> {
    /// Generate code, for the given expression, and store the result in the given temporary.
    fn gen(&mut self, targets: Vec<TempIndex>, exp: &Exp) {
        match exp.as_ref() {
            ExpData::Invalid(id) => self.internal_error(*id, "invalid expression"),
            ExpData::Temporary(id, temp) => self.gen_temporary(targets, *id, *temp),
            ExpData::Value(id, val) => self.gen_value(targets, *id, val),
            ExpData::LocalVar(id, name) => self.gen_local(targets, *id, *name),
            ExpData::Call(id, op, args) => self.gen_call(targets, *id, op, args),
            ExpData::Invoke(id, _, _)
            | ExpData::Lambda(id, _, _)
            | ExpData::Block(id, _, _, _)
            | ExpData::IfElse(id, _, _, _)
            | ExpData::Return(id, _)
            | ExpData::Sequence(id, _)
            | ExpData::Loop(id, _)
            | ExpData::LoopCont(id, _)
            | ExpData::Assign(id, _, _) => self.internal_error(*id, "not yet implemented"),
            ExpData::Quant(id, _, _, _, _, _) => {
                self.internal_error(*id, "unsupported specification construct")
            },
        }
    }
}

// ======================================================================================
// Values

impl<'env> Generator<'env> {
    fn gen_value(&mut self, target: Vec<TempIndex>, id: NodeId, val: &Value) {
        let target = self.require_unary_target(id, target);
        let cons = self.to_constant(id, val);
        self.emit_with(id, |attr| Bytecode::Load(attr, target, cons))
    }

    /// Convert a value from AST world into a constant as expected in bytecode.
    fn to_constant(&self, id: NodeId, val: &Value) -> Constant {
        let ty = self.env().get_node_type(id);
        match val {
            Value::Address(x) => Constant::Address(x.clone()),
            Value::Number(x) => match ty {
                // In the AST, all numbers are uniquely represent by `BigInt`. The bytecode
                // distinguishes representations, we need to do a type based conversion.
                Type::Primitive(PrimitiveType::U8) => Constant::U8(x.to_u8().unwrap_or_default()),
                Type::Primitive(PrimitiveType::U16) => {
                    Constant::U16(x.to_u16().unwrap_or_default())
                },
                Type::Primitive(PrimitiveType::U32) => {
                    Constant::U32(x.to_u32().unwrap_or_default())
                },
                Type::Primitive(PrimitiveType::U64) => {
                    Constant::U64(x.to_u64().unwrap_or_default())
                },
                Type::Primitive(PrimitiveType::U128) => {
                    Constant::U128(x.to_u128().unwrap_or_default())
                },
                Type::Primitive(PrimitiveType::U256) => {
                    // No direct way to go from BigInt to ethnum::U256...
                    let x = U256::from_str_radix(&x.to_str_radix(16), 16).unwrap();
                    Constant::U256(x)
                },
                ty => {
                    self.internal_error(id, format!("inconsistent numeric constant: {:?}", ty));
                    Constant::Bool(false)
                },
            },
            Value::Bool(x) => Constant::Bool(*x),
            Value::ByteArray(x) => Constant::ByteArray(x.clone()),
            Value::AddressArray(x) => Constant::AddressArray(x.clone()),
            Value::Vector(x) => {
                Constant::Vector(x.iter().map(|v| self.to_constant(id, v)).collect())
            },
        }
    }
}

// ======================================================================================
// Locals

impl<'env> Generator<'env> {
    fn gen_local(&mut self, targets: Vec<TempIndex>, id: NodeId, name: Symbol) {
        let target = self.require_unary_target(id, targets);
        let attr = self.new_loc_attr(id);
        for scope in &self.scopes {
            if let Some(temp) = scope.get(&name) {
                self.emit(Bytecode::Assign(attr, target, *temp, AssignKind::Copy));
                return;
            }
        }
        self.internal_error(
            id,
            format!(
                "unbound symbol `{}`",
                name.display(self.env().symbol_pool())
            ),
        )
    }

    fn gen_temporary(&mut self, targets: Vec<TempIndex>, id: NodeId, temp: TempIndex) {
        let target = self.require_unary_target(id, targets);
        self.emit_with(id, |attr| {
            Bytecode::Assign(attr, target, temp, AssignKind::Copy)
        })
    }
}

// ======================================================================================
// Calls

impl<'env> Generator<'env> {
    fn gen_call(&mut self, targets: Vec<TempIndex>, id: NodeId, op: &Operation, args: &[Exp]) {
        match op {
            Operation::Pack(_, _) | Operation::Exists(_) | Operation::BorrowGlobal(_) => {
                self.internal_error(id, "not yet implemented")
            },
            Operation::MoveFunction(m, f) => {
                self.gen_function_call(targets, id, m.qualified(*f), args)
            },
            Operation::Cast => self.gen_cast_call(targets, id, args),
            Operation::Add => self.gen_op_call(targets, id, BytecodeOperation::Add, args),
            Operation::Sub => self.gen_op_call(targets, id, BytecodeOperation::Sub, args),
            Operation::Mul => self.gen_op_call(targets, id, BytecodeOperation::Mul, args),
            Operation::Mod => self.gen_op_call(targets, id, BytecodeOperation::Mod, args),
            Operation::Div => self.gen_op_call(targets, id, BytecodeOperation::Div, args),
            Operation::BitOr => self.gen_op_call(targets, id, BytecodeOperation::BitOr, args),
            Operation::BitAnd => self.gen_op_call(targets, id, BytecodeOperation::BitAnd, args),
            Operation::Xor => self.gen_op_call(targets, id, BytecodeOperation::Xor, args),
            Operation::Shl => self.gen_op_call(targets, id, BytecodeOperation::Shl, args),
            Operation::Shr => self.gen_op_call(targets, id, BytecodeOperation::Shr, args),
            Operation::And => self.gen_op_call(targets, id, BytecodeOperation::And, args),
            Operation::Or => self.gen_op_call(targets, id, BytecodeOperation::Or, args),
            Operation::Eq => self.gen_op_call(targets, id, BytecodeOperation::Eq, args),
            Operation::Neq => self.gen_op_call(targets, id, BytecodeOperation::Neq, args),
            Operation::Lt => self.gen_op_call(targets, id, BytecodeOperation::Lt, args),
            Operation::Gt => self.gen_op_call(targets, id, BytecodeOperation::Gt, args),
            Operation::Le => self.gen_op_call(targets, id, BytecodeOperation::Le, args),
            Operation::Ge => self.gen_op_call(targets, id, BytecodeOperation::Ge, args),
            Operation::Not => self.gen_op_call(targets, id, BytecodeOperation::Not, args),

            // Non-supported specification related operations
            Operation::SpecFunction(_, _, _)
            | Operation::Implies
            | Operation::Iff
            | Operation::Tuple
            | Operation::Select(_, _, _)
            | Operation::UpdateField(_, _, _)
            | Operation::Index
            | Operation::Slice
            | Operation::Range
            | Operation::Result(_)
            | Operation::Len
            | Operation::TypeValue
            | Operation::TypeDomain
            | Operation::ResourceDomain
            | Operation::Global(_)
            | Operation::CanModify
            | Operation::Old
            | Operation::Trace(_)
            | Operation::Identical
            | Operation::EmptyVec
            | Operation::SingleVec
            | Operation::UpdateVec
            | Operation::ConcatVec
            | Operation::IndexOfVec
            | Operation::ContainsVec
            | Operation::InRangeRange
            | Operation::InRangeVec
            | Operation::RangeVec
            | Operation::MaxU8
            | Operation::MaxU16
            | Operation::MaxU32
            | Operation::MaxU64
            | Operation::MaxU128
            | Operation::MaxU256
            | Operation::Bv2Int
            | Operation::Int2Bv
            | Operation::AbortFlag
            | Operation::AbortCode
            | Operation::WellFormed
            | Operation::BoxValue
            | Operation::UnboxValue
            | Operation::EmptyEventStore
            | Operation::ExtendEventStore
            | Operation::EventStoreIncludes
            | Operation::EventStoreIncludedIn
            | Operation::NoOp => self.internal_error(
                id,
                format!("unsupported specification construct: `{:?}`", op),
            ),
        }
    }

    fn gen_cast_call(&mut self, targets: Vec<TempIndex>, id: NodeId, args: &[Exp]) {
        let ty = self.env().get_node_type(id);
        let bytecode_op = match ty {
            Type::Primitive(PrimitiveType::U8) => BytecodeOperation::CastU8,
            Type::Primitive(PrimitiveType::U16) => BytecodeOperation::CastU16,
            Type::Primitive(PrimitiveType::U32) => BytecodeOperation::CastU32,
            Type::Primitive(PrimitiveType::U64) => BytecodeOperation::CastU64,
            Type::Primitive(PrimitiveType::U128) => BytecodeOperation::CastU128,
            Type::Primitive(PrimitiveType::U256) => BytecodeOperation::CastU256,
            _ => {
                self.internal_error(id, "inconsistent type");
                return;
            },
        };
        self.gen_op_call(targets, id, bytecode_op, args)
    }

    fn gen_op_call(
        &mut self,
        targets: Vec<TempIndex>,
        id: NodeId,
        op: BytecodeOperation,
        args: &[Exp],
    ) {
        let target = self.require_unary_target(id, targets);
        let arg_temps = self.gen_arg_list(args);
        self.emit_with(id, |attr| {
            Bytecode::Call(attr, vec![target], op, arg_temps, None)
        })
    }

    fn gen_function_call(
        &mut self,
        targets: Vec<TempIndex>,
        id: NodeId,
        fun: QualifiedId<FunId>,
        args: &[Exp],
    ) {
        let type_args = self
            .env()
            .get_node_instantiation_opt(id)
            .unwrap_or_default();
        let args = self.gen_arg_list(args);
        self.emit_with(id, |attr| {
            Bytecode::Call(
                attr,
                targets,
                BytecodeOperation::Function(fun.module_id, fun.id, type_args),
                args,
                None,
            )
        })
    }

    fn gen_arg_list(&mut self, exps: &[Exp]) -> Vec<TempIndex> {
        exps.iter()
            .map(|exp| {
                let ty = self.env().get_node_type(exp.node_id());
                let temp = self.new_temp(ty);
                self.gen(vec![temp], exp);
                temp
            })
            .collect()
    }
}
