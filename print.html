<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Move Book</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Move book maintained by the Move core team.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="modules-and-scripts.html"><strong aria-hidden="true">1.</strong> Modules and Scripts</a></li><li class="chapter-item expanded "><a href="creating-coins.html"><strong aria-hidden="true">2.</strong> Move Tutorial</a></li><li class="chapter-item expanded "><a href="integers.html"><strong aria-hidden="true">3.</strong> Integers</a></li><li class="chapter-item expanded "><a href="bool.html"><strong aria-hidden="true">4.</strong> Bool</a></li><li class="chapter-item expanded "><a href="address.html"><strong aria-hidden="true">5.</strong> Address</a></li><li class="chapter-item expanded "><a href="vector.html"><strong aria-hidden="true">6.</strong> Vector</a></li><li class="chapter-item expanded "><a href="signer.html"><strong aria-hidden="true">7.</strong> Signer</a></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">8.</strong> References</a></li><li class="chapter-item expanded "><a href="tuples.html"><strong aria-hidden="true">9.</strong> Tuples and Unit</a></li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">10.</strong> Local Variables and Scopes</a></li><li class="chapter-item expanded "><a href="equality.html"><strong aria-hidden="true">11.</strong> Equality</a></li><li class="chapter-item expanded "><a href="abort-and-assert.html"><strong aria-hidden="true">12.</strong> Abort and Assert</a></li><li class="chapter-item expanded "><a href="conditionals.html"><strong aria-hidden="true">13.</strong> Conditionals</a></li><li class="chapter-item expanded "><a href="loops.html"><strong aria-hidden="true">14.</strong> While and Loop</a></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">15.</strong> Functions</a></li><li class="chapter-item expanded "><a href="structs-and-resources.html"><strong aria-hidden="true">16.</strong> Structs and Resources</a></li><li class="chapter-item expanded "><a href="constants.html"><strong aria-hidden="true">17.</strong> Constants</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">18.</strong> Generics</a></li><li class="chapter-item expanded "><a href="abilities.html"><strong aria-hidden="true">19.</strong> Type Abilities</a></li><li class="chapter-item expanded "><a href="uses.html"><strong aria-hidden="true">20.</strong> Uses and Aliases</a></li><li class="chapter-item expanded "><a href="friends.html"><strong aria-hidden="true">21.</strong> Friends</a></li><li class="chapter-item expanded "><a href="packages.html"><strong aria-hidden="true">22.</strong> Packages</a></li><li class="chapter-item expanded "><a href="unit-testing.html"><strong aria-hidden="true">23.</strong> Unit Tests</a></li><li class="chapter-item expanded "><a href="global-storage-structure.html"><strong aria-hidden="true">24.</strong> Global Storage Structure</a></li><li class="chapter-item expanded "><a href="global-storage-operators.html"><strong aria-hidden="true">25.</strong> Global Storage Operators</a></li><li class="chapter-item expanded "><a href="standard-library.html"><strong aria-hidden="true">26.</strong> Standard Library</a></li><li class="chapter-item expanded "><a href="coding-conventions.html"><strong aria-hidden="true">27.</strong> Coding Conventions</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The Move Book</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/move-language/move" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to Move, a next generation language for secure, sandboxed, and formally verified programming. Its first use case is for the Diem blockchain, where Move provides the foundation for its implementation. Move allows developers to write programs that flexibly manage and transfer assets, while providing the security and protections against attacks on those assets. However, Move has been developed with use cases in mind outside a blockchain context as well.</p>
<p>Move takes its cue from <a href="https://www.rust-lang.org/">Rust</a> by using resource types with move (hence the name) semantics as an explicit representation of digital assets, such as currency.</p>
<h2 id="who-is-move-for"><a class="header" href="#who-is-move-for">Who is Move for?</a></h2>
<p>Move was designed and created as a secure, verified, yet flexible programming language. The first use of Move is for the implementation of the Diem blockchain. That said, the language is still evolving. Move has the potential to be a language for other blockchains, and even non-blockchain use cases as well.</p>
<p>The early Move Developer is one with some programming experience, who wants to begin understanding the core programming language and see examples of its usage.</p>
<h3 id="hobbyists"><a class="header" href="#hobbyists">Hobbyists</a></h3>
<p>Understanding that the capability to create custom modules on the Diem Payment Network will not be available at launch, the hobbyist Move Developer is interested in learning the intricacies of the language. She will understand the basic syntax, the standard libraries available, and write example code that can be executed using the Move CLI. The Move Developer may even want to dig into understanding how the Move Virtual Machine executes the code she writes.</p>
<h3 id="core-contributor"><a class="header" href="#core-contributor">Core Contributor</a></h3>
<p>Beyond a hobbyist wanting to stay ahead of the curve for the core programming language is someone who may want to <a href="https://diem.com/en-US/cla-sign/">contribute</a> directly to Move. Whether this includes submitting language improvements or even, in the future, adding core modules available on the Diem Payment Network, the core contributor will understand Move at a deep level.</p>
<h3 id="who-move-is-currently-not-targeting"><a class="header" href="#who-move-is-currently-not-targeting">Who Move is currently not targeting</a></h3>
<p>Currently, Move is not targeting developers who wish to create custom modules and contracts for use on the Diem Payment Network. We are also not targeting novice developers who expect a completely polished developer experience even in testing the language.</p>
<h2 id="where-do-i-start"><a class="header" href="#where-do-i-start">Where Do I Start?</a></h2>
<p>Begin with understanding <a href="./modules-and-scripts.html">modules and scripts</a> and then work through the <a href="./creating-coins.html">Move Tutorial</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules-and-scripts"><a class="header" href="#modules-and-scripts">Modules and Scripts</a></h1>
<p>Move has two different types of programs: <em><strong>Modules</strong></em> and <em><strong>Scripts</strong></em>. Modules are libraries that define struct types along with functions that operate on these types. Struct types define the schema of Move's <a href="./global-storage-structure.html">global storage</a>, and module functions define the rules for updating storage. Modules themselves are also stored in global storage. Scripts are executable entrypoints similar to a <code>main</code> function in a conventional language. A script typically calls functions of a published module that perform updates to global storage. Scripts are ephemeral code snippets that are not published in global storage.</p>
<p>A Move source file (or <strong>compilation unit</strong>) may contain multiple modules and scripts. However, publishing a module or executing a script are separate VM operations.</p>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<h3 id="scripts"><a class="header" href="#scripts">Scripts</a></h3>
<p>A script has the following structure:</p>
<pre><code class="language-text">script {
    &lt;use&gt;*
    &lt;constants&gt;*
    fun &lt;identifier&gt;&lt;[type parameters: constraint]*&gt;([identifier: type]*) &lt;function_body&gt;
}
</code></pre>
<p>A <code>script</code> block must start with all of its <a href="./uses.html"><code>use</code></a> declarations, followed by any <a href="./constants.html">constants</a> and (finally) the main
<a href="./functions.html">function</a> declaration.
The main function can have any name (i.e., it need not be called <code>main</code>), is the only function in a script block, can have any number of
arguments, and must not return a value. Here is an example with each of these components:</p>
<pre><code class="language-move">script {
    // Import the debug module published at the named account address std.
    use std::debug;

    const ONE: u64 = 1;

    fun main(x: u64) {
        let sum = x + ONE;
        debug::print(&amp;sum)
    }
}
</code></pre>
<p>Scripts have very limited power—they cannot declare friends, struct types or access global storage. Their primary purpose is to invoke module functions.</p>
<h3 id="modules"><a class="header" href="#modules">Modules</a></h3>
<p>A module has the following syntax:</p>
<pre><code class="language-text">module &lt;address&gt;::&lt;identifier&gt; {
    (&lt;use&gt; | &lt;friend&gt; | &lt;type&gt; | &lt;function&gt; | &lt;constant&gt;)*
}
</code></pre>
<p>where <code>&lt;address&gt;</code> is a valid <a href="./address.html">named or literal address</a>.</p>
<p>For example:</p>
<pre><code class="language-move">module 0x42::test {
    struct Example has copy, drop { i: u64 }

    use std::debug;
    friend 0x42::another_test;

    const ONE: u64 = 1;

    public fun print(x: u64) {
        let sum = x + ONE;
        let example = Example { i: sum };
        debug::print(&amp;sum)
    }
}
</code></pre>
<p>The <code>module 0x42::test</code> part specifies that the module <code>test</code> will be published under the <a href="./address.html">account address</a> <code>0x42</code> in <a href="./global-storage-structure.html">global storage</a>.</p>
<p>Modules can also be declared using <a href="./address.html">named addresses</a>. For example:</p>
<pre><code class="language-move">module test_addr::test {
    struct Example has copy, drop { a: address }

    use std::debug;
    friend test_addr::another_test;

    public fun print() {
        let example = Example { a: @test_addr };
        debug::print(&amp;example)
    }
}
</code></pre>
<p>Because named addresses only exist at the source language level and during compilation,
named addresses will be fully substituted for their value at the bytecode
level. For example if we had the following code:</p>
<pre><code class="language-move">script {
    fun example() {
        my_addr::m::foo(@my_addr);
    }
}
</code></pre>
<p>and we compiled it with <code>my_addr</code> set to <code>0xC0FFEE</code>, then it would be equivalent
to the following operationally:</p>
<pre><code class="language-move">script {
    fun example() {
        0xC0FFEE::m::foo(@0xC0FFEE);
    }
}
</code></pre>
<p>However at the source level, these <em>are not equivalent</em>—the function
<code>m::foo</code> <em>must</em> be accessed through the <code>my_addr</code> named address, and not through
the numerical value assigned to that address.</p>
<p>Module names can start with letters <code>a</code> to <code>z</code> or letters <code>A</code> to <code>Z</code>. After the first character, module names can contain underscores <code>_</code>, letters <code>a</code> to <code>z</code>, letters <code>A</code> to <code>Z</code>, or digits <code>0</code> to <code>9</code>.</p>
<pre><code class="language-move">module my_module {}
module foo_bar_42 {}
</code></pre>
<p>Typically, module names start with an lowercase letter. A module named <code>my_module</code> should be stored in a source file named <code>my_module.move</code>.</p>
<p>All elements inside a <code>module</code> block can appear in any order.
Fundamentally, a module is a collection of <a href="./structs-and-resources.html"><code>types</code></a> and <a href="./functions.html"><code>functions</code></a>.
The <a href="./uses.html"><code>use</code></a> keyword is used to import types from other modules.
The <a href="./friends.html"><code>friend</code></a> keyword specifies a list of trusted modules.
The <a href="./constants.html"><code>const</code></a> keyword defines private constants that can be used in the functions of a module.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="move-tutorial"><a class="header" href="#move-tutorial">Move Tutorial</a></h1>
<p>Please refer to the <a href="https://github.com/move-language/move/tree/main/language/documentation/tutorial">Move Tutorial</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integers"><a class="header" href="#integers">Integers</a></h1>
<p>Move supports six unsigned integer types: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, and <code>u256</code>. Values of these types range from 0 to a maximum that depends on the size of the type.</p>
<table><thead><tr><th>Type</th><th>Value Range</th></tr></thead><tbody>
<tr><td>Unsigned 8-bit integer, <code>u8</code></td><td>0 to 2<sup>8</sup> - 1</td></tr>
<tr><td>Unsigned 16-bit integer, <code>u16</code></td><td>0 to 2<sup>16</sup> - 1</td></tr>
<tr><td>Unsigned 32-bit integer, <code>u32</code></td><td>0 to 2<sup>32</sup> - 1</td></tr>
<tr><td>Unsigned 64-bit integer, <code>u64</code></td><td>0 to 2<sup>64</sup> - 1</td></tr>
<tr><td>Unsigned 128-bit integer, <code>u128</code></td><td>0 to 2<sup>128</sup> - 1</td></tr>
<tr><td>Unsigned 256-bit integer, <code>u256</code></td><td>0 to 2<sup>256</sup> - 1</td></tr>
</tbody></table>
<h2 id="literals"><a class="header" href="#literals">Literals</a></h2>
<p>Literal values for these types are specified either as a sequence of digits (e.g.,<code>112</code>) or as hex literals, e.g., <code>0xFF</code>. The type of the literal can optionally be added as a suffix, e.g., <code>112u8</code>. If the type is not specified, the compiler will try to infer the type from the context where the literal is used. If the type cannot be inferred, it is assumed to be <code>u64</code>.</p>
<p>Number literals can be separated by underscores for grouping and readability. (e.g.,<code>1_234_5678</code>, <code>1_000u128</code>, <code>0xAB_CD_12_35</code>).</p>
<p>If a literal is too large for its specified (or inferred) size range, an error is reported.</p>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<pre><code class="language-move">// literals with explicit annotations;
let explicit_u8 = 1u8;
let explicit_u16 = 1u16;
let explicit_u32 = 1u32;
let explicit_u64 = 2u64;
let explicit_u128 = 3u128;
let explicit_u256 = 1u256;
let explicit_u64_underscored = 154_322_973u64;

// literals with simple inference
let simple_u8: u8 = 1;
let simple_u16: u16 = 1;
let simple_u32: u32 = 1;
let simple_u64: u64 = 2;
let simple_u128: u128 = 3;
let simple_u256: u256 = 1;

// literals with more complex inference
let complex_u8 = 1; // inferred: u8
// right hand argument to shift must be u8
let _unused = 10 &lt;&lt; complex_u8;

let x: u8 = 38;
let complex_u8 = 2; // inferred: u8
// arguments to `+` must have the same type
let _unused = x + complex_u8;

let complex_u128 = 133_876; // inferred: u128
// inferred from function argument type
function_that_takes_u128(complex_u128);

// literals can be written in hex
let hex_u8: u8 = 0x1;
let hex_u16: u16 = 0x1BAE;
let hex_u32: u32 = 0xDEAD80;
let hex_u64: u64 = 0xCAFE;
let hex_u128: u128 = 0xDEADBEEF;
let hex_u256: u256 = 0x1123_456A_BCDE_F;
</code></pre>
<h2 id="operations"><a class="header" href="#operations">Operations</a></h2>
<h3 id="arithmetic"><a class="header" href="#arithmetic">Arithmetic</a></h3>
<p>Each of these types supports the same set of checked arithmetic operations. For all of these operations, both arguments (the left and right side operands) <em>must</em> be of the same type. If you need to operate over values of different types, you will need to first perform a <a href="integers.html#casting">cast</a>. Similarly, if you expect the result of the operation to be too large for the integer type, perform a <a href="integers.html#casting">cast</a> to a larger size before performing the operation.</p>
<p>All arithmetic operations abort instead of behaving in a way that mathematical integers would not (e.g., overflow, underflow, divide-by-zero).</p>
<table><thead><tr><th>Syntax</th><th>Operation</th><th>Aborts If</th></tr></thead><tbody>
<tr><td><code>+</code></td><td>addition</td><td>Result is too large for the integer type</td></tr>
<tr><td><code>-</code></td><td>subtraction</td><td>Result is less than zero</td></tr>
<tr><td><code>*</code></td><td>multiplication</td><td>Result is too large for the integer type</td></tr>
<tr><td><code>%</code></td><td>modular division</td><td>The divisor is <code>0</code></td></tr>
<tr><td><code>/</code></td><td>truncating division</td><td>The divisor is <code>0</code></td></tr>
</tbody></table>
<h3 id="bitwise"><a class="header" href="#bitwise">Bitwise</a></h3>
<p>The integer types support the following bitwise operations that treat each number as a series of individual bits, either 0 or 1, instead of as numerical integer values.</p>
<p>Bitwise operations do not abort.</p>
<table><thead><tr><th>Syntax</th><th>Operation</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&amp;</code></td><td>bitwise and</td><td>Performs a boolean and for each bit pairwise</td></tr>
<tr><td><code>|</code></td><td>bitwise or</td><td>Performs a boolean or for each bit pairwise</td></tr>
<tr><td><code>^</code></td><td>bitwise xor</td><td>Performs a boolean exclusive or for each bit pairwise</td></tr>
</tbody></table>
<h3 id="bit-shifts"><a class="header" href="#bit-shifts">Bit Shifts</a></h3>
<p>Similar to the bitwise operations, each integer type supports bit shifts. But unlike the other operations, the righthand side operand (how many bits to shift by) must <em>always</em> be a <code>u8</code> and need not match the left side operand (the number you are shifting).</p>
<p>Bit shifts can abort if the number of bits to shift by is greater than or equal to <code>8</code>, <code>16</code>, <code>32</code>, <code>64</code>, <code>128</code> or <code>256</code> for <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code> and <code>u256</code> respectively.</p>
<table><thead><tr><th>Syntax</th><th>Operation</th><th>Aborts if</th></tr></thead><tbody>
<tr><td><code>&lt;&lt;</code></td><td>shift left</td><td>Number of bits to shift by is greater than the size of the integer type</td></tr>
<tr><td><code>&gt;&gt;</code></td><td>shift right</td><td>Number of bits to shift by is greater than the size of the integer type</td></tr>
</tbody></table>
<h3 id="comparisons"><a class="header" href="#comparisons">Comparisons</a></h3>
<p>Integer types are the <em>only</em> types in Move that can use the comparison operators. Both arguments need to be of the same type. If you need to compare integers of different types, you will need to <a href="integers.html#casting">cast</a> one of them first.</p>
<p>Comparison operations do not abort.</p>
<table><thead><tr><th>Syntax</th><th>Operation</th></tr></thead><tbody>
<tr><td><code>&lt;</code></td><td>less than</td></tr>
<tr><td><code>&gt;</code></td><td>greater than</td></tr>
<tr><td><code>&lt;=</code></td><td>less than or equal to</td></tr>
<tr><td><code>&gt;=</code></td><td>greater than or equal to</td></tr>
</tbody></table>
<h3 id="equality"><a class="header" href="#equality">Equality</a></h3>
<p>Like all types with <a href="./abilities.html"><code>drop</code></a> in Move, all integer types support the <a href="./equality.html">&quot;equal&quot;</a> and <a href="./equality.html">&quot;not equal&quot;</a>  operations. Both arguments need to be of the same type. If you need to compare integers of different types, you will need to <a href="integers.html#casting">cast</a> one of them first.</p>
<p>Equality operations do not abort.</p>
<table><thead><tr><th>Syntax</th><th>Operation</th></tr></thead><tbody>
<tr><td><code>==</code></td><td>equal</td></tr>
<tr><td><code>!=</code></td><td>not equal</td></tr>
</tbody></table>
<p>For more details see the section on <a href="./equality.html">equality</a></p>
<h2 id="casting"><a class="header" href="#casting">Casting</a></h2>
<p>Integer types of one size can be cast to integer types of another size. Integers are the only types in Move that support casting.</p>
<p>Casts <em>do not</em> truncate. Casting will abort if the result is too large for the specified type</p>
<table><thead><tr><th>Syntax</th><th>Operation</th><th>Aborts if</th></tr></thead><tbody>
<tr><td><code>(e as T)</code></td><td>Cast integer expression <code>e</code> into an integer type <code>T</code></td><td><code>e</code> is too large to represent as a <code>T</code></td></tr>
</tbody></table>
<p>Here, the type of <code>e</code> must be <code>8</code>, <code>16</code>, <code>32</code>, <code>64</code>, <code>128</code> or <code>256</code> and <code>T</code> must be <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code> oe <code>u256</code>.</p>
<p>For example:</p>
<ul>
<li><code>(x as u8)</code></li>
<li><code>(y as u16)</code></li>
<li><code>(873u16 as u32)</code></li>
<li><code>(2u8 as u64)</code></li>
<li><code>(1 + 3 as u128)</code></li>
<li><code>(4/2 + 12345 as u256)</code></li>
</ul>
<h2 id="ownership"><a class="header" href="#ownership">Ownership</a></h2>
<p>As with the other scalar values built-in to the language, integer values are implicitly copyable, meaning they can be copied without an explicit instruction such as <a href="./variables.html#move-and-copy"><code>copy</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bool"><a class="header" href="#bool">Bool</a></h1>
<p><code>bool</code> is Move's primitive type for boolean <code>true</code> and <code>false</code> values.</p>
<h2 id="literals-1"><a class="header" href="#literals-1">Literals</a></h2>
<p>Literals for <code>bool</code> are either <code>true</code> or <code>false</code>.</p>
<h2 id="operations-1"><a class="header" href="#operations-1">Operations</a></h2>
<h3 id="logical"><a class="header" href="#logical">Logical</a></h3>
<p><code>bool</code> supports three logical operations:</p>
<table><thead><tr><th>Syntax</th><th>Description</th><th>Equivalent Expression</th></tr></thead><tbody>
<tr><td><code>&amp;&amp;</code></td><td>short-circuiting logical and</td><td><code>p &amp;&amp; q</code> is equivalent to <code>if (p) q else false</code></td></tr>
<tr><td><code>||</code></td><td>short-circuiting logical or</td><td><code>p || q</code> is equivalent to <code>if (p) true else q</code></td></tr>
<tr><td><code>!</code></td><td>logical negation</td><td><code>!p</code> is equivalent to <code>if (p) false else true</code></td></tr>
</tbody></table>
<h3 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h3>
<p><code>bool</code> values are used in several of Move's control-flow constructs:</p>
<ul>
<li><a href="./conditionals.html"><code>if (bool) { ... }</code></a></li>
<li><a href="./loops.html"><code>while (bool) { .. }</code></a></li>
<li><a href="./abort-and-assert.html"><code>assert!(bool, u64)</code></a></li>
</ul>
<h2 id="ownership-1"><a class="header" href="#ownership-1">Ownership</a></h2>
<p>As with the other scalar values built-in to the language, boolean values are implicitly copyable,
meaning they can be copied without an explicit instruction such as
<a href="./variables.html#move-and-copy"><code>copy</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="address"><a class="header" href="#address">Address</a></h1>
<p><code>address</code> is a built-in type in Move that is used to represent locations (sometimes called accounts) in global storage. An <code>address</code> value is a 128-bit (16 byte) identifier. At a given address, two things can be stored: <a href="./modules-and-scripts.html">Modules</a> and <a href="./structs-and-resources.html">Resources</a>.</p>
<p>Although an <code>address</code> is a 128 bit integer under the hood, Move addresses are intentionally opaque---they cannot be created from integers, they do not support arithmetic operations, and they cannot be modified. Even though there might be interesting programs that would use such a feature (e.g., pointer arithmetic in C fills a similar niche), Move does not allow this dynamic behavior because it has been designed from the ground up to support static verification.</p>
<p>You can use runtime address values (values of type <code>address</code>) to access resources at that address. You <em>cannot</em> access modules at runtime via address values.</p>
<h2 id="addresses-and-their-syntax"><a class="header" href="#addresses-and-their-syntax">Addresses and Their Syntax</a></h2>
<p>Addresses come in two flavors, named or numerical. The syntax for a named address follows the
same rules for any named identifier in Move. The syntax of a numerical address is not restricted
to hex-encoded values, and any valid <a href="./integers.html"><code>u128</code> numerical value</a> can be used as an
address value, e.g., <code>42</code>, <code>0xCAFE</code>, and <code>2021</code> are all valid numerical address
literals.</p>
<p>To distinguish when an address is being used in an expression context or not, the
syntax when using an address differs depending on the context where it's used:</p>
<ul>
<li>When an address is used as an expression the address must be prefixed by the <code>@</code> character, i.e., <a href="./integers.html"><code>@&lt;numerical_value&gt;</code></a> or <code>@&lt;named_address_identifier&gt;</code>.</li>
<li>Outside of expression contexts, the address may be written without the leading <code>@</code> character, i.e., <a href="./integers.html"><code>&lt;numerical_value&gt;</code></a> or <code>&lt;named_address_identifier&gt;</code>.</li>
</ul>
<p>In general, you can think of <code>@</code> as an operator that takes an address from being a namespace item to being an expression item.</p>
<h2 id="named-addresses"><a class="header" href="#named-addresses">Named Addresses</a></h2>
<p>Named addresses are a feature that allow identifiers to be used in place of
numerical values in any spot where addresses are used, and not just at the
value level.  Named addresses are declared and bound as top level elements
(outside of modules and scripts) in Move Packages, or passed as arguments
to the Move compiler.</p>
<p>Named addresses only exist at the source language level and will be fully
substituted for their value at the bytecode level. Because of this, modules
and module members <em>must</em> be accessed through the module's named address
and not through the numerical value assigned to the named address during
compilation, e.g., <code>use my_addr::foo</code> is <em>not</em> equivalent to <code>use 0x2::foo</code>
even if the Move program is compiled with <code>my_addr</code> set to <code>0x2</code>. This
distinction is discussed in more detail in the section on <a href="./modules-and-scripts.html">Modules and
Scripts</a>.</p>
<h3 id="examples-1"><a class="header" href="#examples-1">Examples</a></h3>
<pre><code class="language-move">let a1: address = @0x1; // shorthand for 0x00000000000000000000000000000001
let a2: address = @0x42; // shorthand for 0x00000000000000000000000000000042
let a3: address = @0xDEADBEEF; // shorthand for 0x000000000000000000000000DEADBEEF
let a4: address = @0x0000000000000000000000000000000A;
let a5: address = @std; // Assigns `a5` the value of the named address `std`
let a6: address = @66;
let a7: address = @0x42;

module 66::some_module {   // Not in expression context, so no @ needed
    use 0x1::other_module; // Not in expression context so no @ needed
    use std::vector;       // Can use a named address as a namespace item when using other modules
    ...
}

module std::other_module {  // Can use a named address as a namespace item to declare a module
    ...
}
</code></pre>
<h2 id="global-storage-operations"><a class="header" href="#global-storage-operations">Global Storage Operations</a></h2>
<p>The primary purpose of <code>address</code> values are to interact with the global storage operations.</p>
<p><code>address</code> values are used with the <code>exists</code>, <code>borrow_global</code>, <code>borrow_global_mut</code>, and <code>move_from</code> <a href="./global-storage-operators.html">operations</a>.</p>
<p>The only global storage operation that <em>does not</em> use <code>address</code> is <code>move_to</code>, which uses <a href="./signer.html"><code>signer</code></a>.</p>
<h2 id="ownership-2"><a class="header" href="#ownership-2">Ownership</a></h2>
<p>As with the other scalar values built-in to the language, <code>address</code> values are implicitly copyable, meaning they can be copied without an explicit instruction such as <a href="./variables.html#move-and-copy"><code>copy</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vector"><a class="header" href="#vector">Vector</a></h1>
<p><code>vector&lt;T&gt;</code> is the only primitive collection type provided by Move. A <code>vector&lt;T&gt;</code> is a homogenous
collection of <code>T</code>'s that can grow or shrink by pushing/popping values off the &quot;end&quot;.</p>
<p>A <code>vector&lt;T&gt;</code> can be instantiated with any type <code>T</code>. For example, <code>vector&lt;u64&gt;</code>, <code>vector&lt;address&gt;</code>,
<code>vector&lt;0x42::MyModule::MyResource&gt;</code>, and <code>vector&lt;vector&lt;u8&gt;&gt;</code> are all valid vector types.</p>
<h2 id="literals-2"><a class="header" href="#literals-2">Literals</a></h2>
<h3 id="general-vector-literals"><a class="header" href="#general-vector-literals">General <code>vector</code> Literals</a></h3>
<p>Vectors of any type can be created with <code>vector</code> literals.</p>
<table><thead><tr><th>Syntax</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>vector[]</code></td><td><code>vector[]: vector&lt;T&gt;</code> where <code>T</code> is any single, non-reference type</td><td>An empty vector</td></tr>
<tr><td><code>vector[e1, ..., en]</code></td><td><code>vector[e1, ..., en]: vector&lt;T&gt;</code> where <code>e_i: T</code> s.t. <code>0 &lt; i &lt;= n</code> and <code>n &gt; 0</code></td><td>A vector with <code>n</code> elements (of length <code>n</code>)</td></tr>
</tbody></table>
<p>In these cases, the type of the <code>vector</code> is inferred, either from the element type or from the
vector's usage. If the type cannot be inferred, or simply for added clarity, the type can be
specified explicitly:</p>
<pre><code class="language-move">vector&lt;T&gt;[]: vector&lt;T&gt;
vector&lt;T&gt;[e1, ..., en]: vector&lt;T&gt;
</code></pre>
<h4 id="example-vector-literals"><a class="header" href="#example-vector-literals">Example Vector Literals</a></h4>
<pre><code class="language-move">(vector[]: vector&lt;bool&gt;);
(vector[0u8, 1u8, 2u8]: vector&lt;u8&gt;);
(vector&lt;u128&gt;[]: vector&lt;u128&gt;);
(vector&lt;address&gt;[@0x42, @0x100]: vector&lt;address&gt;);
</code></pre>
<h3 id="vectoru8-literals"><a class="header" href="#vectoru8-literals"><code>vector&lt;u8&gt;</code> literals</a></h3>
<p>A common use-case for vectors in Move is to represent &quot;byte arrays&quot;, which are represented with
<code>vector&lt;u8&gt;</code>. These values are often used for cryptographic purposes, such as a public key or a hash
result. These values are so common that specific syntax is provided to make the values more
readable, as opposed to having to use <code>vector[]</code> where each individual <code>u8</code> value is specified in
numeric form.</p>
<p>There are currently two supported types of <code>vector&lt;u8&gt;</code> literals, <em>byte strings</em> and <em>hex strings</em>.</p>
<h4 id="byte-strings"><a class="header" href="#byte-strings">Byte Strings</a></h4>
<p>Byte strings are quoted string literals prefixed by a <code>b</code>, e.g. <code>b&quot;Hello!\n&quot;</code>.</p>
<p>These are ASCII encoded strings that allow for escape sequences. Currently, the supported escape
sequences are:</p>
<table><thead><tr><th>Escape Sequence</th><th>Description</th></tr></thead><tbody>
<tr><td><code>\n</code></td><td>New line (or Line feed)</td></tr>
<tr><td><code>\r</code></td><td>Carriage return</td></tr>
<tr><td><code>\t</code></td><td>Tab</td></tr>
<tr><td><code>\\</code></td><td>Backslash</td></tr>
<tr><td><code>\0</code></td><td>Null</td></tr>
<tr><td><code>\&quot;</code></td><td>Quote</td></tr>
<tr><td><code>\xHH</code></td><td>Hex escape, inserts the hex byte sequence <code>HH</code></td></tr>
</tbody></table>
<h4 id="hex-strings"><a class="header" href="#hex-strings">Hex Strings</a></h4>
<p>Hex strings are quoted string literals prefixed by a <code>x</code>, e.g. <code>x&quot;48656C6C6F210A&quot;</code>.</p>
<p>Each byte pair, ranging from <code>00</code> to <code>FF</code>, is interpreted as hex encoded <code>u8</code> value. So each byte
pair corresponds to a single entry in the resulting <code>vector&lt;u8&gt;</code>.</p>
<h4 id="example-string-literals"><a class="header" href="#example-string-literals">Example String Literals</a></h4>
<pre><code class="language-move">script {
fun byte_and_hex_strings() {
    assert!(b&quot;&quot; == x&quot;&quot;, 0);
    assert!(b&quot;Hello!\n&quot; == x&quot;48656C6C6F210A&quot;, 1);
    assert!(b&quot;\x48\x65\x6C\x6C\x6F\x21\x0A&quot; == x&quot;48656C6C6F210A&quot;, 2);
    assert!(
        b&quot;\&quot;Hello\tworld!\&quot;\n \r \\Null=\0&quot; ==
            x&quot;2248656C6C6F09776F726C6421220A200D205C4E756C6C3D00&quot;,
        3
    );
}
}
</code></pre>
<h2 id="operations-2"><a class="header" href="#operations-2">Operations</a></h2>
<p><code>vector</code> supports the following operations via the <code>std::vector</code> module in the Move standard
library:</p>
<table><thead><tr><th>Function</th><th>Description</th><th>Aborts?</th></tr></thead><tbody>
<tr><td><code>vector::empty&lt;T&gt;(): vector&lt;T&gt;</code></td><td>Create an empty vector that can store values of type <code>T</code></td><td>Never</td></tr>
<tr><td><code>vector::singleton&lt;T&gt;(t: T): vector&lt;T&gt;</code></td><td>Create a vector of size 1 containing <code>t</code></td><td>Never</td></tr>
<tr><td><code>vector::push_back&lt;T&gt;(v: &amp;mut vector&lt;T&gt;, t: T)</code></td><td>Add <code>t</code> to the end of <code>v</code></td><td>Never</td></tr>
<tr><td><code>vector::pop_back&lt;T&gt;(v: &amp;mut vector&lt;T&gt;): T</code></td><td>Remove and return the last element in <code>v</code></td><td>If <code>v</code> is empty</td></tr>
<tr><td><code>vector::borrow&lt;T&gt;(v: &amp;vector&lt;T&gt;, i: u64): &amp;T</code></td><td>Return an immutable reference to the <code>T</code> at index <code>i</code></td><td>If <code>i</code> is not in bounds</td></tr>
<tr><td><code>vector::borrow_mut&lt;T&gt;(v: &amp;mut vector&lt;T&gt;, i: u64): &amp;mut T</code></td><td>Return a mutable reference to the <code>T</code> at index <code>i</code></td><td>If <code>i</code> is not in bounds</td></tr>
<tr><td><code>vector::destroy_empty&lt;T&gt;(v: vector&lt;T&gt;)</code></td><td>Delete <code>v</code></td><td>If <code>v</code> is not empty</td></tr>
<tr><td><code>vector::append&lt;T&gt;(v1: &amp;mut vector&lt;T&gt;, v2: vector&lt;T&gt;)</code></td><td>Add the elements in <code>v2</code> to the end of <code>v1</code></td><td>Never</td></tr>
<tr><td><code>vector::contains&lt;T&gt;(v: &amp;vector&lt;T&gt;, e: &amp;T): bool</code></td><td>Return true if <code>e</code> is in the vector <code>v</code>. Otherwise, returns false</td><td>Never</td></tr>
<tr><td><code>vector::swap&lt;T&gt;(v: &amp;mut vector&lt;T&gt;, i: u64, j: u64)</code></td><td>Swaps the elements at the <code>i</code>th and <code>j</code>th indices in the vector <code>v</code></td><td>If <code>i</code> or <code>j</code> is out of bounds</td></tr>
<tr><td><code>vector::reverse&lt;T&gt;(v: &amp;mut vector&lt;T&gt;)</code></td><td>Reverses the order of the elements in the vector <code>v</code> in place</td><td>Never</td></tr>
<tr><td><code>vector::index_of&lt;T&gt;(v: &amp;vector&lt;T&gt;, e: &amp;T): (bool, u64)</code></td><td>Return <code>(true, i)</code> if <code>e</code> is in the vector <code>v</code> at index <code>i</code>. Otherwise, returns <code>(false, 0)</code></td><td>Never</td></tr>
<tr><td><code>vector::remove&lt;T&gt;(v: &amp;mut vector&lt;T&gt;, i: u64): T</code></td><td>Remove the <code>i</code>th element of the vector <code>v</code>, shifting all subsequent elements. This is O(n) and preserves ordering of elements in the vector</td><td>If <code>i</code> is out of bounds</td></tr>
<tr><td><code>vector::swap_remove&lt;T&gt;(v: &amp;mut vector&lt;T&gt;, i: u64): T</code></td><td>Swap the <code>i</code>th element of the vector <code>v</code> with the last element and then pop the element, This is O(1), but does not preserve ordering of elements in the vector</td><td>If <code>i</code> is out of bounds</td></tr>
</tbody></table>
<p>More operations may be added over time.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><code class="language-move">use std::vector;

let v = vector::empty&lt;u64&gt;();
vector::push_back(&amp;mut v, 5);
vector::push_back(&amp;mut v, 6);

assert!(*vector::borrow(&amp;v, 0) == 5, 42);
assert!(*vector::borrow(&amp;v, 1) == 6, 42);
assert!(vector::pop_back(&amp;mut v) == 6, 42);
assert!(vector::pop_back(&amp;mut v) == 5, 42);
</code></pre>
<h2 id="destroying-and-copying-vectors"><a class="header" href="#destroying-and-copying-vectors">Destroying and copying <code>vector</code>s</a></h2>
<p>Some behaviors of <code>vector&lt;T&gt;</code> depend on the abilities of the element type, <code>T</code>. For example, vectors
containing elements that do not have <code>drop</code> cannot be implicitly discarded like <code>v</code> in the example
above--they must be explicitly destroyed with <code>vector::destroy_empty</code>.</p>
<p>Note that <code>vector::destroy_empty</code> will abort at runtime unless <code>vec</code> contains zero elements:</p>
<pre><code class="language-move">fun destroy_any_vector&lt;T&gt;(vec: vector&lt;T&gt;) {
    vector::destroy_empty(vec) // deleting this line will cause a compiler error
}
</code></pre>
<p>But no error would occur for dropping a vector that contains elements with <code>drop</code>:</p>
<pre><code class="language-move">fun destroy_droppable_vector&lt;T: drop&gt;(vec: vector&lt;T&gt;) {
    // valid!
    // nothing needs to be done explicitly to destroy the vector
}
</code></pre>
<p>Similarly, vectors cannot be copied unless the element type has <code>copy</code>. In other words, a
<code>vector&lt;T&gt;</code> has <code>copy</code> if and only if <code>T</code> has <code>copy</code>. However, even copyable vectors are never
implicitly copied:</p>
<pre><code class="language-move">let x = vector::singleton&lt;u64&gt;(10);
let y = copy x; // compiler error without the copy!
</code></pre>
<p>Copies of large vectors can be expensive, so the compiler requires explicit <code>copy</code>'s to make it
easier to see where they are happening.</p>
<p>For more details see the sections on <a href="./abilities.html">type abilities</a> and <a href="./generics.html">generics</a>.</p>
<h2 id="ownership-3"><a class="header" href="#ownership-3">Ownership</a></h2>
<p>As mentioned <a href="vector.html#destroying-and-copying-vectors">above</a>, <code>vector</code> values can be copied only if the
elements can be copied. In that case, the copy must be explicit via a
<a href="./variables.html#move-and-copy"><code>copy</code></a> or a <a href="./references.html#reading-and-writing-through-references">dereference <code>*</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signer"><a class="header" href="#signer">Signer</a></h1>
<p><code>signer</code> is a built-in Move resource type. A <code>signer</code> is a
<a href="https://en.wikipedia.org/wiki/Object-capability_model">capability</a> that allows the holder to act on
behalf of a particular <code>address</code>. You can think of the native implementation as being:</p>
<pre><code class="language-move">struct signer has drop { a: address }
</code></pre>
<p>A <code>signer</code> is somewhat similar to a Unix <a href="https://en.wikipedia.org/wiki/User_identifier">UID</a> in
that it represents a user authenticated by code <em>outside</em> of Move (e.g., by checking a cryptographic
signature or password).</p>
<h2 id="comparison-to-address"><a class="header" href="#comparison-to-address">Comparison to <code>address</code></a></h2>
<p>A Move program can create any <code>address</code> value without special permission using address literals:</p>
<pre><code class="language-move">let a1 = @0x1;
let a2 = @0x2;
// ... and so on for every other possible address
</code></pre>
<p>However, <code>signer</code> values are special because they cannot be created via literals or
instructions--only by the Move VM. Before the VM runs a script with parameters of type <code>signer</code>, it
will automatically create <code>signer</code> values and pass them into the script:</p>
<pre><code class="language-move">script {
    use std::signer;
    fun main(s: signer) {
        assert!(signer::address_of(&amp;s) == @0x42, 0);
    }
}
</code></pre>
<p>This script will abort with code <code>0</code> if the script is sent from any address other than <code>0x42</code>.</p>
<p>A transaction script can have an arbitrary number of <code>signer</code>s as long as the <code>signer</code>s are a prefix
to any other arguments. In other words, all of the <code>signer</code> arguments must come first:</p>
<pre><code class="language-move">script {
    use std::signer;
    fun main(s1: signer, s2: signer, x: u64, y: u8) {
        // ...
    }
}
</code></pre>
<p>This is useful for implementing <em>multi-signer scripts</em> that atomically act with the authority of
multiple parties. For example, an extension of the script above could perform an atomic currency
swap between <code>s1</code> and <code>s2</code>.</p>
<h2 id="signer-operators"><a class="header" href="#signer-operators"><code>signer</code> Operators</a></h2>
<p>The <code>std::signer</code> standard library module provides two utility functions over <code>signer</code> values:</p>
<table><thead><tr><th>Function</th><th>Description</th></tr></thead><tbody>
<tr><td><code>signer::address_of(&amp;signer): address</code></td><td>Return the <code>address</code> wrapped by this <code>&amp;signer</code>.</td></tr>
<tr><td><code>signer::borrow_address(&amp;signer): &amp;address</code></td><td>Return a reference to the <code>address</code> wrapped by this <code>&amp;signer</code>.</td></tr>
</tbody></table>
<p>In addition, the <code>move_to&lt;T&gt;(&amp;signer, T)</code> <a href="./global-storage-operators.html">global storage operator</a>
requires a <code>&amp;signer</code> argument to publish a resource <code>T</code> under <code>signer.address</code>'s account. This
ensures that only an authenticated user can elect to publish a resource under their <code>address</code>.</p>
<h2 id="ownership-4"><a class="header" href="#ownership-4">Ownership</a></h2>
<p>Unlike simple scalar values, <code>signer</code> values are not copyable, meaning they cannot be copied (from
any operation whether it be through an explicit <a href="./variables.html#move-and-copy"><code>copy</code></a> instruction
or through a <a href="./references.html#reading-and-writing-through-references">dereference <code>*</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references"><a class="header" href="#references">References</a></h1>
<p>Move has two types of references: immutable <code>&amp;</code> and mutable <code>&amp;mut</code>. Immutable references are read
only, and cannot modify the underlying value (or any of its fields). Mutable references allow for
modifications via a write through that reference. Move's type system enforces an ownership
discipline that prevents reference errors.</p>
<p>For more details on the rules of references, see <a href="./structs-and-resources.html">Structs and Resources</a></p>
<h2 id="reference-operators"><a class="header" href="#reference-operators">Reference Operators</a></h2>
<p>Move provides operators for creating and extending references as well as converting a mutable
reference to an immutable one. Here and elsewhere, we use the notation <code>e: T</code> for &quot;expression <code>e</code>
has type <code>T</code>&quot;.</p>
<table><thead><tr><th>Syntax</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&amp;e</code></td><td><code>&amp;T</code> where <code>e: T</code> and <code>T</code> is a non-reference type</td><td>Create an immutable reference to <code>e</code></td></tr>
<tr><td><code>&amp;mut e</code></td><td><code>&amp;mut T</code> where <code>e: T</code> and <code>T</code> is a non-reference type</td><td>Create a mutable reference to <code>e</code>.</td></tr>
<tr><td><code>&amp;e.f</code></td><td><code>&amp;T</code> where <code>e.f: T</code></td><td>Create an immutable reference to field <code>f</code> of struct <code>e</code>.</td></tr>
<tr><td><code>&amp;mut e.f</code></td><td><code>&amp;mut T</code> where <code>e.f: T</code></td><td>Create a mutable reference to field <code>f</code> of struct<code>e</code>.</td></tr>
<tr><td><code>freeze(e)</code></td><td><code>&amp;T</code> where <code>e: &amp;mut T</code></td><td>Convert the mutable reference <code>e</code> into an immutable reference.</td></tr>
</tbody></table>
<p>The <code>&amp;e.f</code> and <code>&amp;mut e.f</code> operators can be used both to create a new reference into a struct or to
extend an existing reference:</p>
<pre><code class="language-move">let s = S { f: 10 };
let f_ref1: &amp;u64 = &amp;s.f; // works
let s_ref: &amp;S = &amp;s;
let f_ref2: &amp;u64 = &amp;s_ref.f // also works
</code></pre>
<p>A reference expression with multiple fields works as long as both structs are in the same module:</p>
<pre><code class="language-move">struct A { b: B }
struct B { c : u64 }
fun f(a: &amp;A): &amp;u64 {
  &amp;a.b.c
}
</code></pre>
<p>Finally, note that references to references are not allowed:</p>
<pre><code class="language-move">let x = 7;
let y: &amp;u64 = &amp;x;
let z: &amp;&amp;u64 = &amp;y; // will not compile
</code></pre>
<h2 id="reading-and-writing-through-references"><a class="header" href="#reading-and-writing-through-references">Reading and Writing Through References</a></h2>
<p>Both mutable and immutable references can be read to produce a copy of the referenced value.</p>
<p>Only mutable references can be written. A write <code>*x = v</code> discards the value previously stored in <code>x</code>
and updates it with <code>v</code>.</p>
<p>Both operations use the C-like <code>*</code> syntax. However, note that a read is an expression, whereas a
write is a mutation that must occur on the left hand side of an equals.</p>
<table><thead><tr><th>Syntax</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>*e</code></td><td><code>T</code> where <code>e</code> is <code>&amp;T</code> or <code>&amp;mut T</code></td><td>Read the value pointed to by <code>e</code></td></tr>
<tr><td><code>*e1 = e2</code></td><td><code>()</code> where <code>e1: &amp;mut T</code> and <code>e2: T</code></td><td>Update the value in <code>e1</code> with <code>e2</code>.</td></tr>
</tbody></table>
<p>In order for a reference to be read, the underlying type must have the
<a href="./abilities.html"><code>copy</code> ability</a> as reading the reference creates a new copy of the value. This rule
prevents the copying of resource values:</p>
<pre><code class="language-move=">fun copy_resource_via_ref_bad(c: Coin) {
    let c_ref = &amp;c;
    let counterfeit: Coin = *c_ref; // not allowed!
    pay(c);
    pay(counterfeit);
}
</code></pre>
<p>Dually: in order for a reference to be written to, the underlying type must have the
<a href="./abilities.html"><code>drop</code> ability</a> as writing to the reference will discard (or &quot;drop&quot;) the old value.
This rule prevents the destruction of resource values:</p>
<pre><code class="language-move=">fun destroy_resource_via_ref_bad(ten_coins: Coin, c: Coin) {
    let ref = &amp;mut ten_coins;
    *ref = c; // not allowed--would destroy 10 coins!
}
</code></pre>
<h2 id="freeze-inference"><a class="header" href="#freeze-inference"><code>freeze</code> inference</a></h2>
<p>A mutable reference can be used in a context where an immutable reference is expected:</p>
<pre><code class="language-move">let x = 7;
let y: &amp;u64 = &amp;mut x;
</code></pre>
<p>This works because the under the hood, the compiler inserts <code>freeze</code> instructions where they are
needed. Here are a few more examples of <code>freeze</code> inference in action:</p>
<pre><code class="language-move=">fun takes_immut_returns_immut(x: &amp;u64): &amp;u64 { x }

// freeze inference on return value
fun takes_mut_returns_immut(x: &amp;mut u64): &amp;u64 { x }

fun expression_examples() {
    let x = 0;
    let y = 0;
    takes_immut_returns_immut(&amp;x); // no inference
    takes_immut_returns_immut(&amp;mut x); // inferred freeze(&amp;mut x)
    takes_mut_returns_immut(&amp;mut x); // no inference

    assert!(&amp;x == &amp;mut y, 42); // inferred freeze(&amp;mut y)
}

fun assignment_examples() {
    let x = 0;
    let y = 0;
    let imm_ref: &amp;u64 = &amp;x;

    imm_ref = &amp;x; // no inference
    imm_ref = &amp;mut y; // inferred freeze(&amp;mut y)
}
</code></pre>
<h3 id="subtyping"><a class="header" href="#subtyping">Subtyping</a></h3>
<p>With this <code>freeze</code> inference, the Move type checker can view <code>&amp;mut T</code> as a subtype of <code>&amp;T</code>. As shown
above, this means that anywhere for any expression where a <code>&amp;T</code> value is used, a <code>&amp;mut T</code> value can
also be used. This terminology is used in error messages to concisely indicate that a <code>&amp;mut T</code> was
needed where a <code>&amp;T</code> was supplied. For example</p>
<pre><code class="language-move=">address 0x42 {
module example {
    fun read_and_assign(store: &amp;mut u64, new_value: &amp;u64) {
        *store = *new_value
    }

    fun subtype_examples() {
        let x: &amp;u64 = &amp;0;
        let y: &amp;mut u64 = &amp;mut 1;

        x = &amp;mut 1; // valid
        y = &amp;2; // invalid!

        read_and_assign(y, x); // valid
        read_and_assign(x, y); // invalid!
    }
}
}
</code></pre>
<p>will yield the following error messages</p>
<pre><code class="language-text">error:

    ┌── example.move:12:9 ───
    │
 12 │         y = &amp;2; // invalid!
    │         ^ Invalid assignment to local 'y'
    ·
 12 │         y = &amp;2; // invalid!
    │             -- The type: '&amp;{integer}'
    ·
  9 │         let y: &amp;mut u64 = &amp;mut 1;
    │                -------- Is not a subtype of: '&amp;mut u64'
    │

error:

    ┌── example.move:15:9 ───
    │
 15 │         read_and_assign(x, y); // invalid!
    │         ^^^^^^^^^^^^^^^^^^^^^ Invalid call of '0x42::example::read_and_assign'. Invalid argument for parameter 'store'
    ·
  8 │         let x: &amp;u64 = &amp;0;
    │                ---- The type: '&amp;u64'
    ·
  3 │     fun read_and_assign(store: &amp;mut u64, new_value: &amp;u64) {
    │                                -------- Is not a subtype of: '&amp;mut u64'
    │
</code></pre>
<p>The only other types currently that has subtyping are <a href="./tuples.html">tuples</a></p>
<h2 id="ownership-5"><a class="header" href="#ownership-5">Ownership</a></h2>
<p>Both mutable and immutable references can always be copied and extended <em>even if there are existing
copies or extensions of the same reference</em>:</p>
<pre><code class="language-move">fun reference_copies(s: &amp;mut S) {
  let s_copy1 = s; // ok
  let s_extension = &amp;mut s.f; // also ok
  let s_copy2 = s; // still ok
  ...
}
</code></pre>
<p>This might be surprising for programmers familiar with Rust's ownership system, which would reject
the code above. Move's type system is more permissive in its treatment of
<a href="./variables.html#move-and-copy">copies</a>, but equally strict in ensuring unique ownership of mutable
references before writes.</p>
<h3 id="references-cannot-be-stored"><a class="header" href="#references-cannot-be-stored">References Cannot Be Stored</a></h3>
<p>References and tuples are the <em>only</em> types that cannot be stored as a field value of structs, which
also means that they cannot exist in global storage. All references created during program execution
will be destroyed when a Move program terminates; they are entirely ephemeral. This invariant is
also true for values of types without the <code>store</code> <a href="./abilities.html">ability</a>, but note that
references and tuples go a step further by never being allowed in structs in the first place.</p>
<p>This is another difference between Move and Rust, which allows references to be stored inside of
structs.</p>
<p>Currently, Move cannot support this because references cannot be
<a href="https://en.wikipedia.org/wiki/Serialization">serialized</a>, but <em>every Move value must be
serializable</em>. This requirement comes from Move's
<a href="./global-storage-structure.html">persistent global storage</a>, which needs to serialize values to
persist them across program executions. Structs can be written to global storage, and thus they must
be serializable.</p>
<p>One could imagine a fancier, more expressive, type system that would allow references to be stored
in structs <em>and</em> ban those structs from existing in global storage. We could perhaps allow
references inside of structs that do not have the <code>store</code> <a href="./abilities.html">ability</a>, but that would
not completely solve the problem: Move has a fairly complex system for tracking static reference
safety, and this aspect of the type system would also have to be extended to support storing
references inside of structs. In short, Move's type system (particularly the aspects around
reference safety) would have to expand to support stored references. But it is something we are
keeping an eye on as the language evolves.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuples-and-unit"><a class="header" href="#tuples-and-unit">Tuples and Unit</a></h1>
<p>Move does not fully support tuples as one might expect coming from another language with them as a
<a href="https://en.wikipedia.org/wiki/First-class_citizen">first-class value</a>. However, in order to support multiple return values, Move has tuple-like
expressions. These expressions do not result in a concrete value at runtime (there are no tuples in
the bytecode), and as a result they are very limited: they can only appear in expressions (usually
in the return position for a function); they cannot be bound to local variables; they cannot be
stored in structs; and tuple types cannot be used to instantiate generics.</p>
<p>Similarly, <a href="https://en.wikipedia.org/wiki/Unit_type">unit <code>()</code></a> is a type created by the Move source language in order to be expression based.
The unit value <code>()</code> does not result in any runtime value. We can consider unit<code>()</code> to be an empty
tuple, and any restrictions that apply to tuples also apply to unit.</p>
<p>It might feel weird to have tuples in the language at all given these restrictions. But one of the
most common use cases for tuples in other languages is for functions to allow functions to return
multiple values. Some languages work around this by forcing the users to write structs that contain
the multiple return values. However in Move, you cannot put references inside of
<a href="./structs-and-resources.html">structs</a>. This required Move to support multiple return values. These
multiple return values are all pushed on the stack at the bytecode level. At the source level, these
multiple return values are represented using tuples.</p>
<h2 id="literals-3"><a class="header" href="#literals-3">Literals</a></h2>
<p>Tuples are created by a comma separated list of expressions inside of parentheses.</p>
<table><thead><tr><th>Syntax</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>()</code></td><td><code>(): ()</code></td><td>Unit, the empty tuple, or the tuple of arity 0</td></tr>
<tr><td><code>(e1, ..., en)</code></td><td><code>(e1, ..., en): (T1, ..., Tn)</code> where <code>e_i: Ti</code> s.t. <code>0 &lt; i &lt;= n</code> and <code>n &gt; 0</code></td><td>A <code>n</code>-tuple, a tuple of arity <code>n</code>, a tuple with <code>n</code> elements</td></tr>
</tbody></table>
<p>Note that <code>(e)</code> does not have type <code>(e): (t)</code>, in other words there is no tuple with one element. If
there is only a single element inside of the parentheses, the parentheses are only used for
disambiguation and do not carry any other special meaning.</p>
<p>Sometimes, tuples with two elements are called &quot;pairs&quot; and tuples with three elements are called
&quot;triples.&quot;</p>
<h3 id="examples-2"><a class="header" href="#examples-2">Examples</a></h3>
<pre><code class="language-move">address 0x42 {
module example {
    // all 3 of these functions are equivalent

    // when no return type is provided, it is assumed to be `()`
    fun returns_unit_1() { }

    // there is an implicit () value in empty expression blocks
    fun returns_unit_2(): () { }

    // explicit version of `returns_unit_1` and `returns_unit_2`
    fun returns_unit_3(): () { () }


    fun returns_3_values(): (u64, bool, address) {
        (0, false, @0x42)
    }
    fun returns_4_values(x: &amp;u64): (&amp;u64, u8, u128, vector&lt;u8&gt;) {
        (x, 0, 1, b&quot;foobar&quot;)
    }
}
}
</code></pre>
<h2 id="operations-3"><a class="header" href="#operations-3">Operations</a></h2>
<p>The only operation that can be done on tuples currently is destructuring.</p>
<h3 id="destructuring"><a class="header" href="#destructuring">Destructuring</a></h3>
<p>For tuples of any size, they can be destructured in either a <code>let</code> binding or in an assignment.</p>
<p>For example:</p>
<pre><code class="language-move">address 0x42 {
module example {
    // all 3 of these functions are equivalent
    fun returns_unit() {}
    fun returns_2_values(): (bool, bool) { (true, false) }
    fun returns_4_values(x: &amp;u64): (&amp;u64, u8, u128, vector&lt;u8&gt;) { (x, 0, 1, b&quot;foobar&quot;) }

    fun examples(cond: bool) {
        let () = ();
        let (x, y): (u8, u64) = (0, 1);
        let (a, b, c, d) = (@0x0, 0, false, b&quot;&quot;);

        () = ();
        (x, y) = if (cond) (1, 2) else (3, 4);
        (a, b, c, d) = (@0x1, 1, true, b&quot;1&quot;);
    }

    fun examples_with_function_calls() {
        let () = returns_unit();
        let (x, y): (bool, bool) = returns_2_values();
        let (a, b, c, d) = returns_4_values(&amp;0);

        () = returns_unit();
        (x, y) = returns_2_values();
        (a, b, c, d) = returns_4_values(&amp;1);
    }
}
}
</code></pre>
<p>For more details, see <a href="./variables.html">Move Variables</a>.</p>
<h2 id="subtyping-1"><a class="header" href="#subtyping-1">Subtyping</a></h2>
<p>Along with references, tuples are the only types that have <a href="https://en.wikipedia.org/wiki/Subtyping">subtyping</a> in Move. Tuples do have
subtyping only in the sense that subtype with references (in a covariant way).</p>
<p>For example:</p>
<pre><code class="language-move">let x: &amp;u64 = &amp;0;
let y: &amp;mut u64 = &amp;mut 1;

// (&amp;u64, &amp;mut u64) is a subtype of (&amp;u64, &amp;u64)
// since &amp;mut u64 is a subtype of &amp;u64
let (a, b): (&amp;u64, &amp;u64) = (x, y);

// (&amp;mut u64, &amp;mut u64) is a subtype of (&amp;u64, &amp;u64)
// since &amp;mut u64 is a subtype of &amp;u64
let (c, d): (&amp;u64, &amp;u64) = (y, y);

// error! (&amp;u64, &amp;mut u64) is NOT a subtype of (&amp;mut u64, &amp;mut u64)
// since &amp;u64 is NOT a subtype of &amp;mut u64
let (e, f): (&amp;mut u64, &amp;mut u64) = (x, y);
</code></pre>
<h2 id="ownership-6"><a class="header" href="#ownership-6">Ownership</a></h2>
<p>As mentioned above, tuple values don't really exist at runtime. And currently they cannot be stored
into local variables because of this (but it is likely that this feature will come soon). As such,
tuples can only be moved currently, as copying them would require putting them into a local variable
first.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="local-variables-and-scope"><a class="header" href="#local-variables-and-scope">Local Variables and Scope</a></h1>
<p>Local variables in Move are lexically (statically) scoped. New variables are introduced with the
keyword <code>let</code>, which will shadow any previous local with the same name. Locals are mutable and can
be updated both directly and via a mutable reference.</p>
<h2 id="declaring-local-variables"><a class="header" href="#declaring-local-variables">Declaring Local Variables</a></h2>
<h3 id="let-bindings"><a class="header" href="#let-bindings"><code>let</code> bindings</a></h3>
<p>Move programs use <code>let</code> to bind variable names to values:</p>
<pre><code class="language-move">let x = 1;
let y = x + x:
</code></pre>
<p><code>let</code> can also be used without binding a value to the local.</p>
<pre><code class="language-move">let x;
</code></pre>
<p>The local can then be assigned a value later.</p>
<pre><code class="language-move">let x;
if (cond) {
  x = 1
} else {
  x = 0
}
</code></pre>
<p>This can be very helpful when trying to extract a value from a loop when a default value cannot be
provided.</p>
<pre><code class="language-move">let x;
let cond = true;
let i = 0;
loop {
    (x, cond) = foo(i);
    if (!cond) break;
    i = i + 1;
}
</code></pre>
<h3 id="variables-must-be-assigned-before-use"><a class="header" href="#variables-must-be-assigned-before-use">Variables must be assigned before use</a></h3>
<p>Move's type system prevents a local variable from being used before it has been assigned.</p>
<pre><code class="language-move">let x;
x + x // ERROR!
</code></pre>
<pre><code class="language-move">let x;
if (cond) x = 0;
x + x // ERROR!
</code></pre>
<pre><code class="language-move">let x;
while (cond) x = 0;
x + x // ERROR!
</code></pre>
<h3 id="valid-variable-names"><a class="header" href="#valid-variable-names">Valid variable names</a></h3>
<p>Variable names can contain underscores <code>_</code>, letters <code>a</code> to <code>z</code>, letters <code>A</code> to <code>Z</code>, and digits <code>0</code>
to <code>9</code>. Variable names must start with either an underscore <code>_</code> or a letter <code>a</code> through <code>z</code>. They
<em>cannot</em> start with uppercase letters.</p>
<pre><code class="language-move">// all valid
let x = e;
let _x = e;
let _A = e;
let x0 = e;
let xA = e;
let foobar_123 = e;

// all invalid
let X = e; // ERROR!
let Foo = e; // ERROR!
</code></pre>
<h3 id="type-annotations"><a class="header" href="#type-annotations">Type annotations</a></h3>
<p>The type of a local variable can almost always be inferred by Move's type system. However, Move
allows explicit type annotations that can be useful for readability, clarity, or debuggability. The
syntax for adding a type annotation is:</p>
<pre><code class="language-move">let x: T = e; // &quot;Variable x of type T is initialized to expression e&quot;
</code></pre>
<p>Some examples of explicit type annotations:</p>
<pre><code class="language-move">address 0x42 {
module example {

    struct S { f: u64, g: u64 }

    fun annotated() {
        let u: u8 = 0;
        let b: vector&lt;u8&gt; = b&quot;hello&quot;;
        let a: address = @0x0;
        let (x, y): (&amp;u64, &amp;mut u64) = (&amp;0, &amp;mut 1);
        let S { f, g: f2 }: S = S { f: 0, g: 1 };
    }
}
}
</code></pre>
<p>Note that the type annotations must always be to the right of the pattern:</p>
<pre><code class="language-move">let (x: &amp;u64, y: &amp;mut u64) = (&amp;0, &amp;mut 1); // ERROR! should be let (x, y): ... =
</code></pre>
<h3 id="when-annotations-are-necessary"><a class="header" href="#when-annotations-are-necessary">When annotations are necessary</a></h3>
<p>In some cases, a local type annotation is required if the type system cannot infer the type. This
commonly occurs when the type argument for a generic type cannot be inferred. For example:</p>
<pre><code class="language-move">let _v1 = vector::empty(); // ERROR!
//        ^^^^^^^^^^^^^^^ Could not infer this type. Try adding an annotation
let v2: vector&lt;u64&gt; = vector::empty(); // no error
</code></pre>
<p>In a rarer case, the type system might not be able to infer a type for divergent code (where all the
following code is unreachable). Both <code>return</code> and <a href="./abort-and-assert.html"><code>abort</code></a> are expressions
and can have any type. A <a href="./loops.html"><code>loop</code></a> has type <code>()</code> if it has a <code>break</code>, but if there is no
break out of the <code>loop</code>, it could have any type. If these types cannot be inferred, a type
annotation is required. For example, this code:</p>
<pre><code class="language-move">let a: u8 = return ();
let b: bool = abort 0;
let c: signer = loop ();

let x = return (); // ERROR!
//  ^ Could not infer this type. Try adding an annotation
let y = abort 0; // ERROR!
//  ^ Could not infer this type. Try adding an annotation
let z = loop (); // ERROR!
//  ^ Could not infer this type. Try adding an annotation
</code></pre>
<p>Adding type annotations to this code will expose other errors about dead code or unused local
variables, but the example is still helpful for understanding this problem.</p>
<h3 id="multiple-declarations-with-tuples"><a class="header" href="#multiple-declarations-with-tuples">Multiple declarations with tuples</a></h3>
<p><code>let</code> can introduce more than one local at a time using tuples. The locals declared inside the
parenthesis are initialized to the corresponding values from the tuple.</p>
<pre><code class="language-move">let () = ();
let (x0, x1) = (0, 1);
let (y0, y1, y2) = (0, 1, 2);
let (z0, z1, z2, z3) = (0, 1, 2, 3);
</code></pre>
<p>The type of the expression must match the arity of the tuple pattern exactly.</p>
<pre><code class="language-move">let (x, y) = (0, 1, 2); // ERROR!
let (x, y, z, q) = (0, 1, 2); // ERROR!
</code></pre>
<p>You cannot declare more than one local with the same name in a single <code>let</code>.</p>
<pre><code class="language-move">let (x, x) = 0; // ERROR!
</code></pre>
<h3 id="multiple-declarations-with-structs"><a class="header" href="#multiple-declarations-with-structs">Multiple declarations with structs</a></h3>
<p><code>let</code> can also introduce more than one local at a time when destructuring (or matching against) a
struct. In this form, the <code>let</code> creates a set of local variables that are initialized to the values
of the fields from a struct. The syntax looks like this:</p>
<pre><code class="language-move">struct T { f1: u64, f2: u64 }
</code></pre>
<pre><code class="language-move">let T { f1: local1, f2: local2 } = T { f1: 1, f2: 2 };
// local1: u64
// local2: u64
</code></pre>
<p>Here is a more complicated example:</p>
<pre><code class="language-move">address 0x42 {
module example {
    struct X { f: u64 }
    struct Y { x1: X, x2: X }

    fun new_x(): X {
        X { f: 1 }
    }

    fun example() {
        let Y { x1: X { f }, x2 } = Y { x1: new_x(), x2: new_x() };
        assert!(f + x2.f == 2, 42);

        let Y { x1: X { f: f1 }, x2: X { f: f2 } } = Y { x1: new_x(), x2: new_x() };
        assert!(f1 + f2 == 2, 42);
    }
}
}
</code></pre>
<p>Fields of structs can serve double duty, identifying the field to bind <em>and</em> the name of the
variable. This is sometimes referred to as punning.</p>
<pre><code class="language-move">let X { f } = e;
</code></pre>
<p>is equivalent to:</p>
<pre><code class="language-move">let X { f: f } = e;
</code></pre>
<p>As shown with tuples, you cannot declare more than one local with the same name in a single <code>let</code>.</p>
<pre><code class="language-move">let Y { x1: x, x2: x } = e; // ERROR!
</code></pre>
<h3 id="destructuring-against-references"><a class="header" href="#destructuring-against-references">Destructuring against references</a></h3>
<p>In the examples above for structs, the bound value in the let was moved, destroying the struct value
and binding its fields.</p>
<pre><code class="language-move">struct T { f1: u64, f2: u64 }
</code></pre>
<pre><code class="language-move">let T { f1: local1, f2: local2 } = T { f1: 1, f2: 2 };
// local1: u64
// local2: u64
</code></pre>
<p>In this scenario the struct value <code>T { f1: 1, f2: 2 }</code> no longer exists after the <code>let</code>.</p>
<p>If you wish instead to not move and destroy the struct value, you can borrow each of its fields. For
example:</p>
<pre><code class="language-move">let t = T { f1: 1, f2: 2 };
let T { f1: local1, f2: local2 } = &amp;t;
// local1: &amp;u64
// local2: &amp;u64
</code></pre>
<p>And similarly with mutable references:</p>
<pre><code class="language-move">let t = T { f1: 1, f2: 2 };
let T { f1: local1, f2: local2 } = &amp;mut t;
// local1: &amp;mut u64
// local2: &amp;mut u64
</code></pre>
<p>This behavior can also work with nested structs.</p>
<pre><code class="language-move">address 0x42 {
module example {
    struct X { f: u64 }
    struct Y { x1: X, x2: X }

    fun new_x(): X {
        X { f: 1 }
    }

    fun example() {
        let y = Y { x1: new_x(), x2: new_x() };

        let Y { x1: X { f }, x2 } = &amp;y;
        assert!(*f + x2.f == 2, 42);

        let Y { x1: X { f: f1 }, x2: X { f: f2 } } = &amp;mut y;
        *f1 = *f1 + 1;
        *f2 = *f2 + 1;
        assert!(*f1 + *f2 == 4, 42);
    }
}
}
</code></pre>
<h3 id="ignoring-values"><a class="header" href="#ignoring-values">Ignoring Values</a></h3>
<p>In <code>let</code> bindings, it is often helpful to ignore some values. Local variables that start with <code>_</code>
will be ignored and not introduce a new variable</p>
<pre><code class="language-move">fun three(): (u64, u64, u64) {
    (0, 1, 2)
}
</code></pre>
<pre><code class="language-move">let (x1, _, z1) = three();
let (x2, _y, z2) = three();
assert!(x1 + z1 == x2 + z2, 42);
</code></pre>
<p>This can be necessary at times as the compiler will error on unused local variables</p>
<pre><code class="language-move">let (x1, y, z1) = three(); // ERROR!
//       ^ unused local 'y'
</code></pre>
<h3 id="general-let-grammar"><a class="header" href="#general-let-grammar">General <code>let</code> grammar</a></h3>
<p>All of the different structures in <code>let</code> can be combined! With that we arrive at this general
grammar for <code>let</code> statements:</p>
<blockquote>
<p><em>let-binding</em> → <strong>let</strong> <em>pattern-or-list</em> <em>type-annotation</em><sub><em>opt</em></sub>
<em>initializer</em><sub><em>opt</em></sub> &gt; <em>pattern-or-list</em> → <em>pattern</em> | <strong>(</strong> <em>pattern-list</em> <strong>)</strong> &gt;
<em>pattern-list</em> → <em>pattern</em> <strong>,</strong><sub><em>opt</em></sub> | <em>pattern</em> <strong>,</strong> <em>pattern-list</em> &gt;
<em>type-annotation</em> → <strong>:</strong> <em>type</em> <em>initializer</em> → <strong>=</strong> <em>expression</em></p>
</blockquote>
<p>The general term for the item that introduces the bindings is a <em>pattern</em>. The pattern serves to
both destructure data (possibly recursively) and introduce the bindings. The pattern grammar is as
follows:</p>
<blockquote>
<p><em>pattern</em> → <em>local-variable</em> | <em>struct-type</em> <strong>{</strong> <em>field-binding-list</em> <strong>}</strong> &gt;
<em>field-binding-list</em> → <em>field-binding</em> <strong>,</strong><sub><em>opt</em></sub> | <em>field-binding</em> <strong>,</strong>
<em>field-binding-list</em> &gt; <em>field-binding</em> → <em>field</em> | <em>field</em> <strong>:</strong> <em>pattern</em></p>
</blockquote>
<p>A few concrete examples with this grammar applied:</p>
<pre><code class="language-move">    let (x, y): (u64, u64) = (0, 1);
//       ^                           local-variable
//       ^                           pattern
//          ^                        local-variable
//          ^                        pattern
//          ^                        pattern-list
//       ^^^^                        pattern-list
//      ^^^^^^                       pattern-or-list
//            ^^^^^^^^^^^^           type-annotation
//                         ^^^^^^^^  initializer
//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ let-binding

    let Foo { f, g: x } = Foo { f: 0, g: 1 };
//      ^^^                                    struct-type
//            ^                                field
//            ^                                field-binding
//               ^                             field
//                  ^                          local-variable
//                  ^                          pattern
//               ^^^^                          field-binding
//            ^^^^^^^                          field-binding-list
//      ^^^^^^^^^^^^^^^                        pattern
//      ^^^^^^^^^^^^^^^                        pattern-or-list
//                      ^^^^^^^^^^^^^^^^^^^^   initializer
//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ let-binding
</code></pre>
<h2 id="mutations"><a class="header" href="#mutations">Mutations</a></h2>
<h3 id="assignments"><a class="header" href="#assignments">Assignments</a></h3>
<p>After the local is introduced (either by <code>let</code> or as a function parameter), the local can be
modified via an assignment:</p>
<pre><code class="language-move">x = e
</code></pre>
<p>Unlike <code>let</code> bindings, assignments are expressions. In some languages, assignments return the value
that was assigned, but in Move, the type of any assignment is always <code>()</code>.</p>
<pre><code class="language-move">(x = e: ())
</code></pre>
<p>Practically, assignments being expressions means that they can be used without adding a new
expression block with braces (<code>{</code>...<code>}</code>).</p>
<pre><code class="language-move">let x = 0;
if (cond) x = 1 else x = 2;
</code></pre>
<p>The assignment uses the same pattern syntax scheme as <code>let</code> bindings:</p>
<pre><code class="language-move">address 0x42 {
module example {
    struct X { f: u64 }

    fun new_x(): X {
        X { f: 1 }
    }

    // This example will complain about unused variables and assignments.
    fun example() {
       let (x, _, z) = (0, 1, 3);
       let (x, y, f, g);

       (X { f }, X { f: x }) = (new_x(), new_x());
       assert!(f + x == 2, 42);

       (x, y, z, f, _, g) = (0, 0, 0, 0, 0, 0);
    }
}
}
</code></pre>
<p>Note that a local variable can only have one type, so the type of the local cannot change between
assignments.</p>
<pre><code class="language-move">let x;
x = 0;
x = false; // ERROR!
</code></pre>
<h3 id="mutating-through-a-reference"><a class="header" href="#mutating-through-a-reference">Mutating through a reference</a></h3>
<p>In addition to directly modifying a local with assignment, a local can be modified via a mutable
reference <code>&amp;mut</code>.</p>
<pre><code class="language-move">let x = 0;
let r = &amp;mut x;
*r = 1;
assert!(x == 1, 42);
</code></pre>
<p>This is particularly useful if either:</p>
<p>(1) You want to modify different variables depending on some condition.</p>
<pre><code class="language-move">let x = 0;
let y = 1;
let r = if (cond) &amp;mut x else &amp;mut y;
*r = *r + 1;
</code></pre>
<p>(2) You want another function to modify your local value.</p>
<pre><code class="language-move">let x = 0;
modify_ref(&amp;mut x);
</code></pre>
<p>This sort of modification is how you modify structs and vectors!</p>
<pre><code class="language-move">let v = vector::empty();
vector::push_back(&amp;mut v, 100);
assert!(*vector::borrow(&amp;v, 0) == 100, 42);
</code></pre>
<p>For more details, see <a href="./references.html">Move references</a>.</p>
<h2 id="scopes"><a class="header" href="#scopes">Scopes</a></h2>
<p>Any local declared with <code>let</code> is available for any subsequent expression, <em>within that scope</em>.
Scopes are declared with expression blocks, <code>{</code>...<code>}</code>.</p>
<p>Locals cannot be used outside of the declared scope.</p>
<pre><code class="language-move">let x = 0;
{
    let y = 1;
};
x + y // ERROR!
//  ^ unbound local 'y'
</code></pre>
<p>But, locals from an outer scope <em>can</em> be used in a nested scope.</p>
<pre><code class="language-move">{
    let x = 0;
    {
        let y = x + 1; // valid
    }
}
</code></pre>
<p>Locals can be mutated in any scope where they are accessible. That mutation survives with the local,
regardless of the scope that performed the mutation.</p>
<pre><code class="language-move">let x = 0;
x = x + 1;
assert!(x == 1, 42);
{
    x = x + 1;
    assert!(x == 2, 42);
};
assert!(x == 2, 42);
</code></pre>
<h3 id="expression-blocks"><a class="header" href="#expression-blocks">Expression Blocks</a></h3>
<p>An expression block is a series of statements separated by semicolons (<code>;</code>). The resulting value of
an expression block is the value of the last expression in the block.</p>
<pre><code class="language-move">{ let x = 1; let y = 1; x + y }
</code></pre>
<p>In this example, the result of the block is <code>x + y</code>.</p>
<p>A statement can be either a <code>let</code> declaration or an expression. Remember that assignments (<code>x = e</code>)
are expressions of type <code>()</code>.</p>
<pre><code class="language-move">{ let x; let y = 1; x = 1; x + y }
</code></pre>
<p>Function calls are another common expression of type <code>()</code>. Function calls that modify data are
commonly used as statements.</p>
<pre><code class="language-move">{ let v = vector::empty(); vector::push_back(&amp;mut v, 1); v }
</code></pre>
<p>This is not just limited to <code>()</code> types---any expression can be used as a statement in a sequence!</p>
<pre><code class="language-move">{
    let x = 0;
    x + 1; // value is discarded
    x + 2; // value is discarded
    b&quot;hello&quot;; // value is discarded
}
</code></pre>
<p>But! If the expression contains a resource (a value without the <code>drop</code> <a href="./abilities.html">ability</a>),
you will get an error. This is because Move's type system guarantees that any value that is dropped
has the <code>drop</code> <a href="./abilities.html">ability</a>. (Ownership must be transferred or the value must be
explicitly destroyed within its declaring module.)</p>
<pre><code class="language-move">{
    let x = 0;
    Coin { value: x }; // ERROR!
//  ^^^^^^^^^^^^^^^^^ unused value without the `drop` ability
    x
}
</code></pre>
<p>If a final expression is not present in a block---that is, if there is a trailing semicolon <code>;</code>,
there is an implicit <a href="https://en.wikipedia.org/wiki/Unit_type">unit <code>()</code> value</a>. Similarly, if the expression block is empty, there is an
implicit unit <code>()</code> value.</p>
<pre><code class="language-move">// Both are equivalent
{ x = x + 1; 1 / x; }
{ x = x + 1; 1 / x; () }
</code></pre>
<pre><code class="language-move">// Both are equivalent
{ }
{ () }
</code></pre>
<p>An expression block is itself an expression and can be used anyplace an expression is used. (Note:
The body of a function is also an expression block, but the function body cannot be replaced by
another expression.)</p>
<pre><code class="language-move">let my_vector: vector&lt;vector&lt;u8&gt;&gt; = {
    let v = vector::empty();
    vector::push_back(&amp;mut v, b&quot;hello&quot;);
    vector::push_back(&amp;mut v, b&quot;goodbye&quot;);
    v
};
</code></pre>
<p>(The type annotation is not needed in this example and only added for clarity.)</p>
<h3 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h3>
<p>If a <code>let</code> introduces a local variable with a name already in scope, that previous variable can no
longer be accessed for the rest of this scope. This is called <em>shadowing</em>.</p>
<pre><code class="language-move">let x = 0;
assert!(x == 0, 42);

let x = 1; // x is shadowed
assert!(x == 1, 42);
</code></pre>
<p>When a local is shadowed, it does not need to retain the same type as before.</p>
<pre><code class="language-move">let x = 0;
assert!(x == 0, 42);

let x = b&quot;hello&quot;; // x is shadowed
assert!(x == b&quot;hello&quot;, 42);
</code></pre>
<p>After a local is shadowed, the value stored in the local still exists, but will no longer be
accessible. This is important to keep in mind with values of types without the
<a href="./abilities.html"><code>drop</code> ability</a>, as ownership of the value must be transferred by the end of the
function.</p>
<pre><code class="language-move">address 0x42 {
    module example {
        struct Coin has store { value: u64 }

        fun unused_resource(): Coin {
            let x = Coin { value: 0 }; // ERROR!
//              ^ This local still contains a value without the `drop` ability
            x.value = 1;
            let x = Coin { value: 10 };
            x
//          ^ Invalid return
        }
    }
}
</code></pre>
<p>When a local is shadowed inside a scope, the shadowing only remains for that scope. The shadowing is
gone once that scope ends.</p>
<pre><code class="language-move">let x = 0;
{
    let x = 1;
    assert!(x == 1, 42);
};
assert!(x == 0, 42);
</code></pre>
<p>Remember, locals can change type when they are shadowed.</p>
<pre><code class="language-move">let x = 0;
{
    let x = b&quot;hello&quot;;
    assert!(x = b&quot;hello&quot;, 42);
};
assert!(x == 0, 42);
</code></pre>
<h2 id="move-and-copy"><a class="header" href="#move-and-copy">Move and Copy</a></h2>
<p>All local variables in Move can be used in two ways, either by <code>move</code> or <code>copy</code>. If one or the other
is not specified, the Move compiler is able to infer whether a <code>copy</code> or a <code>move</code> should be used.
This means that in all of the examples above, a <code>move</code> or a <code>copy</code> would be inserted by the
compiler. A local variable cannot be used without the use of <code>move</code> or <code>copy</code>.</p>
<p><code>copy</code> will likely feel the most familiar coming from other programming languages, as it creates a
new copy of the value inside of the variable to use in that expression. With <code>copy</code>, the local
variable can be used more than once.</p>
<pre><code class="language-move">let x = 0;
let y = copy x + 1;
let z = copy x + 2;
</code></pre>
<p>Any value with the <code>copy</code> <a href="./abilities.html">ability</a> can be copied in this way.</p>
<p><code>move</code> takes the value out of the local variable <em>without</em> copying the data. After a <code>move</code> occurs,
the local variable is unavailable.</p>
<pre><code class="language-move">let x = 1;
let y = move x + 1;
//      ------ Local was moved here
let z = move x + 2; // Error!
//      ^^^^^^ Invalid usage of local 'x'
y + z
</code></pre>
<h3 id="safety"><a class="header" href="#safety">Safety</a></h3>
<p>Move's type system will prevent a value from being used after it is moved. This is the same safety
check described in <a href="variables.html#let-bindings"><code>let</code> declaration</a> that prevents local variables from being used
before it is assigned a value.</p>
<!-- For more information, see TODO future section on ownership and move semantics. -->
<h3 id="inference"><a class="header" href="#inference">Inference</a></h3>
<p>As mentioned above, the Move compiler will infer a <code>copy</code> or <code>move</code> if one is not indicated. The
algorithm for doing so is quite simple:</p>
<ul>
<li>Any scalar value with the <code>copy</code> <a href="./abilities.html">ability</a> is given a <code>copy</code>.</li>
<li>Any reference (both mutable <code>&amp;mut</code> and immutable <code>&amp;</code>) is given a <code>copy</code>.
<ul>
<li>Except under special circumstances where it is made a <code>move</code> for predictable borrow checker
errors.</li>
</ul>
</li>
<li>Any other value is given a <code>move</code>.
<ul>
<li>This means that even though other values might be have the <code>copy</code> <a href="./abilities.html">ability</a>, it
must be done <em>explicitly</em> by the programmer.</li>
<li>This is to prevent accidental copies of large data structures.</li>
</ul>
</li>
</ul>
<p>For example:</p>
<pre><code class="language-move">let s = b&quot;hello&quot;;
let foo = Foo { f: 0 };
let coin = Coin { value: 0 };

let s2 = s; // move
let foo2 = foo; // move
let coin2 = coin; // move

let x = 0;
let b = false;
let addr = @0x42;
let x_ref = &amp;x;
let coin_ref = &amp;mut coin2;

let x2 = x; // copy
let b2 = b; // copy
let addr2 = @0x42; // copy
let x_ref2 = x_ref; // copy
let coin_ref2 = coin_ref; // copy
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="equality-1"><a class="header" href="#equality-1">Equality</a></h1>
<p>Move supports two equality operations <code>==</code> and <code>!=</code></p>
<h2 id="operations-4"><a class="header" href="#operations-4">Operations</a></h2>
<table><thead><tr><th>Syntax</th><th>Operation</th><th>Description</th></tr></thead><tbody>
<tr><td><code>==</code></td><td>equal</td><td>Returns <code>true</code> if the two operands have the same value, <code>false</code> otherwise</td></tr>
<tr><td><code>!=</code></td><td>not equal</td><td>Returns <code>true</code> if the two operands have different values, <code>false</code> otherwise</td></tr>
</tbody></table>
<h3 id="typing"><a class="header" href="#typing">Typing</a></h3>
<p>Both the equal (<code>==</code>) and not-equal (<code>!=</code>) operations only work if both operands are the same type</p>
<pre><code class="language-move">0 == 0; // `true`
1u128 == 2u128; // `false`
b&quot;hello&quot; != x&quot;00&quot;; // `true`
</code></pre>
<p>Equality and non-equality also work over user defined types!</p>
<pre><code class="language-move=">address 0x42 {
module example {
    struct S has copy, drop { f: u64, s: vector&lt;u8&gt; }

    fun always_true(): bool {
        let s = S { f: 0, s: b&quot;&quot; };
        // parens are not needed but added for clarity in this example
        (copy s) == s
    }

    fun always_false(): bool {
        let s = S { f: 0, s: b&quot;&quot; };
        // parens are not needed but added for clarity in this example
        (copy s) != s
    }
}
}
</code></pre>
<p>If the operands have different types, there is a type checking error</p>
<pre><code class="language-move">1u8 == 1u128; // ERROR!
//     ^^^^^ expected an argument of type 'u8'
b&quot;&quot; != 0; // ERROR!
//     ^ expected an argument of type 'vector&lt;u8&gt;'
</code></pre>
<h3 id="typing-with-references"><a class="header" href="#typing-with-references">Typing with references</a></h3>
<p>When comparing <a href="./references.html">references</a>, the type of the reference (immutable or mutable) does
not matter. This means that you can compare an immutable <code>&amp;</code> reference with a mutable one <code>&amp;mut</code> of
the same underlying type.</p>
<pre><code class="language-move">let i = &amp;0;
let m = &amp;mut 1;

i == m; // `false`
m == i; // `false`
m == m; // `true`
i == i; // `true`
</code></pre>
<p>The above is equivalent to applying an explicit freeze to each mutable reference where needed</p>
<pre><code class="language-move">let i = &amp;0;
let m = &amp;mut 1;

i == freeze(m); // `false`
freeze(m) == i; // `false`
m == m; // `true`
i == i; // `true`
</code></pre>
<p>But again, the underlying type must be the same type</p>
<pre><code class="language-move">let i = &amp;0;
let s = &amp;b&quot;&quot;;

i == s; // ERROR!
//   ^ expected an argument of type '&amp;u64'
</code></pre>
<h2 id="restrictions"><a class="header" href="#restrictions">Restrictions</a></h2>
<p>Both <code>==</code> and <code>!=</code> consume the value when comparing them. As a result, the type system enforces that
the type must have <a href="./abilities.html"><code>drop</code></a>. Recall that without the
<a href="./abilities.html"><code>drop</code> ability</a>, ownership must be transferred by the end of the function, and such
values can only be explicitly destroyed within their declaring module. If these were used directly
with either equality <code>==</code> or non-equality <code>!=</code>, the value would be destroyed which would break
<a href="./abilities.html"><code>drop</code> ability</a> safety guarantees!</p>
<pre><code class="language-move=">address 0x42 {
module example {
    struct Coin has store { value: u64 }
    fun invalid(c1: Coin, c2: Coin) {
        c1 == c2 // ERROR!
//      ^^    ^^ These resources would be destroyed!
    }
}
}
</code></pre>
<p>But, a programmer can <em>always</em> borrow the value first instead of directly comparing the value, and
reference types have the <a href="./abilities.html"><code>drop</code> ability</a>. For example</p>
<pre><code class="language-move=">address 0x42 {
module example {
    struct Coin as store { value: u64 }
    fun swap_if_equal(c1: Coin, c2: Coin): (Coin, Coin) {
        let are_equal = &amp;c1 == &amp;c2; // valid
        if (are_equal) (c2, c1) else (c1, c2)
    }
}
}
</code></pre>
<h2 id="avoid-extra-copies"><a class="header" href="#avoid-extra-copies">Avoid Extra Copies</a></h2>
<p>While a programmer <em>can</em> compare any value whose type has <a href="./abilities.html"><code>drop</code></a>, a programmer
should often compare by reference to avoid expensive copies.</p>
<pre><code class="language-move=">let v1: vector&lt;u8&gt; = function_that_returns_vector();
let v2: vector&lt;u8&gt; = function_that_returns_vector();
assert!(copy v1 == copy v2, 42);
//     ^^^^       ^^^^
use_two_vectors(v1, v2);

let s1: Foo = function_that_returns_large_struct();
let s2: Foo = function_that_returns_large_struct();
assert!(copy s1 == copy s2, 42);
//     ^^^^       ^^^^
use_two_foos(s1, s2);
</code></pre>
<p>This code is perfectly acceptable (assuming <code>Foo</code> has <a href="./abilities.html"><code>drop</code></a>), just not efficient.
The highlighted copies can be removed and replaced with borrows</p>
<pre><code class="language-move=">let v1: vector&lt;u8&gt; = function_that_returns_vector();
let v2: vector&lt;u8&gt; = function_that_returns_vector();
assert!(&amp;v1 == &amp;v2, 42);
//     ^      ^
use_two_vectors(v1, v2);

let s1: Foo = function_that_returns_large_struct();
let s2: Foo = function_that_returns_large_struct();
assert!(&amp;s1 == &amp;s2, 42);
//     ^      ^
use_two_foos(s1, s2);
</code></pre>
<p>The efficiency of the <code>==</code> itself remains the same, but the <code>copy</code>s are removed and thus the program
is more efficient.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abort-and-assert"><a class="header" href="#abort-and-assert">Abort and Assert</a></h1>
<p><a href="./functions.html"><code>return</code></a> and <code>abort</code> are two control flow constructs that end execution, one for
the current function and one for the entire transaction.</p>
<p>More information on <a href="./functions.html"><code>return</code> can be found in the linked section</a></p>
<h2 id="abort"><a class="header" href="#abort"><code>abort</code></a></h2>
<p><code>abort</code> is an expression that takes one argument: an <strong>abort code</strong> of type <code>u64</code>. For example:</p>
<pre><code class="language-move">abort 42
</code></pre>
<p>The <code>abort</code> expression halts execution the current function and reverts all changes made to global
state by the current transaction. There is no mechanism for &quot;catching&quot; or otherwise handling an
<code>abort</code>.</p>
<p>Luckily, in Move transactions are all or nothing, meaning any changes to global storage are made all
at once only if the transaction succeeds. Because of this transactional commitment of changes, after
an abort there is no need to worry about backing out changes. While this approach is lacking in
flexibility, it is incredibly simple and predictable.</p>
<p>Similar to <a href="./functions.html"><code>return</code></a>, <code>abort</code> is useful for exiting control flow when some
condition cannot be met.</p>
<p>In this example, the function will pop two items off of the vector, but will abort early if the
vector does not have two items</p>
<pre><code class="language-move=">use std::vector;
fun pop_twice&lt;T&gt;(v: &amp;mut vector&lt;T&gt;): (T, T) {
    if (vector::length(v) &lt; 2) abort 42;

    (vector::pop_back(v), vector::pop_back(v))
}
</code></pre>
<p>This is even more useful deep inside a control-flow construct. For example, this function checks
that all numbers in the vector are less than the specified <code>bound</code>. And aborts otherwise</p>
<pre><code class="language-move=">use std::vector;
fun check_vec(v: &amp;vector&lt;u64&gt;, bound: u64) {
    let i = 0;
    let n = vector::length(v);
    while (i &lt; n) {
        let cur = *vector::borrow(v, i);
        if (cur &gt; bound) abort 42;
        i = i + 1;
    }
}
</code></pre>
<h3 id="assert"><a class="header" href="#assert"><code>assert</code></a></h3>
<p><code>assert</code> is a builtin, macro-like operation provided by the Move compiler. It takes two arguments, a
condition of type <code>bool</code> and a code of type <code>u64</code></p>
<pre><code class="language-move">assert!(condition: bool, code: u64)
</code></pre>
<p>Since the operation is a macro, it must be invoked with the <code>!</code>. This is to convey that the
arguments to <code>assert</code> are call-by-expression. In other words, <code>assert</code> is not a normal function and
does not exist at the bytecode level. It is replaced inside the compiler with</p>
<pre><code class="language-move">if (condition) () else abort code
</code></pre>
<p><code>assert</code> is more commonly used than just <code>abort</code> by itself. The <code>abort</code> examples above can be
rewritten using <code>assert</code></p>
<pre><code class="language-move=">use std::vector;
fun pop_twice&lt;T&gt;(v: &amp;mut vector&lt;T&gt;): (T, T) {
    assert!(vector::length(v) &gt;= 2, 42); // Now uses 'assert'

    (vector::pop_back(v), vector::pop_back(v))
}
</code></pre>
<p>and</p>
<pre><code class="language-move=">use std::vector;
fun check_vec(v: &amp;vector&lt;u64&gt;, bound: u64) {
    let i = 0;
    let n = vector::length(v);
    while (i &lt; n) {
        let cur = *vector::borrow(v, i);
        assert!(cur &lt;= bound, 42); // Now uses 'assert'
        i = i + 1;
    }
}
</code></pre>
<p>Note that because the operation is replaced with this <code>if-else</code>, the argument for the <code>code</code> is not
always evaluated. For example:</p>
<pre><code class="language-move">assert!(true, 1 / 0)
</code></pre>
<p>Will not result in an arithmetic error, it is equivalent to</p>
<pre><code class="language-move">if (true) () else (1 / 0)
</code></pre>
<p>So the arithmetic expression is never evaluated!</p>
<h3 id="abort-codes-in-the-move-vm"><a class="header" href="#abort-codes-in-the-move-vm">Abort codes in the Move VM</a></h3>
<p>When using <code>abort</code>, it is important to understand how the <code>u64</code> code will be used by the VM.</p>
<p>Normally, after successful execution, the Move VM produces a change-set for the changes made to
global storage (added/removed resources, updates to existing resources, etc).</p>
<p>If an <code>abort</code> is reached, the VM will instead indicate an error. Included in that error will be two
pieces of information:</p>
<ul>
<li>The module that produced the abort (address and name)</li>
<li>The abort code.</li>
</ul>
<p>For example</p>
<pre><code class="language-move=">address 0x2 {
module example {
    public fun aborts() {
        abort 42
    }
}
}

script {
    fun always_aborts() {
        0x2::example::aborts()
    }
}
</code></pre>
<p>If a transaction, such as the script <code>always_aborts</code> above, calls <code>0x2::example::aborts</code>, the VM
would produce an error that indicated the module <code>0x2::example</code> and the code <code>42</code>.</p>
<p>This can be useful for having multiple aborts being grouped together inside a module.</p>
<p>In this example, the module has two separate error codes used in multiple functions</p>
<pre><code class="language-move=">address 0x42 {
module example {

    use std::vector;

    const EMPTY_VECTOR: u64 = 0;
    const INDEX_OUT_OF_BOUNDS: u64 = 1;

    // move i to j, move j to k, move k to i
    public fun rotate_three&lt;T&gt;(v: &amp;mut vector&lt;T&gt;, i: u64, j: u64, k: u64) {
        let n = vector::length(v);
        assert!(n &gt; 0, EMPTY_VECTOR);
        assert!(i &lt; n, INDEX_OUT_OF_BOUNDS);
        assert!(j &lt; n, INDEX_OUT_OF_BOUNDS);
        assert!(k &lt; n, INDEX_OUT_OF_BOUNDS);

        vector::swap(v, i, k);
        vector::swap(v, j, k);
    }

    public fun remove_twice&lt;T&gt;(v: &amp;mut vector&lt;T&gt;, i: u64, j: u64): (T, T) {
        let n = vector::length(v);
        assert!(n &gt; 0, EMPTY_VECTOR);
        assert!(i &lt; n, INDEX_OUT_OF_BOUNDS);
        assert!(j &lt; n, INDEX_OUT_OF_BOUNDS);
        assert!(i &gt; j, INDEX_OUT_OF_BOUNDS);

        (vector::remove&lt;T&gt;(v, i), vector::remove&lt;T&gt;(v, j))
    }
}
}
</code></pre>
<h2 id="the-type-of-abort"><a class="header" href="#the-type-of-abort">The type of <code>abort</code></a></h2>
<p>The <code>abort i</code> expression can have any type! This is because both constructs break from the normal
control flow, so they never need to evaluate to the value of that type.</p>
<p>The following are not useful, but they will type check</p>
<pre><code class="language-move">let y: address = abort 0;
</code></pre>
<p>This behavior can be helpful in situations where you have a branching instruction that produces a
value on some branches, but not all. For example:</p>
<pre><code class="language-move">let b =
    if (x == 0) false
    else if (x == 1) true
    else abort 42;
//       ^^^^^^^^ `abort 42` has type `bool`
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conditionals"><a class="header" href="#conditionals">Conditionals</a></h1>
<p>An <code>if</code> expression specifies that some code should only be evaluated if a certain condition is true. For example:</p>
<pre><code class="language-move">if (x &gt; 5) x = x - 5
</code></pre>
<p>The condition must be an expression of type <code>bool</code>.</p>
<p>An <code>if</code> expression can optionally include an <code>else</code> clause to specify another expression to evaluate when the condition is false.</p>
<pre><code class="language-move">if (y &lt;= 10) y = y + 1 else y = 10
</code></pre>
<p>Either the &quot;true&quot; branch or the &quot;false&quot; branch will be evaluated, but not both. Either branch can be a single expression or an expression block.</p>
<p>The conditional expressions may produce values so that the <code>if</code> expression has a result.</p>
<pre><code class="language-move">let z = if (x &lt; 100) x else 100;
</code></pre>
<p>The expressions in the true and false branches must have compatible types. For example:</p>
<pre><code class="language-move=">// x and y must be u64 integers
let maximum: u64 = if (x &gt; y) x else y;

// ERROR! branches different types
let z = if (maximum &lt; 10) 10u8 else 100u64;

// ERROR! branches different types, as default false-branch is () not u64
if (maximum &gt;= 10) maximum;
</code></pre>
<p>If the <code>else</code> clause is not specified, the false branch defaults to the unit value. The following are equivalent:</p>
<pre><code class="language-move">if (condition) true_branch // implied default: else ()
if (condition) true_branch else ()
</code></pre>
<p>Commonly, <a href="./conditionals.html"><code>if</code> expressions</a> are used in conjunction with expression blocks.</p>
<pre><code class="language-move">let maximum = if (x &gt; y) x else y;
if (maximum &lt; 10) {
    x = x + 10;
    y = y + 10;
} else if (x &gt;= 10 &amp;&amp; y &gt;= 10) {
    x = x - 10;
    y = y - 10;
}
</code></pre>
<h2 id="grammar-for-conditionals"><a class="header" href="#grammar-for-conditionals">Grammar for Conditionals</a></h2>
<blockquote>
<p><em>if-expression</em> → <strong>if (</strong> <em>expression</em> <strong>)</strong> <em>expression</em> <em>else-clause</em><sub><em>opt</em></sub>
<em>else-clause</em> → <strong>else</strong> <em>expression</em></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="while-and-loop"><a class="header" href="#while-and-loop">While and Loop</a></h1>
<p>Move offers two constructs for looping: <code>while</code> and <code>loop</code>.</p>
<h2 id="while-loops"><a class="header" href="#while-loops"><code>while</code> loops</a></h2>
<p>The <code>while</code> construct repeats the body (an expression of type unit) until the condition (an expression of type <code>bool</code>) evaluates to <code>false</code>.</p>
<p>Here is an example of simple <code>while</code> loop that computes the sum of the numbers from <code>1</code> to <code>n</code>:</p>
<pre><code class="language-move">fun sum(n: u64): u64 {
    let sum = 0;
    let i = 1;
    while (i &lt;= n) {
        sum = sum + i;
        i = i + 1
    };

    sum
}
</code></pre>
<p>Infinite loops are allowed:</p>
<pre><code class="language-move=">fun foo() {
    while (true) { }
}
</code></pre>
<h3 id="break"><a class="header" href="#break"><code>break</code></a></h3>
<p>The <code>break</code> expression can be used to exit a loop before the condition evaluates to <code>false</code>. For example, this loop uses <code>break</code> to find the smallest factor of <code>n</code> that's greater than 1:</p>
<pre><code class="language-move">fun smallest_factor(n: u64): u64 {
    // assuming the input is not 0 or 1
    let i = 2;
    while (i &lt;= n) {
        if (n % i == 0) break;
        i = i + 1
    };

    i
}
</code></pre>
<p>The <code>break</code> expression cannot be used outside of a loop.</p>
<h3 id="continue"><a class="header" href="#continue"><code>continue</code></a></h3>
<p>The <code>continue</code> expression skips the rest of the loop and continues to the next iteration. This loop uses <code>continue</code> to compute the sum of <code>1, 2, ..., n</code>, except when the number is divisible by 10:</p>
<pre><code class="language-move">fun sum_intermediate(n: u64): u64 {
    let sum = 0;
    let i = 0;
    while (i &lt; n) {
        i = i + 1;
        if (i % 10 == 0) continue;
        sum = sum + i;
    };

    sum
}
</code></pre>
<p>The <code>continue</code> expression cannot be used outside of a loop.</p>
<h3 id="the-type-of-break-and-continue"><a class="header" href="#the-type-of-break-and-continue">The type of <code>break</code> and <code>continue</code></a></h3>
<p><code>break</code> and <code>continue</code>, much like <code>return</code> and <code>abort</code>, can have any type. The following examples illustrate where this flexible typing can be helpful:</p>
<pre><code class="language-move">fun pop_smallest_while_not_equal(
    v1: vector&lt;u64&gt;,
    v2: vector&lt;u64&gt;,
): vector&lt;u64&gt; {
    let result = vector::empty();
    while (!vector::is_empty(&amp;v1) &amp;&amp; !vector::is_empty(&amp;v2)) {
        let u1 = *vector::borrow(&amp;v1, vector::length(&amp;v1) - 1);
        let u2 = *vector::borrow(&amp;v2, vector::length(&amp;v2) - 1);
        let popped =
            if (u1 &lt; u2) vector::pop_back(&amp;mut v1)
            else if (u2 &lt; u1) vector::pop_back(&amp;mut v2)
            else break; // Here, `break` has type `u64`
        vector::push_back(&amp;mut result, popped);
    };

    result
}
</code></pre>
<pre><code class="language-move">fun pick(
    indexes: vector&lt;u64&gt;,
    v1: &amp;vector&lt;address&gt;,
    v2: &amp;vector&lt;address&gt;
): vector&lt;address&gt; {
    let len1 = vector::length(v1);
    let len2 = vector::length(v2);
    let result = vector::empty();
    while (!vector::is_empty(&amp;indexes)) {
        let index = vector::pop_back(&amp;mut indexes);
        let chosen_vector =
            if (index &lt; len1) v1
            else if (index &lt; len2) v2
            else continue; // Here, `continue` has type `&amp;vector&lt;address&gt;`
        vector::push_back(&amp;mut result, *vector::borrow(chosen_vector, index))
    };

    result
}
</code></pre>
<h2 id="the-loop-expression"><a class="header" href="#the-loop-expression">The <code>loop</code> expression</a></h2>
<p>The <code>loop</code> expression repeats the loop body (an expression with type <code>()</code>) until it hits a <code>break</code></p>
<p>Without a <code>break</code>, the loop will continue forever</p>
<pre><code class="language-move">fun foo() {
    let i = 0;
    loop { i = i + 1 }
}
</code></pre>
<p>Here is an example that uses <code>loop</code> to write the <code>sum</code> function:</p>
<pre><code class="language-move">fun sum(n: u64): u64 {
    let sum = 0;
    let i = 0;
    loop {
        i = i + 1;
        if (i &gt; n) break;
        sum = sum + i
    };

    sum
}
</code></pre>
<p>As you might expect, <code>continue</code> can also be used inside a <code>loop</code>. Here is <code>sum_intermediate</code> from above rewritten using <code>loop</code> instead of <code>while</code></p>
<pre><code class="language-move">fun sum_intermediate(n: u64): u64 {
    let sum = 0;
    let i = 0;
    loop {
        i = i + 1;
        if (i % 10 == 0) continue;
        if (i &gt; n) break;
        sum = sum + i
    };

    sum
}
</code></pre>
<h2 id="the-type-of-while-and-loop"><a class="header" href="#the-type-of-while-and-loop">The type of <code>while</code> and <code>loop</code></a></h2>
<p>Move loops are typed expressions. A <code>while</code> expression always has type <code>()</code>.</p>
<pre><code class="language-move">let () = while (i &lt; 10) { i = i + 1 };
</code></pre>
<p>If a <code>loop</code> contains a <code>break</code>, the expression has type unit <code>()</code></p>
<pre><code class="language-move">(loop { if (i &lt; 10) i = i + 1 else break }: ());
let () = loop { if (i &lt; 10) i = i + 1 else break };
</code></pre>
<p>If <code>loop</code> does not have a <code>break</code>, <code>loop</code> can have any type much like <code>return</code>, <code>abort</code>, <code>break</code>, and <code>continue</code>.</p>
<pre><code class="language-move">(loop (): u64);
(loop (): address);
(loop (): &amp;vector&lt;vector&lt;u8&gt;&gt;);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Function syntax in Move is shared between module functions and script functions. Functions inside of modules are reusable, whereas script functions are only used once to invoke a transaction.</p>
<h2 id="declaration"><a class="header" href="#declaration">Declaration</a></h2>
<p>Functions are declared with the <code>fun</code> keyword followed by the function name, type parameters, parameters, a return type, acquires annotations, and finally the function body.</p>
<pre><code class="language-text">fun &lt;identifier&gt;&lt;[type_parameters: constraint],*&gt;([identifier: type],*): &lt;return_type&gt; &lt;acquires [identifier],*&gt; &lt;function_body&gt;
</code></pre>
<p>For example</p>
<pre><code class="language-move">fun foo&lt;T1, T2&gt;(x: u64, y: T1, z: T2): (T2, T1, u64) { (z, y, x) }
</code></pre>
<h3 id="visibility"><a class="header" href="#visibility">Visibility</a></h3>
<p>Module functions, by default, can only be called within the same module. These internal (sometimes called private) functions cannot be called from other modules or from scripts.</p>
<pre><code class="language-move=">address 0x42 {
module m {
    fun foo(): u64 { 0 }
    fun calls_foo(): u64 { foo() } // valid
}

module other {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // ERROR!
//      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'
    }
}
}

script {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // ERROR!
//      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'
    }
}
</code></pre>
<p>To allow access from other modules or from scripts, the function must be declared <code>public</code> or <code>public(friend)</code>.</p>
<h4 id="public-visibility"><a class="header" href="#public-visibility"><code>public</code> visibility</a></h4>
<p>A <code>public</code> function can be called by <em>any</em> function defined in <em>any</em> module or script. As shown in the following example, a <code>public</code> function can be called by:</p>
<ul>
<li>other functions defined in the same module,</li>
<li>functions defined in another module, or</li>
<li>the function defined in a script.</li>
</ul>
<p>There are also no restrictions for what the argument types a public function can take and its return type.</p>
<pre><code class="language-move=">address 0x42 {
module m {
    public fun foo(): u64 { 0 }
    fun calls_foo(): u64 { foo() } // valid
}

module other {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // valid
    }
}
}

script {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // valid
    }
}
</code></pre>
<h4 id="publicfriend-visibility"><a class="header" href="#publicfriend-visibility"><code>public(friend)</code> visibility</a></h4>
<p>The <code>public(friend)</code> visibility modifier is a more restricted form of the <code>public</code> modifier to give more control about where a function can be used. A <code>public(friend)</code> function can be called by:</p>
<ul>
<li>other functions defined in the same module, or</li>
<li>functions defined in modules which are explicitly specified in the <strong>friend list</strong> (see <a href="./friends.html">Friends</a> on how to specify the friend list).</li>
</ul>
<p>Note that since we cannot declare a script to be a friend of a module, the functions defined in scripts can never call a <code>public(friend)</code> function.</p>
<pre><code class="language-move=">address 0x42 {
module m {
    friend 0x42::n;  // friend declaration
    public(friend) fun foo(): u64 { 0 }
    fun calls_foo(): u64 { foo() } // valid
}

module n {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // valid
    }
}

module other {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // ERROR!
//      ^^^^^^^^^^^^ 'foo' can only be called from a 'friend' of module '0x42::m'
    }
}
}

script {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // ERROR!
//      ^^^^^^^^^^^^ 'foo' can only be called from a 'friend' of module '0x42::m'
    }
}
</code></pre>
<h3 id="entry-modifier"><a class="header" href="#entry-modifier"><code>entry</code> modifier</a></h3>
<p>The <code>entry</code> modifier is designed to allow module functions to be safely and directly invoked much like scripts. This allows module writers to specify which functions can be to begin execution. The module writer then knows that any non-<code>entry</code> function will be called from a Move program already in execution.</p>
<p>Essentially, <code>entry</code> functions are the &quot;main&quot; functions of a module, and they specify where Move programs start executing.</p>
<p>Note though, an <code>entry</code> function <em>can</em> still be called by other Move functions. So while they <em>can</em> serve as the start of a Move program, they aren't restricted to that case.</p>
<p>For example:</p>
<pre><code class="language-move=">address 0x42 {
module m {
    public entry fun foo(): u64 { 0 }
    fun calls_foo(): u64 { foo() } // valid!
}

module n {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // valid!
    }
}

module other {
    public entry fun calls_m_foo(): u64 {
        0x42::m::foo() // valid!
    }
}
}

script {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // valid!
    }
}
</code></pre>
<p>Even internal functions can be marked as <code>entry</code>! This lets you guarantee that the function is called only at the beginning of execution (assuming you do not call it elsewhere in your module)</p>
<pre><code class="language-move=">address 0x42 {
module m {
    entry fun foo(): u64 { 0 } // valid! entry functions do not have to be public
}

module n {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // ERROR!
//      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'
    }
}

module other {
    public entry fun calls_m_foo(): u64 {
        0x42::m::foo() // ERROR!
//      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'
    }
}
}

script {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // ERROR!
//      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'
    }
}
</code></pre>
<p>Entry functions can take primitive types, String, and vector arguments but cannot take Structs (e.g. Option). They also
must not have any return values.</p>
<h3 id="name"><a class="header" href="#name">Name</a></h3>
<p>Function names can start with letters <code>a</code> to <code>z</code> or letters <code>A</code> to <code>Z</code>. After the first character, function names can contain underscores <code>_</code>, letters <code>a</code> to <code>z</code>, letters <code>A</code> to <code>Z</code>, or digits <code>0</code> to <code>9</code>.</p>
<pre><code class="language-move">fun FOO() {}
fun bar_42() {}
fun _bAZ19() {}
</code></pre>
<h3 id="type-parameters"><a class="header" href="#type-parameters">Type Parameters</a></h3>
<p>After the name, functions can have type parameters</p>
<pre><code class="language-move">fun id&lt;T&gt;(x: T): T { x }
fun example&lt;T1: copy, T2&gt;(x: T1, y: T2): (T1, T1, T2) { (copy x, x, y) }
</code></pre>
<p>For more details, see <a href="./generics.html">Move generics</a>.</p>
<h3 id="parameters"><a class="header" href="#parameters">Parameters</a></h3>
<p>Functions parameters are declared with a local variable name followed by a type annotation</p>
<pre><code class="language-move">fun add(x: u64, y: u64): u64 { x + y }
</code></pre>
<p>We read this as <code>x</code> has type <code>u64</code></p>
<p>A function does not have to have any parameters at all.</p>
<pre><code class="language-move">fun useless() { }
</code></pre>
<p>This is very common for functions that create new or empty data structures</p>
<pre><code class="language-move=">address 0x42 {
module example {
  struct Counter { count: u64 }

  fun new_counter(): Counter {
      Counter { count: 0 }
  }

}
}
</code></pre>
<h3 id="acquires"><a class="header" href="#acquires">Acquires</a></h3>
<p>When a function accesses a resource using <code>move_from</code>, <code>borrow_global</code>, or <code>borrow_global_mut</code>, the function must indicate that it <code>acquires</code> that resource. This is then used by Move's type system to ensure the references into global storage are safe, specifically that there are no dangling references into global storage.</p>
<pre><code class="language-move=">address 0x42 {
module example {

    struct Balance has key { value: u64 }

    public fun add_balance(s: &amp;signer, value: u64) {
        move_to(s, Balance { value })
    }

    public fun extract_balance(addr: address): u64 acquires Balance {
        let Balance { value } = move_from(addr); // acquires needed
        value
    }
}
}
</code></pre>
<p><code>acquires</code> annotations must also be added for transitive calls within the module. Calls to these functions from another module do not need to annotated with these acquires because one module cannot access resources declared in another module--so the annotation is not needed to ensure reference safety.</p>
<pre><code class="language-move=">address 0x42 {
module example {

    struct Balance has key { value: u64 }

    public fun add_balance(s: &amp;signer, value: u64) {
        move_to(s, Balance { value })
    }

    public fun extract_balance(addr: address): u64 acquires Balance {
        let Balance { value } = move_from(addr); // acquires needed
        value
    }

    public fun extract_and_add(sender: address, receiver: &amp;signer) acquires Balance {
        let value = extract_balance(sender); // acquires needed here
        add_balance(receiver, value)
    }
}
}

address 0x42 {
module other {
    fun extract_balance(addr: address): u64 {
        0x42::example::extract_balance(addr) // no acquires needed
    }
}
}
</code></pre>
<p>A function can <code>acquire</code> as many resources as it needs to</p>
<pre><code class="language-move=">address 0x42 {
module example {
    use std::vector;

    struct Balance has key { value: u64 }
    struct Box&lt;T&gt; has key { items: vector&lt;T&gt; }

    public fun store_two&lt;Item1: store, Item2: store&gt;(
        addr: address,
        item1: Item1,
        item2: Item2,
    ) acquires Balance, Box {
        let balance = borrow_global_mut&lt;Balance&gt;(addr); // acquires needed
        balance.value = balance.value - 2;
        let box1 = borrow_global_mut&lt;Box&lt;Item1&gt;&gt;(addr); // acquires needed
        vector::push_back(&amp;mut box1.items, item1);
        let box2 = borrow_global_mut&lt;Box&lt;Item2&gt;&gt;(addr); // acquires needed
        vector::push_back(&amp;mut box2.items, item2);
    }
}
}
</code></pre>
<h3 id="return-type"><a class="header" href="#return-type">Return type</a></h3>
<p>After the parameters, a function specifies its return type.</p>
<pre><code class="language-move">fun zero(): u64 { 0 }
</code></pre>
<p>Here <code>: u64</code> indicates that the function's return type is <code>u64</code>.</p>
<p>Using tuples, a function can return multiple values:</p>
<pre><code class="language-move">fun one_two_three(): (u64, u64, u64) { (0, 1, 2) }
</code></pre>
<p>If no return type is specified, the function has an implicit return type of unit <code>()</code>. These functions are equivalent:</p>
<pre><code class="language-move">fun just_unit(): () { () }
fun just_unit() { () }
fun just_unit() { }
</code></pre>
<p><code>script</code> functions must have a return type of unit <code>()</code>:</p>
<pre><code class="language-move">script {
    fun do_nothing() {
    }
}
</code></pre>
<p>As mentioned in the <a href="./tuples.html">tuples section</a>, these tuple &quot;values&quot; are virtual and do not exist at runtime. So for a function that returns unit <code>()</code>, it will not be returning any value at all during execution.</p>
<h3 id="function-body"><a class="header" href="#function-body">Function body</a></h3>
<p>A function's body is an expression block. The return value of the function is the last value in the sequence</p>
<pre><code class="language-move=">fun example(): u64 {
    let x = 0;
    x = x + 1;
    x // returns 'x'
}
</code></pre>
<p>See <a href="functions.html#returning-values">the section below for more information on returns</a></p>
<p>For more information on expression blocks, see <a href="./variables.html">Move variables</a>.</p>
<h3 id="native-functions"><a class="header" href="#native-functions">Native Functions</a></h3>
<p>Some functions do not have a body specified, and instead have the body provided by the VM. These functions are marked <code>native</code>.</p>
<p>Without modifying the VM source code, a programmer cannot add new native functions. Furthermore, it is the intent that <code>native</code> functions are used for either standard library code or for functionality needed for the given Move environment.</p>
<p>Most <code>native</code> functions you will likely see are in standard library code such as <code>vector</code></p>
<pre><code class="language-move=">module std::vector {
    native public fun empty&lt;Element&gt;(): vector&lt;Element&gt;;
    ...
}
</code></pre>
<h2 id="calling"><a class="header" href="#calling">Calling</a></h2>
<p>When calling a function, the name can be specified either through an alias or fully qualified</p>
<pre><code class="language-move=">address 0x42 {
module example {
    public fun zero(): u64 { 0 }
}
}

script {
    use 0x42::example::{Self, zero};
    fun call_zero() {
        // With the `use` above all of these calls are equivalent
        0x42::example::zero();
        example::zero();
        zero();
    }
}
</code></pre>
<p>When calling a function, an argument must be given for every parameter.</p>
<pre><code class="language-move=">address 0x42 {
module example {
    public fun takes_none(): u64 { 0 }
    public fun takes_one(x: u64): u64 { x }
    public fun takes_two(x: u64, y: u64): u64 { x + y }
    public fun takes_three(x: u64, y: u64, z: u64): u64 { x + y + z }
}
}

script {
    use 0x42::example;
    fun call_all() {
        example::takes_none();
        example::takes_one(0);
        example::takes_two(0, 1);
        example::takes_three(0, 1, 2);
    }
}
</code></pre>
<p>Type arguments can be either specified or inferred. Both calls are equivalent.</p>
<pre><code class="language-move=">address 0x42 {
module example {
    public fun id&lt;T&gt;(x: T): T { x }
}
}

script {
    use 0x42::example;
    fun call_all() {
        example::id(0);
        example::id&lt;u64&gt;(0);
    }
}
</code></pre>
<p>For more details, see <a href="./generics.html">Move generics</a>.</p>
<h2 id="returning-values"><a class="header" href="#returning-values">Returning values</a></h2>
<p>The result of a function, its &quot;return value&quot;, is the final value of its function body. For example</p>
<pre><code class="language-move=">fun add(x: u64, y: u64): u64 {
    x + y
}
</code></pre>
<p><a href="functions.html#function-body">As mentioned above</a>, the function's body is an <a href="./variables.html">expression block</a>. The expression block can sequence various statements, and the final expression in the block will be be the value of that block</p>
<pre><code class="language-move=">fun double_and_add(x: u64, y: u64): u64 {
    let double_x = x * 2;
    let double_y = y * 2;
    double_x + double_y
}
</code></pre>
<p>The return value here is <code>double_x + double_y</code></p>
<h3 id="return-expression"><a class="header" href="#return-expression"><code>return</code> expression</a></h3>
<p>A function implicitly returns the value that its body evaluates to. However, functions can also use the explicit <code>return</code> expression:</p>
<pre><code class="language-move">fun f1(): u64 { return 0 }
fun f2(): u64 { 0 }
</code></pre>
<p>These two functions are equivalent. In this slightly more involved example, the function subtracts two <code>u64</code> values, but returns early with <code>0</code> if the second value is too large:</p>
<pre><code class="language-move=">fun safe_sub(x: u64, y: u64): u64 {
    if (y &gt; x) return 0;
    x - y
}
</code></pre>
<p>Note that the body of this function could also have been written as <code>if (y &gt; x) 0 else x - y</code>.</p>
<p>However <code>return</code> really shines is in exiting deep within other control flow constructs. In this example, the function iterates through a vector to find the index of a given value:</p>
<pre><code class="language-move=">use std::vector;
use std::option::{Self, Option};
fun index_of&lt;T&gt;(v: &amp;vector&lt;T&gt;, target: &amp;T): Option&lt;u64&gt; {
    let i = 0;
    let n = vector::length(v);
    while (i &lt; n) {
        if (vector::borrow(v, i) == target) return option::some(i);
        i = i + 1
    };

    option::none()
}
</code></pre>
<p>Using <code>return</code> without an argument is shorthand for <code>return ()</code>. That is, the following two functions are equivalent:</p>
<pre><code class="language-move">fun foo() { return }
fun foo() { return () }
</code></pre>
<h2 id="inline-functions"><a class="header" href="#inline-functions">Inline Functions</a></h2>
<p>Inline functions are functions which are expanded at caller side instead
of compiled into Move bytecode. This allows to safe gas and may lead
to faster execution. For example, one can define an inline function</p>
<pre><code class="language-move=">inline fun percent(x: u64, y: u64):u64 { x * 100 / y }
</code></pre>
<p>Now, when call <code>percent(2, 200)</code> the compiler will inline the function
definition as if the user has written <code>2 * 100 / 200</code>.</p>
<h3 id="function-parameters"><a class="header" href="#function-parameters">Function Parameters</a></h3>
<p>Inline functions support <em>function parameters</em>. This allows
to define higher-order functions in Move which can comprehend common
programming patterns. As inline functions are expanded at compilation time,
this feature of function parameters can be supported without direct
support for it in Move bytecode.</p>
<p>Consider the following function (from the <code>vector</code> module):</p>
<pre><code class="language-move=">/// Fold the function over the elements. For example, `fold(vector[1,2,3], 0, f)` will execute
/// `f(f(f(0, 1), 2), 3)`
public inline fun fold&lt;Accumulator, Element&gt;(
    v: vector&lt;Element&gt;,
    init: Accumulator,
    f: |Accumulator,Element|Accumulator
): Accumulator {
  let accu = init;
  foreach(v, |elem| accu = g(accu, elem));
  accu
}
</code></pre>
<p>Here, <code>foreach</code> is itself an inline function.</p>
<p>In general, only lambda expressions can be passed to function parameters.
Similar as the inline function itself, those lambdas are expanded at caller
side. Notice that a lambda can access variables in the context, as in the
example the variable <code>accu</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs-and-resources"><a class="header" href="#structs-and-resources">Structs and Resources</a></h1>
<p>A <em>struct</em> is a user-defined data structure containing typed fields. Structs can store any
non-reference type, including other structs.</p>
<p>We often refer to struct values as <em>resources</em> if they cannot be copied and cannot be dropped. In
this case, resource values must have ownership transferred by the end of the function. This property
makes resources particularly well served for defining global storage schemas or for representing
important values (such as a token).</p>
<p>By default, structs are linear and ephemeral. By this we mean that they: cannot be copied, cannot be
dropped, and cannot be stored in global storage. This means that all values have to have ownership
transferred (linear) and the values must be dealt with by the end of the program's execution
(ephemeral). We can relax this behavior by giving the struct <a href="./abilities.html">abilities</a> which allow
values to be copied or dropped and also to be stored in global storage or to define global storage
schemas.</p>
<h2 id="defining-structs"><a class="header" href="#defining-structs">Defining Structs</a></h2>
<p>Structs must be defined inside a module:</p>
<pre><code class="language-move">address 0x2 {
module m {
    struct Foo { x: u64, y: bool }
    struct Bar {}
    struct Baz { foo: Foo, }
    //                   ^ note: it is fine to have a trailing comma
}
}
</code></pre>
<p>Structs cannot be recursive, so the following definition is invalid:</p>
<pre><code class="language-move">struct Foo { x: Foo }
//              ^ error! Foo cannot contain Foo
</code></pre>
<p>As mentioned above: by default, a struct declaration is linear and ephemeral. So to allow the value
to be used with certain operations (that copy it, drop it, store it in global storage, or use it as
a storage schema), structs can be granted <a href="./abilities.html">abilities</a> by annotating them with
<code>has &lt;ability&gt;</code>:</p>
<pre><code class="language-move">address 0x2 {
module m {
    struct Foo has copy, drop { x: u64, y: bool }
}
}
</code></pre>
<p>For more details, see the <a href="./abilities.html#annotating-structs">annotating structs</a> section.</p>
<h3 id="naming"><a class="header" href="#naming">Naming</a></h3>
<p>Structs must start with a capital letter <code>A</code> to <code>Z</code>. After the first letter, struct names can
contain underscores <code>_</code>, letters <code>a</code> to <code>z</code>, letters <code>A</code> to <code>Z</code>, or digits <code>0</code> to <code>9</code>.</p>
<pre><code class="language-move">struct Foo {}
struct BAR {}
struct B_a_z_4_2 {}
</code></pre>
<p>This naming restriction of starting with <code>A</code> to <code>Z</code> is in place to give room for future language
features. It may or may not be removed later.</p>
<h2 id="using-structs"><a class="header" href="#using-structs">Using Structs</a></h2>
<h3 id="creating-structs"><a class="header" href="#creating-structs">Creating Structs</a></h3>
<p>Values of a struct type can be created (or &quot;packed&quot;) by indicating the struct name, followed by
value for each field:</p>
<pre><code class="language-move">address 0x2 {
module m {
    struct Foo has drop { x: u64, y: bool }
    struct Baz has drop { foo: Foo }

    fun example() {
        let foo = Foo { x: 0, y: false };
        let baz = Baz { foo: foo };
    }
}
}
</code></pre>
<p>If you initialize a struct field with a local variable whose name is the same as the field, you can
use the following shorthand:</p>
<pre><code class="language-move">let baz = Baz { foo: foo };
// is equivalent to
let baz = Baz { foo };
</code></pre>
<p>This is called sometimes called &quot;field name punning&quot;.</p>
<h3 id="destroying-structs-via-pattern-matching"><a class="header" href="#destroying-structs-via-pattern-matching">Destroying Structs via Pattern Matching</a></h3>
<p>Struct values can be destroyed by binding or assigning them patterns.</p>
<pre><code class="language-move">address 0x2 {
module m {
    struct Foo { x: u64, y: bool }
    struct Bar { foo: Foo }
    struct Baz {}

    fun example_destroy_foo() {
        let foo = Foo { x: 3, y: false };
        let Foo { x, y: foo_y } = foo;
        //        ^ shorthand for `x: x`

        // two new bindings
        //   x: u64 = 3
        //   foo_y: bool = false
    }

    fun example_destroy_foo_wildcard() {
        let foo = Foo { x: 3, y: false };
        let Foo { x, y: _ } = foo;

        // only one new binding since y was bound to a wildcard
        //   x: u64 = 3
    }

    fun example_destroy_foo_assignment() {
        let x: u64;
        let y: bool;
        Foo { x, y } = Foo { x: 3, y: false };

        // mutating existing variables x &amp; y
        //   x = 3, y = false
    }

    fun example_foo_ref() {
        let foo = Foo { x: 3, y: false };
        let Foo { x, y } = &amp;foo;

        // two new bindings
        //   x: &amp;u64
        //   y: &amp;bool
    }

    fun example_foo_ref_mut() {
        let foo = Foo { x: 3, y: false };
        let Foo { x, y } = &amp;mut foo;

        // two new bindings
        //   x: &amp;mut u64
        //   y: &amp;mut bool
    }

    fun example_destroy_bar() {
        let bar = Bar { foo: Foo { x: 3, y: false } };
        let Bar { foo: Foo { x, y } } = bar;
        //             ^ nested pattern

        // two new bindings
        //   x: u64 = 3
        //   y: bool = false
    }

    fun example_destroy_baz() {
        let baz = Baz {};
        let Baz {} = baz;
    }
}
}
</code></pre>
<h3 id="borrowing-structs-and-fields"><a class="header" href="#borrowing-structs-and-fields">Borrowing Structs and Fields</a></h3>
<p>The <code>&amp;</code> and <code>&amp;mut</code> operator can be used to create references to structs or fields. These examples
include some optional type annotations (e.g., <code>: &amp;Foo</code>) to demonstrate the type of operations.</p>
<pre><code class="language-move">let foo = Foo { x: 3, y: true };
let foo_ref: &amp;Foo = &amp;foo;
let y: bool = foo_ref.y;          // reading a field via a reference to the struct
let x_ref: &amp;u64 = &amp;foo.x;

let x_ref_mut: &amp;mut u64 = &amp;mut foo.x;
*x_ref_mut = 42;            // modifying a field via a mutable reference
</code></pre>
<p>It is possible to borrow inner fields of nested structs:</p>
<pre><code class="language-move">let foo = Foo { x: 3, y: true };
let bar = Bar { foo };

let x_ref = &amp;bar.foo.x;
</code></pre>
<p>You can also borrow a field via a reference to a struct:</p>
<pre><code class="language-move">let foo = Foo { x: 3, y: true };
let foo_ref = &amp;foo;
let x_ref = &amp;foo_ref.x;
// this has the same effect as let x_ref = &amp;foo.x
</code></pre>
<h3 id="reading-and-writing-fields"><a class="header" href="#reading-and-writing-fields">Reading and Writing Fields</a></h3>
<p>If you need to read and copy a field's value, you can then dereference the borrowed field:</p>
<pre><code class="language-move">let foo = Foo { x: 3, y: true };
let bar = Bar { foo: copy foo };
let x: u64 = *&amp;foo.x;
let y: bool = *&amp;foo.y;
let foo2: Foo = *&amp;bar.foo;
</code></pre>
<p>If the field is implicitly copyable, the dot operator can be used to read fields of a struct without
any borrowing. (Only scalar values with the <code>copy</code> ability are implicitly copyable.)</p>
<pre><code class="language-move">let foo = Foo { x: 3, y: true };
let x = foo.x;  // x == 3
let y = foo.y;  // y == true
</code></pre>
<p>Dot operators can be chained to access nested fields:</p>
<pre><code class="language-move">let baz = Baz { foo: Foo { x: 3, y: true } };
let x = baz.foo.x; // x = 3;
</code></pre>
<p>However, this is not permitted for fields that contain non-primitive types, such a vector or another
struct:</p>
<pre><code class="language-move">let foo = Foo { x: 3, y: true };
let bar = Bar { foo };
let foo2: Foo = *&amp;bar.foo;
let foo3: Foo = bar.foo; // error! must add an explicit copy with *&amp;
</code></pre>
<p>The reason behind this design decision is that copying a vector or another struct might be an
expensive operation. It is important for a programmer to be aware of this copy and make others aware
with the explicit syntax <code>*&amp;</code>.</p>
<p>In addition reading from fields, the dot syntax can be used to modify fields, regardless of the
field being a primitive type or some other struct.</p>
<pre><code class="language-move">let foo = Foo { x: 3, y: true };
foo.x = 42;     // foo = Foo { x: 42, y: true }
foo.y = !foo.y; // foo = Foo { x: 42, y: false }
let bar = Bar { foo };            // bar = Bar { foo: Foo { x: 42, y: false } }
bar.foo.x = 52;                   // bar = Bar { foo: Foo { x: 52, y: false } }
bar.foo = Foo { x: 62, y: true }; // bar = Bar { foo: Foo { x: 62, y: true } }
</code></pre>
<p>The dot syntax also works via a reference to a struct:</p>
<pre><code class="language-move">let foo = Foo { x: 3, y: true };
let foo_ref = &amp;mut foo;
foo_ref.x = foo_ref.x + 1;
</code></pre>
<h2 id="privileged-struct-operations"><a class="header" href="#privileged-struct-operations">Privileged Struct Operations</a></h2>
<p>Most struct operations on a struct type <code>T</code> can only be performed inside the module that declares
<code>T</code>:</p>
<ul>
<li>Struct types can only be created (&quot;packed&quot;), destroyed (&quot;unpacked&quot;) inside the module that defines
the struct.</li>
<li>The fields of a struct are only accessible inside the module that defines the struct.</li>
</ul>
<p>Following these rules, if you want to modify your struct outside the module, you will need to
provide public APIs for them. The end of the chapter contains some examples of this.</p>
<p>However, struct <em>types</em> are always visible to another module or script:</p>
<pre><code class="language-move">// m.move
address 0x2 {
module m {
    struct Foo has drop { x: u64 }

    public fun new_foo(): Foo {
        Foo { x: 42 }
    }
}
}
</code></pre>
<pre><code class="language-move">// n.move
address 0x2 {
module n {
    use 0x2::m;

    struct Wrapper has drop {
        foo: m::Foo
    }

    fun f1(foo: m::Foo) {
        let x = foo.x;
        //      ^ error! cannot access fields of `foo` here
    }

    fun f2() {
        let foo_wrapper = Wrapper { foo: m::new_foo() };
    }
}
}
</code></pre>
<p>Note that structs do not have visibility modifiers (e.g., <code>public</code> or <code>private</code>).</p>
<h2 id="ownership-7"><a class="header" href="#ownership-7">Ownership</a></h2>
<p>As mentioned above in <a href="structs-and-resources.html#defining-structs">Defining Structs</a>, structs are by default linear and
ephemeral. This means they cannot be copied or dropped. This property can be very useful when
modeling real world resources like money, as you do not want money to be duplicated or get lost in
circulation.</p>
<pre><code class="language-move">address 0x2 {
module m {
    struct Foo { x: u64 }

    public fun copying_resource() {
        let foo = Foo { x: 100 };
        let foo_copy = copy foo; // error! 'copy'-ing requires the 'copy' ability
        let foo_ref = &amp;foo;
        let another_copy = *foo_ref // error! dereference requires the 'copy' ability
    }

    public fun destroying_resource1() {
        let foo = Foo { x: 100 };

        // error! when the function returns, foo still contains a value.
        // This destruction requires the 'drop' ability
    }

    public fun destroying_resource2(f: &amp;mut Foo) {
        *f = Foo { x: 100 } // error!
                            // destroying the old value via a write requires the 'drop' ability
    }
}
}
</code></pre>
<p>To fix the second example (<code>fun destroying_resource1</code>), you would need to manually &quot;unpack&quot; the
resource:</p>
<pre><code class="language-move">address 0x2 {
module m {
    struct Foo { x: u64 }

    public fun destroying_resource1_fixed() {
        let foo = Foo { x: 100 };
        let Foo { x: _ } = foo;
    }
}
}
</code></pre>
<p>Recall that you are only able to deconstruct a resource within the module in which it is defined.
This can be leveraged to enforce certain invariants in a system, for example, conservation of money.</p>
<p>If on the other hand, your struct does not represent something valuable, you can add the abilities
<code>copy</code> and <code>drop</code> to get a struct value that might feel more familiar from other programming
languages:</p>
<pre><code class="language-move">address 0x2 {
module m {
    struct Foo has copy, drop { x: u64 }

    public fun run() {
        let foo = Foo { x: 100 };
        let foo_copy = copy foo;
        // ^ this code copies foo, whereas `let x = foo` or
        // `let x = move foo` both move foo

        let x = foo.x;            // x = 100
        let x_copy = foo_copy.x;  // x = 100

        // both foo and foo_copy are implicitly discarded when the function returns
    }
}
}
</code></pre>
<h2 id="storing-resources-in-global-storage"><a class="header" href="#storing-resources-in-global-storage">Storing Resources in Global Storage</a></h2>
<p>Only structs with the <code>key</code> ability can be saved directly in
<a href="./global-storage-operators.html">persistent global storage</a>. All values stored within those <code>key</code>
structs must have the <code>store</code> ability. See the <a href="./abilities">ability</a> and
<a href="./global-storage-operators.html">global storage</a> chapters for more detail.</p>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<p>Here are two short examples of how you might use structs to represent valuable data (in the case of
<code>Coin</code>) or more classical data (in the case of <code>Point</code> and <code>Circle</code>).</p>
<h3 id="example-1-coin"><a class="header" href="#example-1-coin">Example 1: Coin</a></h3>
<!-- TODO link to access control for mint -->
<pre><code class="language-move">address 0x2 {
module m {
    // We do not want the Coin to be copied because that would be duplicating this &quot;money&quot;,
    // so we do not give the struct the 'copy' ability.
    // Similarly, we do not want programmers to destroy coins, so we do not give the struct the
    // 'drop' ability.
    // However, we *want* users of the modules to be able to store this coin in persistent global
    // storage, so we grant the struct the 'store' ability. This struct will only be inside of
    // other resources inside of global storage, so we do not give the struct the 'key' ability.
    struct Coin has store {
        value: u64,
    }

    public fun mint(value: u64): Coin {
        // You would want to gate this function with some form of access control to prevent
        // anyone using this module from minting an infinite amount of coins.
        Coin { value }
    }

    public fun withdraw(coin: &amp;mut Coin, amount: u64): Coin {
        assert!(coin.balance &gt;= amount, 1000);
        coin.value = coin.value - amount;
        Coin { value: amount }
    }

    public fun deposit(coin: &amp;mut Coin, other: Coin) {
        let Coin { value } = other;
        coin.value = coin.value + value;
    }

    public fun split(coin: Coin, amount: u64): (Coin, Coin) {
        let other = withdraw(&amp;mut coin, amount);
        (coin, other)
    }

    public fun merge(coin1: Coin, coin2: Coin): Coin {
        deposit(&amp;mut coin1, coin2);
        coin1
    }

    public fun destroy_zero(coin: Coin) {
        let Coin { value } = coin;
        assert!(value == 0, 1001);
    }
}
}
</code></pre>
<h3 id="example-2-geometry"><a class="header" href="#example-2-geometry">Example 2: Geometry</a></h3>
<pre><code class="language-move">address 0x2 {
module point {
    struct Point has copy, drop, store {
        x: u64,
        y: u64,
    }

    public fun new(x: u64, y: u64): Point {
        Point {
            x, y
        }
    }

    public fun x(p: &amp;Point): u64 {
        p.x
    }

    public fun y(p: &amp;Point): u64 {
        p.y
    }

    fun abs_sub(a: u64, b: u64): u64 {
        if (a &lt; b) {
            b - a
        }
        else {
            a - b
        }
    }

    public fun dist_squared(p1: &amp;Point, p2: &amp;Point): u64 {
        let dx = abs_sub(p1.x, p2.x);
        let dy = abs_sub(p1.y, p2.y);
        dx*dx + dy*dy
    }
}
}
</code></pre>
<pre><code class="language-move">address 0x2 {
module circle {
    use 0x2::point::{Self, Point};

    struct Circle has copy, drop, store {
        center: Point,
        radius: u64,
    }

    public fun new(center: Point, radius: u64): Circle {
        Circle { center, radius }
    }

    public fun overlaps(c1: &amp;Circle, c2: &amp;Circle): bool {
        let d = point::dist_squared(&amp;c1.center, &amp;c2.center);
        let r1 = c1.radius;
        let r2 = c2.radius;
        d*d &lt;= r1*r1 + 2*r1*r2 + r2*r2
    }
}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants"><a class="header" href="#constants">Constants</a></h1>
<p>Constants are a way of giving a name to shared, static values inside of a <code>module</code> or <code>script</code>.</p>
<p>The constant's must be known at compilation. The constant's value is stored in the compiled module
or script. And each time the constant is used, a new copy of that value is made.</p>
<h2 id="declaration-1"><a class="header" href="#declaration-1">Declaration</a></h2>
<p>Constant declarations begin with the <code>const</code> keyword, followed by a name, a type, and a value. They
can exist in either a script or module</p>
<pre><code class="language-text">const &lt;name&gt;: &lt;type&gt; = &lt;expression&gt;;
</code></pre>
<p>For example</p>
<pre><code class="language-move=">script {

    const MY_ERROR_CODE: u64 = 0;

    fun main(input: u64) {
        assert!(input &gt; 0, MY_ERROR_CODE);
    }

}

address 0x42 {
module example {

    const MY_ADDRESS: address = @0x42;

    public fun permissioned(s: &amp;signer) {
        assert!(std::signer::address_of(s) == MY_ADDRESS, 0);
    }

}
}
</code></pre>
<h2 id="naming-1"><a class="header" href="#naming-1">Naming</a></h2>
<p>Constants must start with a capital letter <code>A</code> to <code>Z</code>. After the first letter, constant names can
contain underscores <code>_</code>, letters <code>a</code> to <code>z</code>, letters <code>A</code> to <code>Z</code>, or digits <code>0</code> to <code>9</code>.</p>
<pre><code class="language-move">const FLAG: bool = false;
const MY_ERROR_CODE: u64 = 0;
const ADDRESS_42: address = @0x42;
</code></pre>
<p>Even though you can use letters <code>a</code> to <code>z</code> in a constant. The
<a href="./coding-conventions.html">general style guidelines</a> are to use just uppercase letters <code>A</code> to <code>Z</code>,
with underscores <code>_</code> between each word.</p>
<p>This naming restriction of starting with <code>A</code> to <code>Z</code> is in place to give room for future language
features. It may or may not be removed later.</p>
<h2 id="visibility-1"><a class="header" href="#visibility-1">Visibility</a></h2>
<p><code>public</code> constants are not currently supported. <code>const</code> values can be used only in the declaring
module.</p>
<h2 id="valid-expressions"><a class="header" href="#valid-expressions">Valid Expressions</a></h2>
<p>Currently, constants are limited to the primitive types <code>bool</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>u256</code>, <code>address</code>, and
<code>vector&lt;u8&gt;</code>. Future support for other <code>vector</code> values (besides the &quot;string&quot;-style literals) will
come later.</p>
<h3 id="values"><a class="header" href="#values">Values</a></h3>
<p>Commonly, <code>const</code>s are assigned a simple value, or literal, of their type. For example</p>
<pre><code class="language-move">const MY_BOOL: bool = false;
const MY_ADDRESS: address = @0x70DD;
const BYTES: vector&lt;u8&gt; = b&quot;hello world&quot;;
const HEX_BYTES: vector&lt;u8&gt; = x&quot;DEADBEEF&quot;;
</code></pre>
<h3 id="complex-expressions"><a class="header" href="#complex-expressions">Complex Expressions</a></h3>
<p>In addition to literals, constants can include more complex expressions, as long as the compiler is
able to reduce the expression to a value at compile time.</p>
<p>Currently, equality operations, all boolean operations, all bitwise operations, and all arithmetic
operations can be used.</p>
<pre><code class="language-move">const RULE: bool = true &amp;&amp; false;
const CAP: u64 = 10 * 100 + 1;
const SHIFTY: u8 = {
  (1 &lt;&lt; 1) * (1 &lt;&lt; 2) * (1 &lt;&lt; 3) * (1 &lt;&lt; 4)
};
const HALF_MAX: u128 = 340282366920938463463374607431768211455 / 2;
const REM: u256 = 57896044618658097711785492504343953926634992332820282019728792003956564819968 % 654321;
const EQUAL: bool = 1 == 1;
</code></pre>
<p>If the operation would result in a runtime exception, the compiler will give an error that it is
unable to generate the constant's value</p>
<pre><code class="language-move">const DIV_BY_ZERO: u64 = 1 / 0; // error!
const SHIFT_BY_A_LOT: u64 = 1 &lt;&lt; 100; // error!
const NEGATIVE_U64: u64 = 0 - 1; // error!
</code></pre>
<p>Note that constants cannot currently refer to other constants. This feature, along with support for
other expressions, will be added in the future.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<p>Generics can be used to define functions and structs over different input data types. This language feature is sometimes referred to as <em>parametric polymorphism</em>. In Move, we will often use the term generics interchangeably with type parameters and type arguments.</p>
<p>Generics are commonly used in library code, such as in vector, to declare code that works over any possible instantiation (that satisfies the specified constraints). In other frameworks, generic code can sometimes be used to interact with global storage many different ways that all still share the same implementation.</p>
<h2 id="declaring-type-parameters"><a class="header" href="#declaring-type-parameters">Declaring Type Parameters</a></h2>
<p>Both functions and structs can take a list of type parameters in their signatures, enclosed by a pair of angle brackets <code>&lt;...&gt;</code>.</p>
<h3 id="generic-functions"><a class="header" href="#generic-functions">Generic Functions</a></h3>
<p>Type parameters for functions are placed after the function name and before the (value) parameter list. The following code defines a generic identity function that takes a value of any type and returns that value unchanged.</p>
<pre><code class="language-move">fun id&lt;T&gt;(x: T): T {
    // this type annotation is unnecessary but valid
    (x: T)
}
</code></pre>
<p>Once defined, the type parameter <code>T</code> can be used in parameter types, return types, and inside the function body.</p>
<h3 id="generic-structs"><a class="header" href="#generic-structs">Generic Structs</a></h3>
<p>Type parameters for structs are placed after the struct name, and can be used to name the types of the fields.</p>
<pre><code class="language-move">struct Foo&lt;T&gt; has copy, drop { x: T }

struct Bar&lt;T1, T2&gt; has copy, drop {
    x: T1,
    y: vector&lt;T2&gt;,
}
</code></pre>
<p>Note that <a href="generics.html#unused-type-parameters">type parameters do not have to be used</a></p>
<h2 id="type-arguments"><a class="header" href="#type-arguments">Type Arguments</a></h2>
<h3 id="calling-generic-functions"><a class="header" href="#calling-generic-functions">Calling Generic Functions</a></h3>
<p>When calling a generic function, one can specify the type arguments for the function's type parameters in a list enclosed by a pair of angle brackets.</p>
<pre><code class="language-move">fun foo() {
    let x = id&lt;bool&gt;(true);
}
</code></pre>
<p>If you do not specify the type arguments, Move's <a href="generics.html#type-inference">type inference</a> will supply them for you.</p>
<h3 id="using-generic-structs"><a class="header" href="#using-generic-structs">Using Generic Structs</a></h3>
<p>Similarly, one can attach a list of type arguments for the struct's type parameters when constructing or destructing values of generic types.</p>
<pre><code class="language-move">fun foo() {
    let foo = Foo&lt;bool&gt; { x: true };
    let Foo&lt;bool&gt; { x } = foo;
}
</code></pre>
<p>If you do not specify the type arguments, Move's <a href="generics.html#type-inference">type inference</a> will supply them for you.</p>
<h3 id="type-argument-mismatch"><a class="header" href="#type-argument-mismatch">Type Argument Mismatch</a></h3>
<p>If you specify the type arguments and they conflict with the actual values supplied, an error will be given:</p>
<pre><code class="language-move">fun foo() {
    let x = id&lt;u64&gt;(true); // error! true is not a u64
}
</code></pre>
<p>and similarly:</p>
<pre><code class="language-move">fun foo() {
    let foo = Foo&lt;bool&gt; { x: 0 }; // error! 0 is not a bool
    let Foo&lt;address&gt; { x } = foo; // error! bool is incompatible with address
}
</code></pre>
<h2 id="type-inference"><a class="header" href="#type-inference">Type Inference</a></h2>
<p>In most cases, the Move compiler will be able to infer the type arguments so you don't have to write them down explicitly. Here's what the examples above would look like if we omit the type arguments:</p>
<pre><code class="language-move">fun foo() {
    let x = id(true);
    //        ^ &lt;bool&gt; is inferred

    let foo = Foo { x: true };
    //           ^ &lt;bool&gt; is inferred

    let Foo { x } = foo;
    //     ^ &lt;bool&gt; is inferred
}
</code></pre>
<p>Note: when the compiler is unable to infer the types, you'll need annotate them manually. A common scenario is to call a function with type parameters appearing only at return positions.</p>
<pre><code class="language-move">address 0x2 {
module m {
    using std::vector;

    fun foo() {
        // let v = vector::new();
        //                    ^ The compiler cannot figure out the element type.

        let v = vector::new&lt;u64&gt;();
        //                 ^~~~~ Must annotate manually.
    }
}
}
</code></pre>
<p>However, the compiler will be able to infer the type if that return value is used later in that function:</p>
<pre><code class="language-move">address 0x2 {
module m {
    using std::vector;

    fun foo() {
        let v = vector::new();
        //                 ^ &lt;u64&gt; is inferred
        vector::push_back(&amp;mut v, 42);
    }
}
}
</code></pre>
<h2 id="unused-type-parameters"><a class="header" href="#unused-type-parameters">Unused Type Parameters</a></h2>
<p>For a struct definition,
an unused type parameter is one that
does not appear in any field defined in the struct,
but is checked statically at compile time.
Move allows unused type parameters so the following struct definition is valid:</p>
<pre><code class="language-move">struct Foo&lt;T&gt; {
    foo: u64
}
</code></pre>
<p>This can be convenient when modeling certain concepts. Here is an example:</p>
<pre><code class="language-move">address 0x2 {
module m {
    // Currency Specifiers
    struct Currency1 {}
    struct Currency2 {}

    // A generic coin type that can be instantiated using a currency
    // specifier type.
    //   e.g. Coin&lt;Currency1&gt;, Coin&lt;Currency2&gt; etc.
    struct Coin&lt;Currency&gt; has store {
        value: u64
    }

    // Write code generically about all currencies
    public fun mint_generic&lt;Currency&gt;(value: u64): Coin&lt;Currency&gt; {
        Coin { value }
    }

    // Write code concretely about one currency
    public fun mint_concrete(value: u64): Coin&lt;Currency1&gt; {
        Coin { value }
    }
}
}
</code></pre>
<p>In this example,
<code>struct Coin&lt;Currency&gt;</code> is generic on the <code>Currency</code> type parameter,
which specifies the currency of the coin and
allows code to be written either
generically on any currency or
concretely on a specific currency.
This genericity applies even when the <code>Currency</code> type parameter
does not appear in any of the fields defined in <code>Coin</code>.</p>
<h3 id="phantom-type-parameters"><a class="header" href="#phantom-type-parameters">Phantom Type Parameters</a></h3>
<p>In the example above,
although <code>struct Coin</code> asks for the <code>store</code> ability,
neither <code>Coin&lt;Currency1&gt;</code> nor <code>Coin&lt;Currency2&gt;</code> will have the <code>store</code> ability.
This is because of the rules for
<a href="./abilities.html#conditional-abilities-and-generic-types">Conditional Abilities and Generic Types</a>
and the fact that <code>Currency1</code> and <code>Currency2</code> don't have the <code>store</code> ability,
despite the fact that they are not even used in the body of <code>struct Coin</code>.
This might cause some unpleasant consequences.
For example, we are unable to put <code>Coin&lt;Currency1&gt;</code> into a wallet in the global storage.</p>
<p>One possible solution would be to
add spurious ability annotations to <code>Currency1</code> and <code>Currency2</code>
(i.e., <code>struct Currency1 has store {}</code>).
But, this might lead to bugs or security vulnerabilities
because it weakens the types with unnecessary ability declarations.
For example, we would never expect a resource in the global storage to have a field in type <code>Currency1</code>,
but this would be possible with the spurious <code>store</code> ability.
Moreover, the spurious annotations would be infectious,
requiring many functions generic on the unused type parameter to also include the necessary constraints.</p>
<p>Phantom type parameters solve this problem.
Unused type parameters can be marked as <em>phantom</em> type parameters,
which do not participate in the ability derivation for structs.
In this way,
arguments to phantom type parameters are not considered when deriving the abilities for generic types,
thus avoiding the need for spurious ability annotations.
For this relaxed rule to be sound,
Move's type system guarantees that a parameter declared as <code>phantom</code> is either
not used at all in the struct definition, or
it is only used as an argument to type parameters also declared as <code>phantom</code>.</p>
<h4 id="declaration-2"><a class="header" href="#declaration-2">Declaration</a></h4>
<p>In a struct definition
a type parameter can be declared as phantom by adding the <code>phantom</code> keyword before its declaration.
If a type parameter is declared as phantom we say it is a phantom type parameter.
When defining a struct, Move's type checker ensures that every phantom type parameter is either
not used inside the struct definition or
it is only used as an argument to a phantom type parameter.</p>
<p>More formally,
if a type is used as an argument to a phantom type parameter
we say the type appears in <em>phantom position</em>.
With this definition in place,
the rule for the correct use of phantom parameters can be specified as follows:
<strong>A phantom type parameter can only appear in phantom position</strong>.</p>
<p>The following two examples show valid uses of phantom parameters.
In the first one,
the parameter <code>T1</code> is not used at all inside the struct definition.
In the second one, the parameter <code>T1</code> is only used as an argument to a phantom type parameter.</p>
<pre><code class="language-move">struct S1&lt;phantom T1, T2&gt; { f: u64 }
                  ^^
                  Ok: T1 does not appear inside the struct definition


struct S2&lt;phantom T1, T2&gt; { f: S1&lt;T1, T2&gt; }
                                  ^^
                                  Ok: T1 appears in phantom position
</code></pre>
<p>The following code shows examples of violations of the rule:</p>
<pre><code class="language-move">struct S1&lt;phantom T&gt; { f: T }
                          ^
                          Error: Not a phantom position

struct S2&lt;T&gt; { f: T }

struct S3&lt;phantom T&gt; { f: S2&lt;T&gt; }
                             ^
                             Error: Not a phantom position
</code></pre>
<h4 id="instantiation"><a class="header" href="#instantiation">Instantiation</a></h4>
<p>When instantiating a struct,
the arguments to phantom parameters are excluded when deriving the struct abilities.
For example, consider the following code:</p>
<pre><code class="language-move">struct S&lt;T1, phantom T2&gt; has copy { f: T1 }
struct NoCopy {}
struct HasCopy has copy {}
</code></pre>
<p>Consider now the type <code>S&lt;HasCopy, NoCopy&gt;</code>.
Since <code>S</code> is defined with <code>copy</code> and all non-phantom arguments have <code>copy</code>
then <code>S&lt;HasCopy, NoCopy&gt;</code> also has <code>copy</code>.</p>
<h4 id="phantom-type-parameters-with-ability-constraints"><a class="header" href="#phantom-type-parameters-with-ability-constraints">Phantom Type Parameters with Ability Constraints</a></h4>
<p>Ability constraints and phantom type parameters are orthogonal features in the sense that
phantom parameters can be declared with ability constraints.
When instantiating a phantom type parameter with an ability constraint,
the type argument has to satisfy that constraint,
even though the parameter is phantom.
For example, the following definition is perfectly valid:</p>
<pre><code class="language-move">struct S&lt;phantom T: copy&gt; {}
</code></pre>
<p>The usual restrictions apply and <code>T</code> can only be instantiated with arguments having <code>copy</code>.</p>
<h2 id="constraints"><a class="header" href="#constraints">Constraints</a></h2>
<p>In the examples above, we have demonstrated how one can use type parameters to define &quot;unknown&quot; types that can be plugged in by callers at a later time. This however means the type system has little information about the type and has to perform checks in a very conservative way. In some sense, the type system must assume the worst case scenario for an unconstrained generic. Simply put, by default generic type parameters have no <a href="./abilities.html">abilities</a>.</p>
<p>This is where constraints come into play: they offer a way to specify what properties these unknown types have so the type system can allow operations that would otherwise be unsafe.</p>
<h3 id="declaring-constraints"><a class="header" href="#declaring-constraints">Declaring Constraints</a></h3>
<p>Constraints can be imposed on type parameters using the following syntax.</p>
<pre><code class="language-move">// T is the name of the type parameter
T: &lt;ability&gt; (+ &lt;ability&gt;)*
</code></pre>
<p>The <code>&lt;ability&gt;</code> can be any of the four <a href="./abilities.html">abilities</a>, and a type parameter can be constrained with multiple abilities at once. So all of the following would be valid type parameter declarations:</p>
<pre><code class="language-move">T: copy
T: copy + drop
T: copy + drop + store + key
</code></pre>
<h3 id="verifying-constraints"><a class="header" href="#verifying-constraints">Verifying Constraints</a></h3>
<p>Constraints are checked at call sites so the following code won't compile.</p>
<pre><code class="language-move">struct Foo&lt;T: key&gt; { x: T }

struct Bar { x: Foo&lt;u8&gt; }
//                  ^ error! u8 does not have 'key'

struct Baz&lt;T&gt; { x: Foo&lt;T&gt; }
//                     ^ error! T does not have 'key'
</code></pre>
<pre><code class="language-move">struct R {}

fun unsafe_consume&lt;T&gt;(x: T) {
    // error! x does not have 'drop'
}

fun consume&lt;T: drop&gt;(x: T) {
    // valid!
    // x will be dropped automatically
}

fun foo() {
    let r = R {};
    consume&lt;R&gt;(r);
    //      ^ error! R does not have 'drop'
}
</code></pre>
<pre><code class="language-move">struct R {}

fun unsafe_double&lt;T&gt;(x: T) {
    (copy x, x)
    // error! x does not have 'copy'
}

fun double&lt;T: copy&gt;(x: T) {
    (copy x, x) // valid!
}

fun foo(): (R, R) {
    let r = R {};
    double&lt;R&gt;(r)
    //     ^ error! R does not have 'copy'
}
</code></pre>
<p>For more information, see the abilities section on <a href="./abilities.html#conditional-abilities-and-generic-types">conditional abilities and generic types</a>.</p>
<h2 id="limitations-on-recursions"><a class="header" href="#limitations-on-recursions">Limitations on Recursions</a></h2>
<h3 id="recursive-structs"><a class="header" href="#recursive-structs">Recursive Structs</a></h3>
<p>Generic structs can not contain fields of the same type, either directly or indirectly, even with different type arguments. All of the following struct definitions are invalid:</p>
<pre><code class="language-move">struct Foo&lt;T&gt; {
    x: Foo&lt;u64&gt; // error! 'Foo' containing 'Foo'
}

struct Bar&lt;T&gt; {
    x: Bar&lt;T&gt; // error! 'Bar' containing 'Bar'
}

// error! 'A' and 'B' forming a cycle, which is not allowed either.
struct A&lt;T&gt; {
    x: B&lt;T, u64&gt;
}

struct B&lt;T1, T2&gt; {
    x: A&lt;T1&gt;
    y: A&lt;T2&gt;
}
</code></pre>
<h3 id="advanced-topic-type-level-recursions"><a class="header" href="#advanced-topic-type-level-recursions">Advanced Topic: Type-level Recursions</a></h3>
<p>Move allows generic functions to be called recursively. However, when used in combination with generic structs, this could create an infinite number of types in certain cases, and allowing this means adding unnecessary complexity to the compiler, vm and other language components. Therefore, such recursions are forbidden.</p>
<p>Allowed:</p>
<pre><code class="language-move">address 0x2 {
module m {
    struct A&lt;T&gt; {}

    // Finitely many types -- allowed.
    // foo&lt;T&gt; -&gt; foo&lt;T&gt; -&gt; foo&lt;T&gt; -&gt; ... is valid
    fun foo&lt;T&gt;() {
        foo&lt;T&gt;();
    }

    // Finitely many types -- allowed.
    // foo&lt;T&gt; -&gt; foo&lt;A&lt;u64&gt;&gt; -&gt; foo&lt;A&lt;u64&gt;&gt; -&gt; ... is valid
    fun foo&lt;T&gt;() {
        foo&lt;A&lt;u64&gt;&gt;();
    }
}
}
</code></pre>
<p>Not allowed:</p>
<pre><code class="language-move">address 0x2 {
module m {
    struct A&lt;T&gt; {}

    // Infinitely many types -- NOT allowed.
    // error!
    // foo&lt;T&gt; -&gt; foo&lt;A&lt;T&gt;&gt; -&gt; foo&lt;A&lt;A&lt;T&gt;&gt;&gt; -&gt; ...
    fun foo&lt;T&gt;() {
        foo&lt;Foo&lt;T&gt;&gt;();
    }
}
}
</code></pre>
<pre><code class="language-move">address 0x2 {
module n {
    struct A&lt;T&gt; {}

    // Infinitely many types -- NOT allowed.
    // error!
    // foo&lt;T1, T2&gt; -&gt; bar&lt;T2, T1&gt; -&gt; foo&lt;T2, A&lt;T1&gt;&gt;
    //   -&gt; bar&lt;A&lt;T1&gt;, T2&gt; -&gt; foo&lt;A&lt;T1&gt;, A&lt;T2&gt;&gt;
    //   -&gt; bar&lt;A&lt;T2&gt;, A&lt;T1&gt;&gt; -&gt; foo&lt;A&lt;T2&gt;, A&lt;A&lt;T1&gt;&gt;&gt;
    //   -&gt; ...
    fun foo&lt;T1, T2&gt;() {
        bar&lt;T2, T1&gt;();
    }

    fun bar&lt;T1, T2&gt; {
        foo&lt;T1, A&lt;T2&gt;&gt;();
    }
}
}
</code></pre>
<p>Note, the check for type level recursions is based on a conservative analysis on the call sites and does NOT take control flow or runtime values into account.</p>
<pre><code class="language-move">address 0x2 {
module m {
    struct A&lt;T&gt; {}

    fun foo&lt;T&gt;(n: u64) {
        if (n &gt; 0) {
            foo&lt;A&lt;T&gt;&gt;(n - 1);
        };
    }
}
}
</code></pre>
<p>The function in the example above will technically terminate for any given input and therefore only creating finitely many types, but it is still considered invalid by Move's type system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abilities"><a class="header" href="#abilities">Abilities</a></h1>
<p>Abilities are a typing feature in Move that control what actions are permissible for values of a given type. This system grants fine grained control over the &quot;linear&quot; typing behavior of values, as well as if and how values are used in global storage. This is implemented by gating access to certain bytecode instructions so that for a value to be used with the bytecode instruction, it must have the ability required (if one is required at all—not every instruction is gated by an ability).</p>
<!-- TODO future section on detailed walk through maybe. We have some examples at the end but it might be helpful to explain why we have precisely this set of abilities

If you are already somewhat familiar with abilities from writing Move programs, but are still confused as to what is going on, it might be helpful to skip to the [motivating walkthrough](#motivating-walkthrough) section to get an idea of what the system is setup in the way that it is. -->
<h2 id="the-four-abilities"><a class="header" href="#the-four-abilities">The Four Abilities</a></h2>
<p>The four abilities are:</p>
<ul>
<li><a href="abilities.html#copy"><code>copy</code></a>
<ul>
<li>Allows values of types with this ability to be copied.</li>
</ul>
</li>
<li><a href="abilities.html#drop"><code>drop</code></a>
<ul>
<li>Allows values of types with this ability to be popped/dropped.</li>
</ul>
</li>
<li><a href="abilities.html#store"><code>store</code></a>
<ul>
<li>Allows values of types with this ability to exist inside a struct in global storage.</li>
</ul>
</li>
<li><a href="abilities.html#key"><code>key</code></a>
<ul>
<li>Allows the type to serve as a key for global storage operations.</li>
</ul>
</li>
</ul>
<h3 id="copy"><a class="header" href="#copy"><code>copy</code></a></h3>
<p>The <code>copy</code> ability allows values of types with that ability to be copied. It gates the ability to copy values out of local variables with the <a href="./variables.html#move-and-copy"><code>copy</code></a> operator and to copy values via references with <a href="./references.html#reading-and-writing-through-references">dereference <code>*e</code></a>.</p>
<p>If a value has <code>copy</code>, all values contained inside of that value have <code>copy</code>.</p>
<h3 id="drop"><a class="header" href="#drop"><code>drop</code></a></h3>
<p>The <code>drop</code> ability allows values of types with that ability to be dropped. By dropped, we mean that value is not transferred and is effectively destroyed as the Move program executes. As such, this ability gates the ability to ignore values in a multitude of locations, including:</p>
<ul>
<li>not using the value in a local variable or parameter</li>
<li>not using the value in a <a href="./variables.html#expression-blocks">sequence via <code>;</code></a></li>
<li>overwriting values in variables in <a href="./variables.html#assignments">assignments</a></li>
<li>overwriting values via references when <a href="./references.html#reading-and-writing-through-references">writing <code>*e1 = e2</code></a>.</li>
</ul>
<p>If a value has <code>drop</code>, all values contained inside of that value have <code>drop</code>.</p>
<h3 id="store"><a class="header" href="#store"><code>store</code></a></h3>
<p>The <code>store</code> ability allows values of types with this ability to exist inside of a struct (resource) in global storage, <em>but</em> not necessarily as a top-level resource in global storage. This is the only ability that does not directly gate an operation. Instead it gates the existence in global storage when used in tandem with <code>key</code>.</p>
<p>If a value has <code>store</code>, all values contained inside of that value have <code>store</code></p>
<h3 id="key"><a class="header" href="#key"><code>key</code></a></h3>
<p>The <code>key</code> ability allows the type to serve as a key for <a href="./global-storage-operators.html">global storage operations</a>. It gates all global storage operations, so in order for a type to be used with <code>move_to</code>, <code>borrow_global</code>, <code>move_from</code>, etc., the type must have the <code>key</code> ability. Note that the operations still must be used in the module where the <code>key</code> type is defined (in a sense, the operations are private to the defining module).</p>
<p>If a value has <code>key</code>, all values contained inside of that value have <code>store</code>. This is the only ability with this sort of asymmetry.</p>
<h2 id="builtin-types"><a class="header" href="#builtin-types">Builtin Types</a></h2>
<p>Most primitive, builtin types have <code>copy</code>, <code>drop</code>, and <code>store</code> with the exception of <code>signer</code>, which just has <code>drop</code></p>
<ul>
<li><code>bool</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>u256</code>, and <code>address</code> all have <code>copy</code>, <code>drop</code>, and <code>store</code>.</li>
<li><code>signer</code> has <code>drop</code>
<ul>
<li>Cannot be copied and cannot be put into global storage</li>
</ul>
</li>
<li><code>vector&lt;T&gt;</code> may have <code>copy</code>, <code>drop</code>, and <code>store</code> depending on the abilities of <code>T</code>.
<ul>
<li>See <a href="abilities.html#conditional-abilities-and-generic-types">Conditional Abilities and Generic Types</a> for more details.</li>
</ul>
</li>
<li>Immutable references <code>&amp;</code> and mutable references <code>&amp;mut</code> both have <code>copy</code> and <code>drop</code>.
<ul>
<li>This refers to copying and dropping the reference itself, not what they refer to.</li>
<li>References cannot appear in global storage, hence they do not have <code>store</code>.</li>
</ul>
</li>
</ul>
<p>None of the primitive types have <code>key</code>, meaning none of them can be used directly with the <a href="./global-storage-operators.html">global storage operations</a>.</p>
<h2 id="annotating-structs"><a class="header" href="#annotating-structs">Annotating Structs</a></h2>
<p>To declare that a <code>struct</code> has an ability, it is declared with <code>has &lt;ability&gt;</code> after the struct name but before the fields. For example:</p>
<pre><code class="language-move">struct Ignorable has drop { f: u64 }
struct Pair has copy, drop, store { x: u64, y: u64 }
</code></pre>
<p>In this case: <code>Ignorable</code> has the <code>drop</code> ability. <code>Pair</code> has <code>copy</code>, <code>drop</code>, and <code>store</code>.</p>
<p>All of these abilities have strong guarantees over these gated operations. The operation can be performed on the value only if it has that ability; even if the value is deeply nested inside of some other collection!</p>
<p>As such: when declaring a struct’s abilities, certain requirements are placed on the fields. All fields must satisfy these constraints. These rules are necessary so that structs satisfy the reachability rules for the abilities given above. If a struct is declared with the ability...</p>
<ul>
<li><code>copy</code>, all fields must have <code>copy</code>.</li>
<li><code>drop</code>, all fields must have <code>drop</code>.</li>
<li><code>store</code>, all fields must have <code>store</code>.</li>
<li><code>key</code>, all fields must have <code>store</code>.
<ul>
<li><code>key</code> is the only ability currently that doesn’t require itself.</li>
</ul>
</li>
</ul>
<p>For example:</p>
<pre><code class="language-move">// A struct without any abilities
struct NoAbilities {}

struct WantsCopy has copy {
    f: NoAbilities, // ERROR 'NoAbilities' does not have 'copy'
}
</code></pre>
<p>and similarly:</p>
<pre><code class="language-move">// A struct without any abilities
struct NoAbilities {}

struct MyResource has key {
    f: NoAbilities, // Error 'NoAbilities' does not have 'store'
}
</code></pre>
<h2 id="conditional-abilities-and-generic-types"><a class="header" href="#conditional-abilities-and-generic-types">Conditional Abilities and Generic Types</a></h2>
<p>When abilities are annotated on a generic type, not all instances of that type are guaranteed to have that ability. Consider this struct declaration:</p>
<pre><code>struct Cup&lt;T&gt; has copy, drop, store, key { item: T }
</code></pre>
<p>It might be very helpful if <code>Cup</code> could hold any type, regardless of its abilities. The type system can <em>see</em> the type parameter, so it should be able to remove abilities from <code>Cup</code> if it <em>sees</em> a type parameter that would violate the guarantees for that ability.</p>
<p>This behavior might sound a bit confusing at first, but it might be more understandable if we think about collection types. We could consider the builtin type <code>vector</code> to have the following type declaration:</p>
<pre><code>vector&lt;T&gt; has copy, drop, store;
</code></pre>
<p>We want <code>vector</code>s to work with any type. We don't want separate <code>vector</code> types for different abilities. So what are the rules we would want? Precisely the same that we would want with the field rules above.  So, it would be safe to copy a <code>vector</code> value only if the inner elements can be copied. It would be safe to ignore a <code>vector</code> value only if the inner elements can be ignored/dropped. And, it would be safe to put a <code>vector</code> in global storage only if the inner elements can be in global storage.</p>
<p>To have this extra expressiveness, a type might not have all the abilities it was declared with depending on the instantiation of that type; instead, the abilities a type will have depends on both its declaration <strong>and</strong> its type arguments. For any type, type parameters are pessimistically assumed to be used inside of the struct, so the abilities are only granted if the type parameters meet the requirements described above for fields. Taking <code>Cup</code> from above as an example:</p>
<ul>
<li><code>Cup</code> has the ability <code>copy</code> only if <code>T</code> has <code>copy</code>.</li>
<li>It has <code>drop</code> only if <code>T</code> has <code>drop</code>.</li>
<li>It has <code>store</code> only if <code>T</code> has <code>store</code>.</li>
<li>It has <code>key</code> only if <code>T</code> has <code>store</code>.</li>
</ul>
<p>Here are examples for this conditional system for each ability:</p>
<h3 id="example-conditional-copy"><a class="header" href="#example-conditional-copy">Example: conditional <code>copy</code></a></h3>
<pre><code>struct NoAbilities {}
struct S has copy, drop { f: bool }
struct Cup&lt;T&gt; has copy, drop, store { item: T }

fun example(c_x: Cup&lt;u64&gt;, c_s: Cup&lt;S&gt;) {
    // Valid, 'Cup&lt;u64&gt;' has 'copy' because 'u64' has 'copy'
    let c_x2 = copy c_x;
    // Valid, 'Cup&lt;S&gt;' has 'copy' because 'S' has 'copy'
    let c_s2 = copy c_s;
}

fun invalid(c_account: Cup&lt;signer&gt;, c_n: Cup&lt;NoAbilities&gt;) {
    // Invalid, 'Cup&lt;signer&gt;' does not have 'copy'.
    // Even though 'Cup' was declared with copy, the instance does not have 'copy'
    // because 'signer' does not have 'copy'
    let c_account2 = copy c_account;
    // Invalid, 'Cup&lt;NoAbilities&gt;' does not have 'copy'
    // because 'NoAbilities' does not have 'copy'
    let c_n2 = copy c_n;
}
</code></pre>
<h3 id="example-conditional-drop"><a class="header" href="#example-conditional-drop">Example: conditional <code>drop</code></a></h3>
<pre><code>struct NoAbilities {}
struct S has copy, drop { f: bool }
struct Cup&lt;T&gt; has copy, drop, store { item: T }

fun unused() {
    Cup&lt;bool&gt; { item: true }; // Valid, 'Cup&lt;bool&gt;' has 'drop'
    Cup&lt;S&gt; { item: S { f: false }}; // Valid, 'Cup&lt;S&gt;' has 'drop'
}

fun left_in_local(c_account: Cup&lt;signer&gt;): u64 {
    let c_b = Cup&lt;bool&gt; { item: true };
    let c_s = Cup&lt;S&gt; { item: S { f: false }};
    // Valid return: 'c_account', 'c_b', and 'c_s' have values
    // but 'Cup&lt;signer&gt;', 'Cup&lt;bool&gt;', and 'Cup&lt;S&gt;' have 'drop'
    0
}

fun invalid_unused() {
    // Invalid, Cannot ignore 'Cup&lt;NoAbilities&gt;' because it does not have 'drop'.
    // Even though 'Cup' was declared with 'drop', the instance does not have 'drop'
    // because 'NoAbilities' does not have 'drop'
    Cup&lt;NoAbilities&gt; { item: NoAbilities {}};
}

fun invalid_left_in_local(): u64 {
    let n = Cup&lt;NoAbilities&gt; { item: NoAbilities {}};
    // Invalid return: 'c_n' has a value
    // and 'Cup&lt;NoAbilities&gt;' does not have 'drop'
    0
}
</code></pre>
<h3 id="example-conditional-store"><a class="header" href="#example-conditional-store">Example: conditional <code>store</code></a></h3>
<pre><code>struct Cup&lt;T&gt; has copy, drop, store { item: T }

// 'MyInnerResource' is declared with 'store' so all fields need 'store'
struct MyInnerResource has store {
    yes: Cup&lt;u64&gt;, // Valid, 'Cup&lt;u64&gt;' has 'store'
    // no: Cup&lt;signer&gt;, Invalid, 'Cup&lt;signer&gt;' does not have 'store'
}

// 'MyResource' is declared with 'key' so all fields need 'store'
struct MyResource has key {
    yes: Cup&lt;u64&gt;, // Valid, 'Cup&lt;u64&gt;' has 'store'
    inner: Cup&lt;MyInnerResource&gt;, // Valid, 'Cup&lt;MyInnerResource&gt;' has 'store'
    // no: Cup&lt;signer&gt;, Invalid, 'Cup&lt;signer&gt;' does not have 'store'
}
</code></pre>
<h3 id="example-conditional-key"><a class="header" href="#example-conditional-key">Example: conditional <code>key</code></a></h3>
<pre><code>struct NoAbilities {}
struct MyResource&lt;T&gt; has key { f: T }

fun valid(account: &amp;signer) acquires MyResource {
    let addr = signer::address_of(account);
     // Valid, 'MyResource&lt;u64&gt;' has 'key'
    let has_resource = exists&lt;MyResource&lt;u64&gt;&gt;(addr);
    if (!has_resource) {
         // Valid, 'MyResource&lt;u64&gt;' has 'key'
        move_to(account, MyResource&lt;u64&gt; { f: 0 })
    };
    // Valid, 'MyResource&lt;u64&gt;' has 'key'
    let r = borrow_global_mut&lt;MyResource&lt;u64&gt;&gt;(addr)
    r.f = r.f + 1;
}

fun invalid(account: &amp;signer) {
   // Invalid, 'MyResource&lt;NoAbilities&gt;' does not have 'key'
   let has_it = exists&lt;MyResource&lt;NoAbilities&gt;&gt;(addr);
   // Invalid, 'MyResource&lt;NoAbilities&gt;' does not have 'key'
   let NoAbilities {} = move_from&lt;NoAbilities&gt;(addr);
   // Invalid, 'MyResource&lt;NoAbilities&gt;' does not have 'key'
   move_to(account, NoAbilities {});
   // Invalid, 'MyResource&lt;NoAbilities&gt;' does not have 'key'
   borrow_global&lt;NoAbilities&gt;(addr);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uses-and-aliases"><a class="header" href="#uses-and-aliases">Uses and Aliases</a></h1>
<p>The <code>use</code> syntax can be used to create aliases to members in other modules. <code>use</code> can be used to
create aliases that last either for the entire module, or for a given expression block scope.</p>
<h2 id="syntax-1"><a class="header" href="#syntax-1">Syntax</a></h2>
<p>There are several different syntax cases for <code>use</code>. Starting with the most simple, we have the
following for creating aliases to other modules</p>
<pre><code class="language-move">use &lt;address&gt;::&lt;module name&gt;;
use &lt;address&gt;::&lt;module name&gt; as &lt;module alias name&gt;;
</code></pre>
<p>For example</p>
<pre><code class="language-move">use std::vector;
use std::vector as V;
</code></pre>
<p><code>use std::vector;</code> introduces an alias <code>vector</code> for <code>std::vector</code>. This means that anywhere you
would want to use the module name <code>std::vector</code> (assuming this <code>use</code> is in scope), you could use
<code>vector</code> instead. <code>use std::vector;</code> is equivalent to <code>use std::vector as vector;</code></p>
<p>Similarly <code>use std::vector as V;</code> would let you use <code>V</code> instead of <code>std::vector</code></p>
<pre><code class="language-move=">use std::vector;
use std::vector as V;

fun new_vecs(): (vector&lt;u8&gt;, vector&lt;u8&gt;, vector&lt;u8&gt;) {
    let v1 = std::vector::empty();
    let v2 = vector::empty();
    let v3 = V::empty();
    (v1, v2, v3)
}
</code></pre>
<p>If you want to import a specific module member (such as a function, struct, or constant). You can
use the following syntax.</p>
<pre><code class="language-move">use &lt;address&gt;::&lt;module name&gt;::&lt;module member&gt;;
use &lt;address&gt;::&lt;module name&gt;::&lt;module member&gt; as &lt;member alias&gt;;
</code></pre>
<p>For example</p>
<pre><code class="language-move">use std::vector::empty;
use std::vector::empty as empty_vec;
</code></pre>
<p>This would let you use the function <code>std::vector::empty</code> without full qualification. Instead you
could use <code>empty</code> and <code>empty_vec</code> respectively. Again, <code>use std::vector::empty;</code> is equivalent to
<code>use std::vector::empty as empty;</code></p>
<pre><code class="language-move=">use std::vector::empty;
use std::vector::empty as empty_vec;

fun new_vecs(): (vector&lt;u8&gt;, vector&lt;u8&gt;, vector&lt;u8&gt;) {
    let v1 = std::vector::empty();
    let v2 = empty();
    let v3 = empty_vec();
    (v1, v2, v3)
}
</code></pre>
<p>If you want to add aliases for multiple module members at once, you can do so with the following
syntax</p>
<pre><code class="language-move">use &lt;address&gt;::&lt;module name&gt;::{&lt;module member&gt;, &lt;module member&gt; as &lt;member alias&gt; ... };
</code></pre>
<p>For example</p>
<pre><code class="language-move=">use std::vector::{push_back, length as len, pop_back};

fun swap_last_two&lt;T&gt;(v: &amp;mut vector&lt;T&gt;) {
    assert!(len(v) &gt;= 2, 42);
    let last = pop_back(v);
    let second_to_last = pop_back(v);
    push_back(v, last);
    push_back(v, second_to_last)
}
</code></pre>
<p>If you need to add an alias to the Module itself in addition to module members, you can do that in a
single <code>use</code> using <code>Self</code>. <code>Self</code> is a member of sorts that refers to the module.</p>
<pre><code class="language-move">use std::vector::{Self, empty};
</code></pre>
<p>For clarity, all of the following are equivalent:</p>
<pre><code class="language-move">use std::vector;
use std::vector as vector;
use std::vector::Self;
use std::vector::Self as vector;
use std::vector::{Self};
use std::vector::{Self as vector};
</code></pre>
<p>If needed, you can have as many aliases for any item as you like</p>
<pre><code class="language-move=">use std::vector::{
    Self,
    Self as V,
    length,
    length as len,
};

fun pop_twice&lt;T&gt;(v: &amp;mut vector&lt;T&gt;): (T, T) {
    // all options available given the `use` above
    assert!(vector::length(v) &gt; 1, 42);
    assert!(V::length(v) &gt; 1, 42);
    assert!(length(v) &gt; 1, 42);
    assert!(len(v) &gt; 1, 42);

    (vector::pop_back(v), vector::pop_back(v))
}
</code></pre>
<h2 id="inside-a-module"><a class="header" href="#inside-a-module">Inside a <code>module</code></a></h2>
<p>Inside of a <code>module</code> all <code>use</code> declarations are usable regardless of the order of declaration.</p>
<pre><code class="language-move=">address 0x42 {
module example {
    use std::vector;

    fun example(): vector&lt;u8&gt; {
        let v = empty();
        vector::push_back(&amp;mut v, 0);
        vector::push_back(&amp;mut v, 10);
        v
    }

    use std::vector::empty;
}
}
</code></pre>
<p>The aliases declared by <code>use</code> in the module usable within that module.</p>
<p>Additionally, the aliases introduced cannot conflict with other module members. See
<a href="uses.html#uniqueness">Uniqueness</a> for more details</p>
<h2 id="inside-an-expression"><a class="header" href="#inside-an-expression">Inside an expression</a></h2>
<p>You can add <code>use</code> declarations to the beginning of any expression block</p>
<pre><code class="language-move=">address 0x42 {
module example {

    fun example(): vector&lt;u8&gt; {
        use std::vector::{empty, push_back};

        let v = empty();
        push_back(&amp;mut v, 0);
        push_back(&amp;mut v, 10);
        v
    }
}
}
</code></pre>
<p>As with <code>let</code>, the aliases introduced by <code>use</code> in an expression block are removed at the end of that
block.</p>
<pre><code class="language-move=">address 0x42 {
module example {

    fun example(): vector&lt;u8&gt; {
        let result = {
            use std::vector::{empty, push_back};
            let v = empty();
            push_back(&amp;mut v, 0);
            push_back(&amp;mut v, 10);
            v
        };
        result
    }

}
}
</code></pre>
<p>Attempting to use the alias after the block ends will result in an error</p>
<pre><code class="language-move=">fun example(): vector&lt;u8&gt; {
    let result = {
        use std::vector::{empty, push_back};
        let v = empty();
        push_back(&amp;mut v, 0);
        push_back(&amp;mut v, 10);
        v
    };
    let v2 = empty(); // ERROR!
//           ^^^^^ unbound function 'empty'
    result
}
</code></pre>
<p>Any <code>use</code> must be the first item in the block. If the <code>use</code> comes after any expression or <code>let</code>, it
will result in a parsing error</p>
<pre><code class="language-move=">{
    let x = 0;
    use std::vector; // ERROR!
    let v = vector::empty();
}
</code></pre>
<h2 id="naming-rules"><a class="header" href="#naming-rules">Naming rules</a></h2>
<p>Aliases must follow the same rules as other module members. This means that aliases to structs or
constants must start with <code>A</code> to <code>Z</code></p>
<pre><code class="language-move=">address 0x42 {
module data {
    struct S {}
    const FLAG: bool = false;
    fun foo() {}
}
module example {
    use 0x42::data::{
        S as s, // ERROR!
        FLAG as fLAG, // ERROR!
        foo as FOO,  // valid
        foo as bar, // valid
    };
}
}
</code></pre>
<h2 id="uniqueness"><a class="header" href="#uniqueness">Uniqueness</a></h2>
<p>Inside a given scope, all aliases introduced by <code>use</code> declarations must be unique.</p>
<p>For a module, this means aliases introduced by <code>use</code> cannot overlap</p>
<pre><code class="language-move=">address 0x42 {
module example {

    use std::vector::{empty as foo, length as foo}; // ERROR!
    //                                        ^^^ duplicate 'foo'

    use std::vector::empty as bar;

    use std::vector::length as bar; // ERROR!
    //                         ^^^ duplicate 'bar'

}
}
</code></pre>
<p>And, they cannot overlap with any of the module's other members</p>
<pre><code class="language-move=">address 0x42 {
module data {
    struct S {}
}
module example {
    use 0x42::data::S;

    struct S { value: u64 } // ERROR!
    //     ^ conflicts with alias 'S' above
}
}
</code></pre>
<p>Inside of an expression block, they cannot overlap with each other, but they can
<a href="uses.html#shadowing">shadow</a> other aliases or names from an outer scope</p>
<h2 id="shadowing-1"><a class="header" href="#shadowing-1">Shadowing</a></h2>
<p><code>use</code> aliases inside of an expression block can shadow names (module members or aliases) from the
outer scope. As with shadowing of locals, the shadowing ends at the end of the expression block;</p>
<pre><code class="language-move=">address 0x42 {
module example {

    struct WrappedVector { vec: vector&lt;u64&gt; }

    fun empty(): WrappedVector {
        WrappedVector { vec: std::vector::empty() }
    }

    fun example1(): (WrappedVector, WrappedVector) {
        let vec = {
            use std::vector::{empty, push_back};
            // 'empty' now refers to std::vector::empty

            let v = empty();
            push_back(&amp;mut v, 0);
            push_back(&amp;mut v, 1);
            push_back(&amp;mut v, 10);
            v
        };
        // 'empty' now refers to Self::empty

        (empty(), WrappedVector { vec })
    }

    fun example2(): (WrappedVector, WrappedVector) {
        use std::vector::{empty, push_back};
        let w: WrappedVector = {
            use 0x42::example::empty;
            empty()
        };
        push_back(&amp;mut w.vec, 0);
        push_back(&amp;mut w.vec, 1);
        push_back(&amp;mut w.vec, 10);

        let vec = empty();
        push_back(&amp;mut vec, 0);
        push_back(&amp;mut vec, 1);
        push_back(&amp;mut vec, 10);

        (w, WrappedVector { vec })
    }
}
}
</code></pre>
<h2 id="unused-use-or-alias"><a class="header" href="#unused-use-or-alias">Unused Use or Alias</a></h2>
<p>An unused <code>use</code> will result in an error</p>
<pre><code class="language-move=">address 0x42 {
module example {
    use std::vector::{empty, push_back}; // ERROR!
    //                       ^^^^^^^^^ unused alias 'push_back'

    fun example(): vector&lt;u8&gt; {
        empty()
    }
}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="friends"><a class="header" href="#friends">Friends</a></h1>
<p>The <code>friend</code> syntax is used to declare modules that are trusted by the current module.
A trusted module is allowed to call any function defined in the current module that have the <code>public(friend)</code> visibility.
For details on function visibilities, please refer to the <em>Visibility</em> section in <a href="./functions.html">Functions</a>.</p>
<h2 id="friend-declaration"><a class="header" href="#friend-declaration">Friend declaration</a></h2>
<p>A module can declare other modules as friends via friend declaration statements, in the format of</p>
<ul>
<li>
<p><code>friend &lt;address::name&gt;</code> — friend declaration using fully qualified module name like the example below, or</p>
<pre><code class="language-move">address 0x42 {
module a {
    friend 0x42::b;
}
}
</code></pre>
</li>
<li>
<p><code>friend &lt;module-name-alias&gt;</code> — friend declaration using a module name alias, where the module alias is introduced via the <code>use</code> statement.</p>
<pre><code class="language-move">address 0x42 {
module a {
    use 0x42::b;
    friend b;
}
}
</code></pre>
</li>
</ul>
<p>A module may have multiple friend declarations, and the union of all the friend modules forms the friend list.
In the example below, both <code>0x42::B</code> and <code>0x42::C</code> are considered as friends of <code>0x42::A</code>.</p>
<pre><code class="language-move">address 0x42 {
module a {
    friend 0x42::b;
    friend 0x42::c;
}
}
</code></pre>
<p>Unlike <code>use</code> statements, <code>friend</code> can only be declared in the module scope and not in the expression block scope.
<code>friend</code> declarations may be located anywhere a top-level construct (e.g., <code>use</code>, <code>function</code>, <code>struct</code>, etc.) is allowed.
However, for readability, it is advised to place friend declarations near the beginning of the module definition.</p>
<p>Note that the concept of friendship does not apply to Move scripts:</p>
<ul>
<li>A Move script cannot declare <code>friend</code> modules as doing so is considered meaningless: there is no mechanism to call the function defined in a script.</li>
<li>A Move module cannot declare <code>friend</code> scripts as well because scripts are ephemeral code snippets that are never published to global storage.</li>
</ul>
<h3 id="friend-declaration-rules"><a class="header" href="#friend-declaration-rules">Friend declaration rules</a></h3>
<p>Friend declarations are subject to the following rules:</p>
<ul>
<li>
<p>A module cannot declare itself as a friend.</p>
<pre><code class="language-move=">address 0x42 {
module m { friend Self; // ERROR! }
//                ^^^^ Cannot declare the module itself as a friend
}

address 0x43 {
module m { friend 0x43::M; // ERROR! }
//                ^^^^^^^ Cannot declare the module itself as a friend
}
</code></pre>
</li>
<li>
<p>Friend modules must be known by the compiler</p>
<pre><code class="language-move=">address 0x42 {
module m { friend 0x42::nonexistent; // ERROR! }
//                ^^^^^^^^^^^^^^^^^ Unbound module '0x42::nonexistent'
}
</code></pre>
</li>
<li>
<p>Friend modules must be within the same account address. (Note: this is not a technical requirement but rather a policy decision which <em>may</em> be relaxed later.)</p>
<pre><code class="language-move=">address 0x42 {
module m {}
}

address 0x43 {
module n { friend 0x42::m; // ERROR! }
//                ^^^^^^^ Cannot declare modules out of the current address as a friend
}
</code></pre>
</li>
<li>
<p>Friends relationships cannot create cyclic module dependencies.</p>
<p>Cycles are not allowed in the friend relationships, e.g., the relation <code>0x2::a</code> friends <code>0x2::b</code> friends <code>0x2::c</code> friends <code>0x2::a</code> is not allowed.
More generally, declaring a friend module adds a dependency upon the current module to the friend module (because the purpose is for the friend to call functions in the current module).
If that friend module is already used, either directly or transitively, a cycle of dependencies would be created.</p>
<pre><code class="language-move=">address 0x2 {
module a {
    use 0x2::c;
    friend 0x2::b;

    public fun a() {
        c::c()
    }
}

module b {
    friend 0x2::c; // ERROR!
//         ^^^^^^ This friend relationship creates a dependency cycle: '0x2::b' is a friend of '0x2::a' uses '0x2::c' is a friend of '0x2::b'
}

module c {
    public fun c() {}
}
}
</code></pre>
</li>
<li>
<p>The friend list for a module cannot contain duplicates.</p>
<pre><code class="language-move=">address 0x42 {
module a {}

module m {
    use 0x42::a as aliased_a;
    friend 0x42::A;
    friend aliased_a; // ERROR!
//         ^^^^^^^^^ Duplicate friend declaration '0x42::a'. Friend declarations in a module must be unique
}
}
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packages"><a class="header" href="#packages">Packages</a></h1>
<p>Packages allow Move programmers to more easily re-use code and share it
across projects. The Move package system allows programmers to easily:</p>
<ul>
<li>Define a package containing Move code;</li>
<li>Parameterize a package by <a href="./address.html">named addresses</a>;</li>
<li>Import and use packages in other Move code and instantiate named addresses;</li>
<li>Build packages and generate associated compilation artifacts from packages; and</li>
<li>Work with a common interface around compiled Move artifacts.</li>
</ul>
<h2 id="package-layout-and-manifest-syntax"><a class="header" href="#package-layout-and-manifest-syntax">Package Layout and Manifest Syntax</a></h2>
<p>A Move package source directory contains a <code>Move.toml</code> package manifest
file along with a set of subdirectories:</p>
<pre><code>a_move_package
├── Move.toml      (required)
├── sources        (required)
├── examples       (optional, test &amp; dev mode)
├── scripts        (optional)
├── doc_templates  (optional)
└── tests          (optional, test mode)
</code></pre>
<p>The directories marked <code>required</code> <em>must</em> be present in order for the directory
to be considered a Move package and to be compiled. Optional directories can
be present, and if so will be included in the compilation process. Depending on
the mode that the package is built with (<code>test</code> or <code>dev</code>), the <code>tests</code> and
<code>examples</code> directories will be included as well.</p>
<p>The <code>sources</code> directory can contain both Move modules and Move scripts (both
transaction scripts and modules containing script functions). The <code>examples</code>
directory can hold additional code to be used only for development and/or
tutorial purposes that will not be included when compiled outside <code>test</code> or
<code>dev</code> mode.</p>
<p>A <code>scripts</code> directory is supported so transaction scripts can be separated
from modules if that is desired by the package author. The <code>scripts</code>
directory will always be included for compilation if it is present.
Documentation will be built using any documentation templates present in
the <code>doc_templates</code> directory.</p>
<h3 id="movetoml"><a class="header" href="#movetoml">Move.toml</a></h3>
<p>The Move package manifest is defined within the <code>Move.toml</code> file and has the
following syntax. Optional fields are marked with <code>*</code>, <code>+</code> denotes
one or more elements:</p>
<pre><code>[package]
name = &lt;string&gt;                  # e.g., &quot;MoveStdlib&quot;
version = &quot;&lt;uint&gt;.&lt;uint&gt;.&lt;uint&gt;&quot; # e.g., &quot;0.1.1&quot;
license* = &lt;string&gt;              # e.g., &quot;MIT&quot;, &quot;GPL&quot;, &quot;Apache 2.0&quot;
authors* = [&lt;string&gt;]            # e.g., [&quot;Joe Smith (joesmith@noemail.com)&quot;, &quot;Jane Smith (janesmith@noemail.com)&quot;]

[addresses]  # (Optional section) Declares named addresses in this package and instantiates named addresses in the package graph
# One or more lines declaring named addresses in the following format
&lt;addr_name&gt; = &quot;_&quot; | &quot;&lt;hex_address&gt;&quot; # e.g., std = &quot;_&quot; or my_addr = &quot;0xC0FFEECAFE&quot;

[dependencies] # (Optional section) Paths to dependencies and instantiations or renamings of named addresses from each dependency
# One or more lines declaring dependencies in the following format
&lt;string&gt; = { local = &lt;string&gt;, addr_subst* = { (&lt;string&gt; = (&lt;string&gt; | &quot;&lt;hex_address&gt;&quot;))+ } } # local dependencies
&lt;string&gt; = { git = &lt;URL ending in .git&gt;, subdir=&lt;path to dir containing Move.toml inside git repo&gt;, rev=&lt;git commit hash&gt;, addr_subst* = { (&lt;string&gt; = (&lt;string&gt; | &quot;&lt;hex_address&gt;&quot;))+ } } # git dependencies

[dev-addresses] # (Optional section) Same as [addresses] section, but only included in &quot;dev&quot; and &quot;test&quot; modes
# One or more lines declaring dev named addresses in the following format
&lt;addr_name&gt; = &quot;_&quot; | &quot;&lt;hex_address&gt;&quot; # e.g., std = &quot;_&quot; or my_addr = &quot;0xC0FFEECAFE&quot;

[dev-dependencies] # (Optional section) Same as [dependencies] section, but only included in &quot;dev&quot; and &quot;test&quot; modes
# One or more lines declaring dev dependencies in the following format
&lt;string&gt; = { local = &lt;string&gt;, addr_subst* = { (&lt;string&gt; = (&lt;string&gt; | &lt;address&gt;))+ } }
</code></pre>
<p>An example of a minimal package manifest with one local dependency and one git dependency:</p>
<pre><code>[package]
name = &quot;AName&quot;
version = &quot;0.0.0&quot;
</code></pre>
<p>An example of a more standard package manifest that also includes the Move
standard library and instantiates the named address <code>Std</code> from it with the
address value <code>0x1</code>:</p>
<pre><code>[package]
name = &quot;AName&quot;
version = &quot;0.0.0&quot;
license = &quot;Apache 2.0&quot;

[addresses]
address_to_be_filled_in = &quot;_&quot;
specified_address = &quot;0xB0B&quot;

[dependencies]
# Local dependency
LocalDep = { local = &quot;projects/move-awesomeness&quot;, addr_subst = { &quot;std&quot; = &quot;0x1&quot; } }
# Git dependency
MoveStdlib = { git = &quot;https://github.com/diem/diem.git&quot;, subdir=&quot;language/move-stdlib&quot;, rev = &quot;56ab033cc403b489e891424a629e76f643d4fb6b&quot; }

[dev-addresses] # For use when developing this module
address_to_be_filled_in = &quot;0x101010101&quot;
</code></pre>
<p>Most of the sections in the package manifest are self explanatory, but named
addresses can be a bit difficult to understand so it's worth examining them in
a bit more detail.</p>
<h2 id="named-addresses-during-compilation"><a class="header" href="#named-addresses-during-compilation">Named Addresses During Compilation</a></h2>
<p>Recall that Move has <a href="./address.html">named addresses</a> and that
named addresses cannot be declared in Move. Because of this, until now
named addresses and their values needed to be passed to the compiler on the
command line. With the Move package system this is no longer needed, and
you can declare named addresses in the package, instantiate other named
addresses in scope, and rename named addresses from other packages within
the Move package system manifest file. Let's go through each of these
individually:</p>
<h3 id="declaration-3"><a class="header" href="#declaration-3">Declaration</a></h3>
<p>Let's say we have a Move module in <code>example_pkg/sources/A.move</code> as follows:</p>
<pre><code class="language-move">module named_addr::A {
    public fun x(): address { @named_addr }
}
</code></pre>
<p>We could in <code>example_pkg/Move.toml</code> declare the named address <code>named_addr</code> in
two different ways. The first:</p>
<pre><code>[package]
name = &quot;ExamplePkg&quot;
...
[addresses]
named_addr = &quot;_&quot;
</code></pre>
<p>Declares <code>named_addr</code> as a named address in the package <code>ExamplePkg</code> and
that <em>this address can be any valid address value</em>. Therefore an importing
package can pick the value of the named address <code>named_addr</code> to be any address
it wishes. Intuitively you can think of this as parameterizing the package
<code>ExamplePkg</code> by the named address <code>named_addr</code>, and the package can then be
instantiated later on by an importing package.</p>
<p><code>named_addr</code> can also be declared as:</p>
<pre><code>[package]
name = &quot;ExamplePkg&quot;
...
[addresses]
named_addr = &quot;0xCAFE&quot;
</code></pre>
<p>which states that the named address <code>named_addr</code> is exactly <code>0xCAFE</code> and cannot be
changed. This is useful so other importing packages can use this named
address without needing to worry about the exact value assigned to it.</p>
<p>With these two different declaration methods, there are two ways that
information about named addresses can flow in the package graph:</p>
<ul>
<li>The former (&quot;unassigned named addresses&quot;) allows named address values to flow
from the importation site to the declaration site.</li>
<li>The latter (&quot;assigned named addresses&quot;) allows named address values to flow
from the declaration site upwards in the package graph to usage sites.</li>
</ul>
<p>With these two methods for flowing named address information throughout the
package graph the rules around scoping and renaming become important to
understand.</p>
<h2 id="scoping-and-renaming-of-named-addresses"><a class="header" href="#scoping-and-renaming-of-named-addresses">Scoping and Renaming of Named Addresses</a></h2>
<p>A named address <code>N</code> in a package <code>P</code> is in scope if:</p>
<ol>
<li>It declares a named address <code>N</code>; or</li>
<li>A package in one of <code>P</code>'s transitive dependencies declares the named address
<code>N</code> and there is a dependency path in the package graph between between <code>P</code> and the
declaring package of <code>N</code> with no renaming of <code>N</code>.</li>
</ol>
<p>Additionally, every named address in a package is exported. Because of this and
the above scoping rules each package can be viewed as coming with a set of
named addresses that will be brought into scope when the package is imported,
e.g., if the <code>ExamplePkg</code> package was imported, that importation would bring
into scope the <code>named_addr</code> named address. Because of this, if <code>P</code> imports two
packages <code>P1</code> and <code>P2</code> both of which declare a named address <code>N</code> an issue
arises in <code>P</code>: which &quot;<code>N</code>&quot; is meant when <code>N</code> is referred to in <code>P</code>? The one
from <code>P1</code> or <code>P2</code>? To prevent this ambiguity around which package a named
address is coming from, we enforce that the sets of scopes introduced by all
dependencies in a package are disjoint, and provide a way to <em>rename named
addresses</em> when the package that brings them into scope is imported.</p>
<p>Renaming a named address when importing can be done as follows in our <code>P</code>,
<code>P1</code>, and <code>P2</code> example above:</p>
<pre><code>[package]
name = &quot;P&quot;
...
[dependencies]
P1 = { local = &quot;some_path_to_P1&quot;, addr_subst = { &quot;P1N&quot; = &quot;N&quot; } }
P2 = { local = &quot;some_path_to_P2&quot;  }
</code></pre>
<p>With this renaming <code>N</code> refers to the <code>N</code> from <code>P2</code> and <code>P1N</code> will refer to <code>N</code>
coming from <code>P1</code>:</p>
<pre><code>module N::A {
    public fun x(): address { @P1N }
}
</code></pre>
<p>It is important to note that <em>renaming is not local</em>: once a named address <code>N</code>
has been renamed to <code>N2</code> in a package <code>P</code> all packages that import <code>P</code> will not
see <code>N</code> but only <code>N2</code> unless <code>N</code> is reintroduced from outside of <code>P</code>. This is
why rule (2) in the scoping rules at the start of this section specifies a
&quot;dependency path in the package graph between between <code>P</code> and the declaring
package of <code>N</code> with no renaming of <code>N</code>.&quot;</p>
<h3 id="instantiation-1"><a class="header" href="#instantiation-1">Instantiation</a></h3>
<p>Named addresses can be instantiated multiple times across the package graph as
long as it is always with the same value. It is an error if the same named
address (regardless of renaming) is instantiated with differing values across
the package graph.</p>
<p>A Move package can only be compiled if all named addresses resolve to a value.
This presents issues if the package wishes to expose an uninstantiated named
address. This is what the <code>[dev-addresses]</code> section solves. This section can
set values for named addresses, but cannot introduce any named addresses.
Additionally, only the <code>[dev-addresses]</code> in the root package are included in
<code>dev</code> mode. For example a root package with the following manifest would not compile
outside of <code>dev</code> mode since <code>named_addr</code> would be uninstantiated:</p>
<pre><code>[package]
name = &quot;ExamplePkg&quot;
...
[addresses]
named_addr = &quot;_&quot;

[dev-addresses]
named_addr = &quot;0xC0FFEE&quot;
</code></pre>
<h2 id="usage-artifacts-and-data-structures"><a class="header" href="#usage-artifacts-and-data-structures">Usage, Artifacts, and Data Structures</a></h2>
<p>The Move package system comes with a command line option as part of the Move
CLI <code>move &lt;flags&gt; &lt;command&gt; &lt;command_flags&gt;</code>. Unless a
particular path is provided, all package commands will run in the current working
directory. The full list of commands and flags for the Move CLI can be found by
running <code>move --help</code>.</p>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<p>A package can be compiled either through the Move CLI commands, or as a library
command in Rust with the function <code>compile_package</code>. This will create a
<code>CompiledPackage</code> that holds the compiled bytecode along with other compilation
artifacts (source maps, documentation, ABIs) in memory. This <code>CompiledPackage</code>
can be converted to an <code>OnDiskPackage</code> and vice versa -- the latter being the data of
the <code>CompiledPackage</code> laid out in the file system in the following format:</p>
<pre><code>a_move_package
├── Move.toml
...
└── build
    ├── &lt;dep_pkg_name&gt;
    │   ├── BuildInfo.yaml
    │   ├── bytecode_modules
    │   │   └── *.mv
    │   ├── source_maps
    │   │   └── *.mvsm
    │   ├── bytecode_scripts
    │   │   └── *.mv
    │   ├── abis
    │   │   ├── *.abi
    │   │   └── &lt;module_name&gt;/*.abi
    │   └── sources
    │       └── *.move
    ...
    └── &lt;dep_pkg_name&gt;
        ├── BuildInfo.yaml
        ...
        └── sources
</code></pre>
<p>See the <code>move-package</code> crate for more information on these data structures and
how to use the Move package system as a Rust library.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h1>
<p>Unit testing for Move adds three new annotations to the Move source language:</p>
<ul>
<li><code>#[test]</code></li>
<li><code>#[test_only]</code>, and</li>
<li><code>#[expected_failure]</code>.</li>
</ul>
<p>They respectively mark a function as a test, mark a module or module member (<code>use</code>, function, or struct) as code to be included for testing only, and mark that a test is expected to fail. These annotations can be placed on a function with any visibility. Whenever a module or module member is annotated as <code>#[test_only]</code> or <code>#[test]</code>, it will not be included in the compiled bytecode unless it is compiled for testing.</p>
<h2 id="testing-annotations-their-meaning-and-usage"><a class="header" href="#testing-annotations-their-meaning-and-usage">Testing Annotations: Their Meaning and Usage</a></h2>
<p>Both the <code>#[test]</code> and <code>#[expected_failure]</code> annotations can be used either with or without arguments.</p>
<p>Without arguments, the <code>#[test]</code> annotation can only be placed on a function with no parameters. This annotation simply marks this function as a test to be run by the unit testing harness.</p>
<pre><code>#[test] // OK
fun this_is_a_test() { ... }

#[test] // Will fail to compile since the test takes an argument
fun this_is_not_correct(arg: signer) { ... }
</code></pre>
<p>A test can also be annotated as an <code>#[expected_failure]</code>. This annotation marks that the test should is expected to raise an error. You can ensure that a test is aborting with a specific abort code by annotating it with <code>#[expected_failure(abort_code = &lt;code&gt;)]</code>, if it then fails with a different abort code or with a non-abort error the test will fail. Only functions that have the <code>#[test]</code> annotation can also be annotated as an #<code>[expected_failure]</code>.</p>
<pre><code>#[test]
#[expected_failure]
public fun this_test_will_abort_and_pass() { abort 1 }

#[test]
#[expected_failure]
public fun test_will_error_and_pass() { 1/0; }

#[test]
#[expected_failure(abort_code = 0)]
public fun test_will_error_and_fail() { 1/0; }

#[test, expected_failure] // Can have multiple in one attribute. This test will pass.
public fun this_other_test_will_abort_and_pass() { abort 1 }
</code></pre>
<p>With arguments, a test annotation takes the form <code>#[test(&lt;param_name_1&gt; = &lt;address&gt;, ..., &lt;param_name_n&gt; = &lt;address&gt;)]</code>. If a function is annotated in such a manner, the function's parameters must be a permutation of the parameters &lt;<code>param_name_1&gt;, ..., &lt;param_name_n&gt;</code>, i.e., the order of these parameters as they occur in the function and their order in the test annotation do not have to be the same, but they must be able to be matched up with each other by name.</p>
<p>Only parameters with a type of <code>signer</code> are supported as test parameters. If a non-<code>signer</code> parameter is supplied, the test will result in an error when run.</p>
<pre><code>#[test(arg = @0xC0FFEE)] // OK
fun this_is_correct_now(arg: signer) { ... }

#[test(wrong_arg_name = @0xC0FFEE)] // Not correct: arg name doesn't match
fun this_is_incorrect(arg: signer) { ... }

#[test(a = @0xC0FFEE, b = @0xCAFE)] // OK. We support multiple signer arguments, but you must always provide a value for that argument
fun this_works(a: signer, b: signer) { ... }

// somewhere a named address is declared
#[test_only] // test-only named addresses are supported
address TEST_NAMED_ADDR = @0x1;
...
#[test(arg = @TEST_NAMED_ADDR)] // Named addresses are supported!
fun this_is_correct_now(arg: signer) { ... }
</code></pre>
<p>An expected failure annotation can also take the form <code>#[expected_failure(abort_code = &lt;u64&gt;)]</code>. If a test function is annotated in such a way, the test must abort with an abort code equal to <code>&lt;u64&gt;</code>. Any other failure or abort code will result in a test failure.</p>
<pre><code>#[test, expected_failure(abort_code = 1)] // This test will fail
fun this_test_should_abort_and_fail() { abort 0 }

#[test]
#[expected_failure(abort_code = 0)] // This test will pass
fun this_test_should_abort_and_pass_too() { abort 0 }
</code></pre>
<p>A module and any of its members can be declared as test only. In such a case the item will only be included in the compiled Move bytecode when compiled in test mode. Additionally, when compiled outside of test mode, any non-test <code>use</code>s of a <code>#[test_only]</code> module will raise an error during compilation.</p>
<pre><code>#[test_only] // test only attributes can be attached to modules
module abc { ... }

#[test_only] // test only attributes can be attached to named addresses
address ADDR = @0x1;

#[test_only] // .. to uses
use 0x1::some_other_module;

#[test_only] // .. to structs
struct SomeStruct { ... }

#[test_only] // .. and functions. Can only be called from test code, but not a test
fun test_only_function(...) { ... }
</code></pre>
<h2 id="running-unit-tests"><a class="header" href="#running-unit-tests">Running Unit Tests</a></h2>
<p>Unit tests for a Move package can be run with the <a href="./packages.html"><code>move test</code>
command</a>.</p>
<p>When running tests, every test will either <code>PASS</code>, <code>FAIL</code>, or <code>TIMEOUT</code>. If a test case fails, the location of the failure along with the function name that caused the failure will be reported if possible. You can see an example of this below.</p>
<p>A test will be marked as timing out if it exceeds the maximum number of instructions that can be executed for any single test. This bound can be changed using the options below, and its default value is set to 5000 instructions. Additionally, while the result of a test is always deterministic, tests are run in parallel by default, so the ordering of test results in a test run is non-deterministic unless running with only one thread (see <code>OPTIONS</code> below).</p>
<p>There are also a number of options that can be passed to the unit testing binary to fine-tune testing and to help debug failing tests. These can be found using the help flag:</p>
<pre><code>$ move -h
</code></pre>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<p>A simple module using some of the unit testing features is shown in the following example:</p>
<p>First create an empty package and change directory into it:</p>
<pre><code>$ move new TestExample; cd TestExample
</code></pre>
<p>Next add the following to the <code>Move.toml</code>:</p>
<pre><code>[dependencies]
MoveStdlib = { git = &quot;https://github.com/diem/diem.git&quot;, subdir=&quot;language/move-stdlib&quot;, rev = &quot;56ab033cc403b489e891424a629e76f643d4fb6b&quot;, addr_subst = { &quot;std&quot; = &quot;0x1&quot; } }
</code></pre>
<p>Next add the following module under the <code>sources</code> directory:</p>
<pre><code>// filename: sources/my_module.move
module 0x1::my_module {

    struct MyCoin has key { value: u64 }

    public fun make_sure_non_zero_coin(coin: MyCoin): MyCoin {
        assert!(coin.value &gt; 0, 0);
        coin
    }

    public fun has_coin(addr: address): bool {
        exists&lt;MyCoin&gt;(addr)
    }

    #[test]
    fun make_sure_non_zero_coin_passes() {
        let coin = MyCoin { value: 1 };
        let MyCoin { value: _ } = make_sure_non_zero_coin(coin);
    }

    #[test]
    // Or #[expected_failure] if we don't care about the abort code
    #[expected_failure(abort_code = 0)]
    fun make_sure_zero_coin_fails() {
        let coin = MyCoin { value: 0 };
        let MyCoin { value: _ } = make_sure_non_zero_coin(coin);
    }

    #[test_only] // test only helper function
    fun publish_coin(account: &amp;signer) {
        move_to(account, MyCoin { value: 1 })
    }

    #[test(a = @0x1, b = @0x2)]
    fun test_has_coin(a: signer, b: signer) {
        publish_coin(&amp;a);
        publish_coin(&amp;b);
        assert!(has_coin(@0x1), 0);
        assert!(has_coin(@0x2), 1);
        assert!(!has_coin(@0x3), 1);
    }
}
</code></pre>
<h3 id="running-tests"><a class="header" href="#running-tests">Running Tests</a></h3>
<p>You can then run these tests with the <code>move test</code> command:</p>
<pre><code>$ move test
BUILDING MoveStdlib
BUILDING TestExample
Running Move unit tests
[ PASS    ] 0x1::my_module::make_sure_non_zero_coin_passes
[ PASS    ] 0x1::my_module::make_sure_zero_coin_fails
[ PASS    ] 0x1::my_module::test_has_coin
Test result: OK. Total tests: 3; passed: 3; failed: 0
</code></pre>
<h3 id="using-test-flags"><a class="header" href="#using-test-flags">Using Test Flags</a></h3>
<h4 id="-f-str-or---filter-str"><a class="header" href="#-f-str-or---filter-str"><code>-f &lt;str&gt;</code> or <code>--filter &lt;str&gt;</code></a></h4>
<p>This will only run tests whose fully qualified name contains <code>&lt;str&gt;</code>. For example if we wanted to only run tests with <code>&quot;zero_coin&quot;</code> in their name:</p>
<pre><code>$ move test -f zero_coin
CACHED MoveStdlib
BUILDING TestExample
Running Move unit tests
[ PASS    ] 0x1::my_module::make_sure_non_zero_coin_passes
[ PASS    ] 0x1::my_module::make_sure_zero_coin_fails
Test result: OK. Total tests: 2; passed: 2; failed: 0
</code></pre>
<h4 id="-i-bound-or---gas_used-bound"><a class="header" href="#-i-bound-or---gas_used-bound"><code>-i &lt;bound&gt;</code> or <code>--gas_used &lt;bound&gt;</code></a></h4>
<p>This bounds the amount of gas that can be consumed for any one test to <code>&lt;bound&gt;</code>:</p>
<pre><code>$ move test -i 0
CACHED MoveStdlib
BUILDING TestExample
Running Move unit tests
[ TIMEOUT ] 0x1::my_module::make_sure_non_zero_coin_passes
[ TIMEOUT ] 0x1::my_module::make_sure_zero_coin_fails
[ TIMEOUT ] 0x1::my_module::test_has_coin

Test failures:

Failures in 0x1::my_module:

┌── make_sure_non_zero_coin_passes ──────
│ Test timed out
└──────────────────


┌── make_sure_zero_coin_fails ──────
│ Test timed out
└──────────────────


┌── test_has_coin ──────
│ Test timed out
└──────────────────

Test result: FAILED. Total tests: 3; passed: 0; failed: 3
</code></pre>
<h4 id="-s-or---statistics"><a class="header" href="#-s-or---statistics"><code>-s</code> or <code>--statistics</code></a></h4>
<p>With these flags you can gather statistics about the tests run and report the runtime and gas used for each test. For example, if we wanted to see the statistics for the tests in the example above:</p>
<pre><code>$ move test -s
CACHED MoveStdlib
BUILDING TestExample
Running Move unit tests
[ PASS    ] 0x1::my_module::make_sure_non_zero_coin_passes
[ PASS    ] 0x1::my_module::make_sure_zero_coin_fails
[ PASS    ] 0x1::my_module::test_has_coin

Test Statistics:

┌────────────────────────────────────────────────┬────────────┬───────────────────────────┐
│                   Test Name                    │    Time    │   Gas Used   │
├────────────────────────────────────────────────┼────────────┼───────────────────────────┤
│ 0x1::my_module::make_sure_non_zero_coin_passes │   0.009    │             1             │
├────────────────────────────────────────────────┼────────────┼───────────────────────────┤
│ 0x1::my_module::make_sure_zero_coin_fails      │   0.008    │             1             │
├────────────────────────────────────────────────┼────────────┼───────────────────────────┤
│ 0x1::my_module::test_has_coin                  │   0.008    │             1             │
└────────────────────────────────────────────────┴────────────┴───────────────────────────┘

Test result: OK. Total tests: 3; passed: 3; failed: 0
</code></pre>
<h4 id="-g-or---state-on-error"><a class="header" href="#-g-or---state-on-error"><code>-g</code> or <code>--state-on-error</code></a></h4>
<p>These flags will print the global state for any test failures. e.g., if we added the following (failing) test to the <code>my_module</code> example:</p>
<pre><code>module 0x1::my_module {
    ...
    #[test(a = @0x1)]
    fun test_has_coin_bad(a: signer) {
        publish_coin(&amp;a);
        assert!(has_coin(@0x1), 0);
        assert!(has_coin(@0x2), 1);
    }
}
</code></pre>
<p>we would get the following output when running the tests:</p>
<pre><code>$ move test -g
CACHED MoveStdlib
BUILDING TestExample
Running Move unit tests
[ PASS    ] 0x1::my_module::make_sure_non_zero_coin_passes
[ PASS    ] 0x1::my_module::make_sure_zero_coin_fails
[ PASS    ] 0x1::my_module::test_has_coin
[ FAIL    ] 0x1::my_module::test_has_coin_bad

Test failures:

Failures in 0x1::my_module:

┌── test_has_coin_bad ──────
│ error[E11001]: test failure
│    ┌─ /home/tzakian/TestExample/sources/my_module.move:47:10
│    │
│ 44 │      fun test_has_coin_bad(a: signer) {
│    │          ----------------- In this function in 0x1::my_module
│    ·
│ 47 │          assert!(has_coin(@0x2), 1);
│    │          ^^^^^^^^^^^^^^^^^^^^^^^^^^ Test was not expected to abort but it aborted with 1 here
│
│
│ ────── Storage state at point of failure ──────
│ 0x1:
│       =&gt; key 0x1::my_module::MyCoin {
│           value: 1
│       }
│
└──────────────────

Test result: FAILED. Total tests: 4; passed: 3; failed: 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="global-storage---structure"><a class="header" href="#global-storage---structure">Global Storage - Structure</a></h1>
<p>The purpose of Move programs is to <a href="./global-storage-operators.html">read from and write to</a> tree-shaped persistent global storage. Programs cannot access the filesystem, network, or any other data outside of this tree.</p>
<p>In pseudocode, the global storage looks something like:</p>
<pre><code class="language-move">struct GlobalStorage {
  resources: Map&lt;(address, ResourceType), ResourceValue&gt;
  modules: Map&lt;(address, ModuleName), ModuleBytecode&gt;
}
</code></pre>
<p>Structurally, global storage is a <a href="https://en.wikipedia.org/wiki/Tree_(graph_theory)">forest</a> consisting of trees rooted at an account <a href="./address.html"><code>address</code></a>. Each address can store both <a href="./structs-and-resources.html">resource</a> data values and <a href="./modules-and-scripts.html">module</a> code values. As the pseudocode above indicates, each <code>address</code> can store at most one resource value of a given type and at most one module with a given name.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="global-storage---operators"><a class="header" href="#global-storage---operators">Global Storage - Operators</a></h1>
<p>Move programs can create, delete, and update <a href="./structs-and-resources.html">resources</a> in global storage using the following five instructions:</p>
<table><thead><tr><th>Operation</th><th>Description</th><th>Aborts?</th></tr></thead><tbody>
<tr><td><code>move_to&lt;T&gt;(&amp;signer,T)</code></td><td>Publish <code>T</code> under <code>signer.address</code></td><td>If <code>signer.address</code> already holds a <code>T</code></td></tr>
<tr><td><code>move_from&lt;T&gt;(address): T</code></td><td>Remove <code>T</code> from <code>address</code> and return it</td><td>If <code>address</code> does not hold a <code>T</code></td></tr>
<tr><td><code>borrow_global_mut&lt;T&gt;(address): &amp;mut T</code></td><td>Return a mutable reference to the <code>T</code> stored under <code>address</code></td><td>If <code>address</code> does not hold a <code>T</code></td></tr>
<tr><td><code>borrow_global&lt;T&gt;(address): &amp;T</code></td><td>Return an immutable reference to the <code>T</code> stored under <code>address</code></td><td>If <code>address</code> does not hold a <code>T</code></td></tr>
<tr><td><code>exists&lt;T&gt;(address): bool</code></td><td>Return <code>true</code> if a <code>T</code> is stored under <code>address</code></td><td>Never</td></tr>
</tbody></table>
<p>Each of these instructions is parameterized by a type <code>T</code> with the <a href="./abilities.html"><code>key</code> ability</a>. However, each type <code>T</code> <em>must be declared in the current module</em>. This ensures that a resource can only be manipulated via the API exposed by its defining module. The instructions also take either an <a href="./address.html"><code>address</code></a> or <a href="./signer.html"><code>&amp;signer</code></a> representing the account address where the resource of type <code>T</code> is stored.</p>
<h2 id="references-to-resources"><a class="header" href="#references-to-resources">References to resources</a></h2>
<p>References to global resources returned by <code>borrow_global</code> or <code>borrow_global_mut</code> mostly behave like references to local storage: they can be extended, read, and written using ordinary <a href="./references.html">reference operators</a> and passed as arguments to other function. However, there is one important difference between local and global references: <strong>a function cannot return a reference that points into global storage</strong>. For example, these two functions will each fail to compile:</p>
<pre><code class="language-move">struct R has key { f: u64 }
// will not compile
fun ret_direct_resource_ref_bad(a: address): &amp;R {
    borrow_global&lt;R&gt;(a) // error!
}
// also will not compile
fun ret_resource_field_ref_bad(a: address): &amp;u64 {
    &amp;borrow_global&lt;R&gt;(a).f // error!
}
</code></pre>
<p>Move must enforce this restriction to guarantee absence of dangling references to global storage. <a href="global-storage-operators.html#reference-safety-for-global-resources">This</a> section contains much more detail for the interested reader.</p>
<h2 id="global-storage-operators-with-generics"><a class="header" href="#global-storage-operators-with-generics">Global storage operators with generics</a></h2>
<p>Global storage operations can be applied to generic resources with both instantiated and uninstantiated generic type parameters:</p>
<pre><code class="language-move">struct Container&lt;T&gt; has key { t: T }

// Publish a Container storing a type T of the caller's choosing
fun publish_generic_container&lt;T&gt;(account: &amp;signer, t: T) {
    move_to&lt;Container&lt;T&gt;&gt;(account, Container { t })
}

/// Publish a container storing a u64
fun publish_instantiated_generic_container(account: &amp;signer, t: u64) {
    move_to&lt;Container&lt;u64&gt;&gt;(account, Container { t })
}
</code></pre>
<p>The ability to index into global storage via a type parameter chosen at runtime is a powerful Move feature known as <em>storage polymorphism</em>. For more on the design patterns enabled by this feature, see <a href="./generics.html">Move generics</a>.</p>
<h2 id="example-counter"><a class="header" href="#example-counter">Example: <code>Counter</code></a></h2>
<p>The simple <code>Counter</code> module below exercises each of the five global storage operators. The API exposed by this module allows:</p>
<ul>
<li>Anyone to publish a <code>Counter</code> resource under their account</li>
<li>Anyone to check if a <code>Counter</code> exists under any address</li>
<li>Anyone to read or increment the value of a <code>Counter</code> resource under any address</li>
<li>An account that stores a <code>Counter</code> resource to reset it to zero</li>
<li>An account that stores a <code>Counter</code> resource to remove and delete it</li>
</ul>
<pre><code class="language-move">address 0x42 {
module counter {
    use std::signer;

    /// Resource that wraps an integer counter
    struct Counter has key { i: u64 }

    /// Publish a `Counter` resource with value `i` under the given `account`
    public fun publish(account: &amp;signer, i: u64) {
      // &quot;Pack&quot; (create) a Counter resource. This is a privileged operation that
      // can only be done inside the module that declares the `Counter` resource
      move_to(account, Counter { i })
    }

    /// Read the value in the `Counter` resource stored at `addr`
    public fun get_count(addr: address): u64 acquires Counter {
        borrow_global&lt;Counter&gt;(addr).i
    }

    /// Increment the value of `addr`'s `Counter` resource
    public fun increment(addr: address) acquires Counter {
        let c_ref = &amp;mut borrow_global_mut&lt;Counter&gt;(addr).i;
        *c_ref = *c_ref + 1
    }

    /// Reset the value of `account`'s `Counter` to 0
    public fun reset(account: &amp;signer) acquires Counter {
        let c_ref = &amp;mut borrow_global_mut&lt;Counter&gt;(signer::address_of(account)).i;
        *c_ref = 0
    }

    /// Delete the `Counter` resource under `account` and return its value
    public fun delete(account: &amp;signer): u64 acquires Counter {
        // remove the Counter resource
        let c = move_from&lt;Counter&gt;(signer::address_of(account));
        // &quot;Unpack&quot; the `Counter` resource into its fields. This is a
        // privileged operation that can only be done inside the module
        // that declares the `Counter` resource
        let Counter { i } = c;
        i
    }

    /// Return `true` if `addr` contains a `Counter` resource
    public fun exists(addr: address): bool {
        exists&lt;Counter&gt;(addr)
    }
}
}
</code></pre>
<h2 id="annotating-functions-with-acquires"><a class="header" href="#annotating-functions-with-acquires">Annotating functions with <code>acquires</code></a></h2>
<p>In the <code>counter</code> example, you might have noticed that the <code>get_count</code>, <code>increment</code>, <code>reset</code>, and <code>delete</code> functions are annotated with <code>acquires Counter</code>. A Move function <code>m::f</code> must be annotated with <code>acquires T</code> if and only if:</p>
<ul>
<li>The body of <code>m::f</code> contains a <code>move_from&lt;T&gt;</code>, <code>borrow_global_mut&lt;T&gt;</code>, or <code>borrow_global&lt;T&gt;</code> instruction, or</li>
<li>The body of <code>m::f</code> invokes a function <code>m::g</code> declared in the same module that is annotated with <code>acquires</code></li>
</ul>
<p>For example, the following function inside <code>Counter</code> would need an <code>acquires</code> annotation:</p>
<pre><code class="language-move">// Needs `acquires` because `increment` is annotated with `acquires`
fun call_increment(addr: address): u64 acquires Counter {
    counter::increment(addr)
}
</code></pre>
<p>However, the same function <em>outside</em> <code>Counter</code> would not need an annotation:</p>
<pre><code class="language-move">address 0x43 {
module m {
   use 0x42::counter;

   // Ok. Only need annotation when resource acquired by callee is declared
   // in the same module
   fun call_increment(addr: address): u64 {
       counter::increment(addr)
   }
}
}
</code></pre>
<p>If a function touches multiple resources, it needs multiple <code>acquires</code>:</p>
<pre><code class="language-move=">address 0x42 {
module two_resources {
    struct R1 has key { f: u64 }
    struct R2 has key { g: u64 }

    fun double_acquires(a: address): u64 acquires R1, R2 {
        borrow_global&lt;R1&gt;(a).f + borrow_global&lt;R2&gt;.g
    }
}
}
</code></pre>
<p>The <code>acquires</code> annotation does not take generic type parameters into account:</p>
<pre><code class="language-move=">address 0x42 {
module m {
    struct R&lt;T&gt; has key { t: T }

    // `acquires R`, not `acquires R&lt;T&gt;`
    fun acquire_generic_resource&lt;T: store&gt;(a: addr) acquires R {
        let _ = borrow_global&lt;R&lt;T&gt;&gt;(a);
    }

    // `acquires R`, not `acquires R&lt;u64&gt;
    fun acquire_instantiated_generic_resource(a: addr) acquires R {
        let _ = borrow_global&lt;R&lt;u64&gt;&gt;(a);
    }
}
}
</code></pre>
<p>Finally: redundant <code>acquires</code> are not allowed. Adding this function inside <code>Counter</code> will result in a compilation error:</p>
<pre><code class="language-move">// This code will not compile because the body of the function does not use a global
// storage instruction or invoke a function with `acquires`
fun redundant_acquires_bad() acquires Counter {}
</code></pre>
<p>For more information on <code>acquires</code>, see <a href="./functions.html">Move functions</a>.</p>
<h2 id="reference-safety-for-global-resources"><a class="header" href="#reference-safety-for-global-resources">Reference Safety For Global Resources</a></h2>
<p>Move prohibits returning global references and requires the <code>acquires</code> annotation to prevent dangling references. This allows Move to live up to its promise of static reference safety (i.e., no dangling references, no <code>null</code> or <code>nil</code> dereferences) for all <a href="./references.html">reference</a> types.</p>
<p>This example illustrates how the Move type system uses <code>acquires</code> to prevent a dangling reference:</p>
<pre><code class="language-move=">address 0x42 {
module dangling {
    struct T has key { f: u64 }

    fun borrow_then_remove_bad(a: address) acquires T {
        let t_ref: &amp;mut T = borrow_global_mut&lt;T&gt;(a);
        let t = remove_t(a); // type system complains here
        // t_ref now dangling!
        let uh_oh = *&amp;t_ref.f
    }

    fun remove_t(a: address): T acquires T {
        move_from&lt;T&gt;(a)
    }

}
}
</code></pre>
<p>In this code, line 6 acquires a reference to the <code>T</code> stored at address <code>a</code> in global storage. The callee <code>remove_t</code> then removes the value, which makes <code>t_ref</code> a dangling reference.</p>
<p>Fortunately, this cannot happen because the type system will reject this program. The <code>acquires</code> annotation on <code>remove_t</code> lets the type system know that line 7 is dangerous, without having to recheck or introspect the body of <code>remove_t</code> separately!</p>
<p>The restriction on returning global references prevents a similar, but even more insidious problem:</p>
<pre><code class="language-move=">address 0x42 {
module m1 {
    struct T has key {}

    public fun ret_t_ref(a: address): &amp;T acquires T {
        borrow_global&lt;T&gt;(a) // error! type system complains here
    }

    public fun remove_t(a: address) acquires T {
        let T {} = move_from&lt;T&gt;(a);
    }
}

module m2 {
    fun borrow_then_remove_bad(a: address) {
        let t_ref = m1::ret_t_ref(a);
        let t = m1::remove_t(a); // t_ref now dangling!
    }
}
}
</code></pre>
<p>Line 16 acquires a reference to a global resource <code>m1::T</code>, then line 17 removes that same resource, which makes <code>t_ref</code> dangle. In this case, <code>acquires</code> annotations do not help us because the <code>borrow_then_remove_bad</code> function is outside of the <code>m1</code> module that declares <code>T</code> (recall that <code>acquires</code> annotations can only be used for resources declared in the current module). Instead, the type system avoids this problem by preventing the return of a global reference at line 6.</p>
<p>Fancier type systems that would allow returning global references without sacrificing reference safety are possible, and we may consider them in future iterations of Move. We chose the current design because it strikes a good balance between expressivity, annotation burden, and type system complexity.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-library"><a class="header" href="#standard-library">Standard Library</a></h1>
<p>The Move standard library exposes interfaces that implement the following functionality:</p>
<ul>
<li><a href="standard-library.html#vector">Basic operations on vectors</a>.</li>
<li><a href="standard-library.html#option">Option types and operations on<code>Option</code> types</a>.</li>
<li><a href="standard-library.html#errors">A common error encoding code interface for abort codes</a>.</li>
<li><a href="standard-library.html#fixed_point32">32-bit precision fixed-point numbers</a>.</li>
</ul>
<h2 id="vector-1"><a class="header" href="#vector-1">vector</a></h2>
<p>The <code>vector</code> module defines a number of operations over the primitive
<a href="./vector.html"><code>vector</code></a> type. The module is published under the
named address <code>Std</code> and consists of a number of native functions, as
well as functions defined in Move. The API for this module is as follows.</p>
<h3 id="functions-1"><a class="header" href="#functions-1">Functions</a></h3>
<hr />
<p>Create an empty <a href="./vector.html"><code>vector</code></a>.
The <code>Element</code> type can be both a <code>resource</code> or <code>copyable</code> type.</p>
<pre><code class="language-move">    native public fun empty&lt;Element&gt;(): vector&lt;Element&gt;;
</code></pre>
<hr />
<p>Create a vector of length <code>1</code> containing the passed in <code>element</code>.</p>
<pre><code class="language-move">    public fun singleton&lt;Element&gt;(e: Element): vector&lt;Element&gt;;
</code></pre>
<hr />
<p>Destroy (deallocate) the vector <code>v</code>. Will abort if <code>v</code> is non-empty.
<em>Note</em>: The emptiness restriction is due to the fact that <code>Element</code> can be a
resource type, and destruction of a non-empty vector would violate
<a href="./structs-and-resources.html">resource conservation</a>.</p>
<pre><code class="language-move">    native public fun destroy_empty&lt;Element&gt;(v: vector&lt;Element&gt;);
</code></pre>
<hr />
<p>Acquire an <a href="./references.html">immutable reference</a> to the <code>i</code>th element of the vector <code>v</code>.  Will abort if
the index <code>i</code> is out of bounds for the vector <code>v</code>.</p>
<pre><code class="language-move">    native public fun borrow&lt;Element&gt;(v: &amp;vector&lt;Element&gt;, i: u64): &amp;Element;
</code></pre>
<hr />
<p>Acquire a <a href="./references.html">mutable reference</a>
to the <code>i</code>th element of the vector <code>v</code>.  Will abort if
the index <code>i</code> is out of bounds for the vector <code>v</code>.</p>
<pre><code class="language-move">    native public fun borrow_mut&lt;Element&gt;(v: &amp;mut vector&lt;Element&gt;, i: u64): &amp;mut Element;
</code></pre>
<hr />
<p>Empty and destroy the <code>other</code> vector, and push each of the elements in
the <code>other</code> vector onto the <code>lhs</code> vector in the same order as they occurred in <code>other</code>.</p>
<pre><code class="language-move">    public fun append&lt;Element&gt;(lhs: &amp;mut vector&lt;Element&gt;, other: vector&lt;Element&gt;);
</code></pre>
<hr />
<p>Push an element <code>e</code> of type <code>Element</code> onto the end of the vector <code>v</code>. May
trigger a resizing of the underlying vector's memory.</p>
<pre><code class="language-move">    native public fun push_back&lt;Element&gt;(v: &amp;mut vector&lt;Element&gt;, e: Element);
</code></pre>
<hr />
<p>Pop an element from the end of the vector <code>v</code> in-place and return the owned
value. Will abort if <code>v</code> is empty.</p>
<pre><code class="language-move">    native public fun pop_back&lt;Element&gt;(v: &amp;mut vector&lt;Element&gt;): Element;
</code></pre>
<hr />
<p>Remove the element at index <code>i</code> in the vector <code>v</code> and return the owned value
that was previously stored at <code>i</code> in <code>v</code>. All elements occurring at indices
greater than <code>i</code> will be shifted down by 1. Will abort if <code>i</code> is out of bounds
for <code>v</code>.</p>
<pre><code class="language-move">    public fun remove&lt;Element&gt;(v: &amp;mut vector&lt;Element&gt;, i: u64): Element;
</code></pre>
<hr />
<p>Swap the <code>i</code>th element of the vector <code>v</code> with the last element and then pop
this element off of the back of the vector and return the owned value that
was previously stored at index <code>i</code>.
This operation is O(1), but does not preserve ordering of elements in the vector.
Aborts if the index <code>i</code> is out of bounds for the vector <code>v</code>.</p>
<pre><code class="language-move">    public fun swap_remove&lt;Element&gt;(v: &amp;mut vector&lt;Element&gt;, i: u64): Element;
</code></pre>
<hr />
<p>Swap the elements at the <code>i</code>'th and <code>j</code>'th indices in the vector <code>v</code>. Will
abort if either of <code>i</code> or <code>j</code> are out of bounds for <code>v</code>.</p>
<pre><code class="language-move">    native public fun swap&lt;Element&gt;(v: &amp;mut vector&lt;Element&gt;, i: u64, j: u64);
</code></pre>
<hr />
<p>Reverse the order of the elements in the vector <code>v</code> in-place.</p>
<pre><code class="language-move">    public fun reverse&lt;Element&gt;(v: &amp;mut vector&lt;Element&gt;);
</code></pre>
<hr />
<p>Return the index of the first occurrence of an element in <code>v</code> that is
equal to <code>e</code>. Returns <code>(true, index)</code> if such an element was found, and
<code>(false, 0)</code> otherwise.</p>
<pre><code class="language-move">    public fun index_of&lt;Element&gt;(v: &amp;vector&lt;Element&gt;, e: &amp;Element): (bool, u64);
</code></pre>
<hr />
<p>Return if an element equal to <code>e</code> exists in the vector <code>v</code>.</p>
<pre><code class="language-move">    public fun contains&lt;Element&gt;(v: &amp;vector&lt;Element&gt;, e: &amp;Element): bool;
</code></pre>
<hr />
<p>Return the length of a <code>vector</code>.</p>
<pre><code class="language-move">    native public fun length&lt;Element&gt;(v: &amp;vector&lt;Element&gt;): u64;
</code></pre>
<hr />
<p>Return whether the vector <code>v</code> is empty.</p>
<pre><code class="language-move">    public fun is_empty&lt;Element&gt;(v: &amp;vector&lt;Element&gt;): bool;
</code></pre>
<hr />
<h2 id="option"><a class="header" href="#option">option</a></h2>
<p>The <code>option</code> module defines a generic option type <code>Option&lt;T&gt;</code> that represents a
value of type <code>T</code> that may, or may not, be present. It is published under the named address <code>Std</code>.</p>
<p>The Move option type is internally represented as a singleton vector, and may
contain a value of <code>resource</code> or <code>copyable</code> kind.  If you are familiar with option
types in other languages, the Move <code>Option</code> behaves similarly to those with a
couple notable exceptions since the option can contain a value of kind <code>resource</code>.
Particularly, certain operations such as <code>get_with_default</code> and
<code>destroy_with_default</code> require that the element type <code>T</code> be of <code>copyable</code> kind.</p>
<p>The API for the <code>option</code> module is as as follows</p>
<h3 id="types"><a class="header" href="#types">Types</a></h3>
<p>Generic type abstraction of a value that may, or may not, be present. Can contain
a value of either <code>resource</code> or <code>copyable</code> kind.</p>
<pre><code class="language-move">    struct Option&lt;T&gt;;
</code></pre>
<h3 id="functions-2"><a class="header" href="#functions-2">Functions</a></h3>
<p>Create an empty <code>Option</code> of that can contain a value of <code>Element</code> type.</p>
<pre><code class="language-move">    public fun none&lt;Element&gt;(): Option&lt;Element&gt;;
</code></pre>
<hr />
<p>Create a non-empty <code>Option</code> type containing a value <code>e</code> of type <code>Element</code>.</p>
<pre><code class="language-move">    public fun some&lt;Element&gt;(e: T): Option&lt;Element&gt;;
</code></pre>
<hr />
<p>Return an immutable reference to the value inside the option <code>opt_elem</code>
Will abort if <code>opt_elem</code> does not contain a value.</p>
<pre><code class="language-move">    public fun borrow&lt;Element&gt;(opt_elem: &amp;Option&lt;Element&gt;): &amp;Element;
</code></pre>
<hr />
<p>Return a reference to the value inside <code>opt_elem</code> if it contains one. If
<code>opt_elem</code> does not contain a value the passed in <code>default_ref</code> reference will be returned.
Does not abort.</p>
<pre><code class="language-move">    public fun borrow_with_default&lt;Element&gt;(opt_elem: &amp;Option&lt;Element&gt;, default_ref: &amp;Element): &amp;Element;
</code></pre>
<hr />
<p>Return a mutable reference to the value inside <code>opt_elem</code>. Will abort if
<code>opt_elem</code> does not contain a value.</p>
<pre><code class="language-move">    public fun borrow_mut&lt;Element&gt;(opt_elem: &amp;mut Option&lt;Element&gt;): &amp;mut Element;
</code></pre>
<hr />
<p>Convert an option value that contains a value to one that is empty in-place by
removing and returning the value stored inside <code>opt_elem</code>.
Will abort if <code>opt_elem</code> does not contain a value.</p>
<pre><code class="language-move">    public fun extract&lt;Element&gt;(opt_elem: &amp;mut Option&lt;Element&gt;): Element;
</code></pre>
<hr />
<p>Return the value contained inside the option <code>opt_elem</code> if it contains one.
Will return the passed in <code>default</code> value if <code>opt_elem</code> does not contain a
value. The <code>Element</code> type that the <code>Option</code> type is instantiated with must be
of <code>copyable</code> kind in order for this function to be callable.</p>
<pre><code class="language-move">    public fun get_with_default&lt;Element: copyable&gt;(opt_elem: &amp;Option&lt;Element&gt;, default: Element): Element;
</code></pre>
<hr />
<p>Convert an empty option <code>opt_elem</code> to an option value that contains the value <code>e</code>.
Will abort if <code>opt_elem</code> already contains a value.</p>
<pre><code class="language-move">    public fun fill&lt;Element&gt;(opt_elem: &amp;mut Option&lt;Element&gt;, e: Element);
</code></pre>
<hr />
<p>Swap the value currently contained in <code>opt_elem</code> with <code>new_elem</code> and return the
previously contained value. Will abort if <code>opt_elem</code> does not contain a value.</p>
<pre><code class="language-move">    public fun swap&lt;Element&gt;(opt_elem: &amp;mut Option&lt;Element&gt;, e: Element): Element;
</code></pre>
<hr />
<p>Return true if <code>opt_elem</code> contains a value equal to the value of <code>e_ref</code>.
Otherwise, <code>false</code> will be returned.</p>
<pre><code class="language-move">    public fun contains&lt;Element&gt;(opt_elem: &amp;Option&lt;Element&gt;, e_ref: &amp;Element): bool;
</code></pre>
<hr />
<p>Return <code>true</code> if <code>opt_elem</code> does not contain a value.</p>
<pre><code class="language-move">    public fun is_none&lt;Element&gt;(opt_elem: &amp;Option&lt;Element&gt;): bool;
</code></pre>
<hr />
<p>Return <code>true</code> if <code>opt_elem</code> contains a value.</p>
<pre><code class="language-move">    public fun is_some&lt;Element&gt;(opt_elem: &amp;Option&lt;Element&gt;): bool;
</code></pre>
<hr />
<p>Unpack <code>opt_elem</code> and return the value that it contained.
Will abort if <code>opt_elem</code> does not contain a value.</p>
<pre><code class="language-move">    public fun destroy_some&lt;Element&gt;(opt_elem: Option&lt;Element&gt;): Element;
</code></pre>
<hr />
<p>Destroys the <code>opt_elem</code> value passed in. If <code>opt_elem</code> contained a value it
will be returned otherwise, the passed in <code>default</code> value will be returned.</p>
<pre><code class="language-move">    public fun destroy_with_default&lt;Element: copyable&gt;(opt_elem: Option&lt;Element&gt;, default: Element): Element;
</code></pre>
<hr />
<p>Destroys the <code>opt_elem</code> value passed in, <code>opt_elem</code> must be empty and not
contain a value. Will abort if <code>opt_elem</code> contains a value.</p>
<pre><code class="language-move">    public fun destroy_none&lt;Element&gt;(opt_elem: Option&lt;Element&gt;);
</code></pre>
<h2 id="errors"><a class="header" href="#errors">errors</a></h2>
<p>Recall that each abort code in Move is represented as an unsigned 64-bit integer. The <code>errors</code> module defines a common interface that can be used to &quot;tag&quot; each of these abort codes so that they can represent both the error <strong>category</strong> along with an error <strong>reason</strong>.</p>
<p>Error categories are declared as constants in the <code>errors</code> module and are globally unique with respect to this module. Error reasons on the other hand are module-specific error codes, and can provide greater detail (perhaps, even a particular <em>reason</em>) about the specific error condition. This representation of a category and reason for each error code is done by dividing the abort code into two sections.</p>
<p>The lower 8 bits of the abort code hold the <em>error category</em>. The remaining 56 bits of the abort code hold the <em>error reason</em>.
The reason should be a unique number relative to the module which raised the error and can be used to obtain more information about the error at hand. It should mostly be used for diagnostic purposes as error reasons may change over time if the module is updated.</p>
<table><thead><tr><th>Category</th><th>Reason</th></tr></thead><tbody>
<tr><td>8 bits</td><td>56 bits</td></tr>
</tbody></table>
<p>Since error categories are globally stable, these present the most stable API and should in general be what is used by clients to determine the messages they may present to users (whereas the reason is useful for diagnostic purposes). There are public functions in the <code>errors</code> module for creating an abort code of each error category with a specific <code>reason</code> number (represented as a <code>u64</code>).</p>
<h3 id="constants-1"><a class="header" href="#constants-1">Constants</a></h3>
<p>The system is in a state where the performed operation is not allowed.</p>
<pre><code class="language-move">    const INVALID_STATE: u8 = 1;
</code></pre>
<hr />
<p>A specific account address was required to perform an operation, but a different address from what was expected was encountered.</p>
<pre><code class="language-move">    const REQUIRES_ADDRESS: u8 = 2;
</code></pre>
<hr />
<p>An account did not have the expected  role for this operation. Useful for Role Based Access Control (RBAC) error conditions.</p>
<pre><code class="language-move">    const REQUIRES_ROLE: u8 = 3;
</code></pre>
<hr />
<p>An account did not not have a required capability. Useful for RBAC error conditions.</p>
<pre><code class="language-move">    const REQUIRES_CAPABILITY: u8 = 4;
</code></pre>
<hr />
<p>A resource was expected, but did not exist under an address.</p>
<pre><code class="language-move">    const NOT_PUBLISHED: u8 = 5;
</code></pre>
<hr />
<p>Attempted to publish a resource under an address where one was already published.</p>
<pre><code class="language-move">    const ALREADY_PUBLISHED: u8 = 6;
</code></pre>
<hr />
<p>An argument provided for an operation was invalid.</p>
<pre><code class="language-move">    const INVALID_ARGUMENT: u8 = 7;
</code></pre>
<hr />
<p>A limit on a value was exceeded.</p>
<pre><code class="language-move">    const LIMIT_EXCEEDED: u8 = 8;
</code></pre>
<hr />
<p>An internal error (bug) has occurred.</p>
<pre><code class="language-move">    const INTERNAL: u8 = 10;
</code></pre>
<hr />
<p>A custom error category for extension points.</p>
<pre><code class="language-move">    const CUSTOM: u8 = 255;
</code></pre>
<hr />
<h3 id="functions-3"><a class="header" href="#functions-3">Functions</a></h3>
<p>Should be used in the case where invalid (global) state is encountered. Constructs an abort code with specified <code>reason</code> and category <code>INVALID_STATE</code>. Will abort if <code>reason</code> does not fit in 56 bits.</p>
<pre><code class="language-move">    public fun invalid_state(reason: u64): u64;
</code></pre>
<hr />
<p>Should be used if an account's address does not match a specific address. Constructs an abort code with specified <code>reason</code> and category <code>REQUIRES_ADDRESS</code>. Will abort if <code>reason</code> does not fit in 56 bits.</p>
<pre><code class="language-move">    public fun requires_address(reason: u64): u64;
</code></pre>
<hr />
<p>Should be used if a role did not match a required role when using RBAC. Constructs an abort code with specified <code>reason</code> and category <code>REQUIRES_ROLE</code>. Will abort if <code>reason</code> does not fit in 56 bits.</p>
<pre><code class="language-move">    public fun requires_role(reason: u64): u64;
</code></pre>
<hr />
<p>Should be used if an account did not have a required capability when using RBAC. Constructs an abort code with specified <code>reason</code> and category <code>REQUIRES_CAPABILITY</code>. Should be Will abort if <code>reason</code> does not fit in 56 bits.</p>
<pre><code class="language-move">    public fun requires_capability(reason: u64): u64;
</code></pre>
<hr />
<p>Should be used if a resource did not exist where one was expected. Constructs an abort code with specified <code>reason</code> and category <code>NOT_PUBLISHED</code>. Will abort if <code>reason</code> does not fit in 56 bits.</p>
<pre><code class="language-move">    public fun not_published(reason: u64): u64;
</code></pre>
<hr />
<p>Should be used if a resource already existed where one was about to be published. Constructs an abort code with specified <code>reason</code> and category <code>ALREADY_PUBLISHED</code>. Will abort if <code>reason</code> does not fit in 56 bits.</p>
<pre><code class="language-move">    public fun already_published(reason: u64): u64;
</code></pre>
<hr />
<p>Should be used if an invalid argument was passed to a function/operation. Constructs an abort code with specified <code>reason</code> and category <code>INVALID_ARGUMENT</code>. Will abort if <code>reason</code> does not fit in 56 bits.</p>
<pre><code class="language-move">    public fun invalid_argument(reason: u64): u64;
</code></pre>
<hr />
<p>Should be used if a limit on a specific value is reached, e.g., subtracting 1 from a value of 0. Constructs an abort code with specified <code>reason</code> and category <code>LIMIT_EXCEEDED</code>. Will abort if <code>reason</code> does not fit in 56 bits.</p>
<pre><code class="language-move">    public fun limit_exceeded(reason: u64): u64;
</code></pre>
<hr />
<p>Should be used if an internal error or bug was encountered. Constructs an abort code with specified <code>reason</code> and category <code>INTERNAL</code>. Will abort if <code>reason</code> does not fit in 56 bits.</p>
<pre><code class="language-move">    public fun internal(reason: u64): u64;
</code></pre>
<hr />
<p>Used for extension points, should be not used under most circumstances. Constructs an abort code with specified <code>reason</code> and category <code>CUSTOM</code>. Will abort if <code>reason</code> does not fit in 56 bits.</p>
<pre><code class="language-move">    public fun custom(reason: u64): u64;
</code></pre>
<hr />
<h2 id="fixed_point32"><a class="header" href="#fixed_point32">fixed_point32</a></h2>
<p>The <code>fixed_point32</code> module defines a fixed-point numeric type with 32 integer bits and 32 fractional bits. Internally, this is represented as a <code>u64</code> integer wrapped in a struct to make a unique <code>fixed_point32</code> type. Since the numeric representation is a binary one, some decimal values may not be exactly representable, but it provides more than 9 decimal digits of precision both before and after the decimal point (18 digits total). For comparison, double precision floating-point has less than 16 decimal digits of precision, so you should be careful about using floating-point to convert these values to decimal.</p>
<h3 id="types-1"><a class="header" href="#types-1">Types</a></h3>
<p>Represents a fixed-point numeric number with 32 fractional bits.</p>
<pre><code class="language-move">    struct FixedPoint32;
</code></pre>
<h3 id="functions-4"><a class="header" href="#functions-4">Functions</a></h3>
<p>Multiply a u64 integer by a fixed-point number, truncating any fractional part of the product. This will abort if the product overflows.</p>
<pre><code class="language-move">    public fun multiply_u64(val: u64, multiplier: FixedPoint32): u64;
</code></pre>
<hr />
<p>Divide a u64 integer by a fixed-point number, truncating any fractional part of the quotient. This will abort if the divisor is zero or if the quotient overflows.</p>
<pre><code class="language-move">    public fun divide_u64(val: u64, divisor: FixedPoint32): u64;
</code></pre>
<hr />
<p>Create a fixed-point value from a rational number specified by its numerator and denominator. Calling this function should be preferred for using <code>fixed_point32::create_from_raw_value</code> which is also available. This will abort if the denominator is zero. It will also abort if the numerator is nonzero and the ratio is not in the range $2^{-32}\ldots2^{32}-1$. When specifying decimal fractions, be careful about rounding errors: if you round to display $N$ digits after the decimal point, you can use a denominator of $10^N$ to avoid numbers where the very small imprecision in the binary representation could change the rounding, e.g., 0.0125 will round down to 0.012 instead of up to 0.013.</p>
<pre><code class="language-move">    public fun create_from_rational(numerator: u64, denominator: u64): FixedPoint32;
</code></pre>
<hr />
<p>Create a fixedpoint value from a raw <code>u64</code> value.</p>
<pre><code class="language-move">    public fun create_from_raw_value(value: u64): FixedPoint32;
</code></pre>
<hr />
<p>Returns <code>true</code> if the decimal value of <code>num</code> is equal to zero.</p>
<pre><code class="language-move">    public fun is_zero(num: FixedPoint32): bool;
</code></pre>
<hr />
<p>Accessor for the raw <code>u64</code> value. Other less common operations, such as adding or subtracting <code>FixedPoint32</code> values, can be done using the raw values directly.</p>
<pre><code class="language-move">    public fun get_raw_value(num: FixedPoint32): u64;
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="move-coding-conventions"><a class="header" href="#move-coding-conventions">Move Coding Conventions</a></h1>
<p>This section lays out some basic coding conventions for Move that the Move team has found helpful. These are only recommendations, and you should feel free to use other formatting guidelines and conventions if you have a preference for them.</p>
<h2 id="naming-2"><a class="header" href="#naming-2">Naming</a></h2>
<ul>
<li><strong>Module names</strong>: should be lower snake case, e.g., <code>fixed_point32</code>, <code>vector</code>.</li>
<li><strong>Type names</strong>: should be camel case if they are not a native type, e.g., <code>Coin</code>, <code>RoleId</code>.</li>
<li><strong>Function names</strong>: should be lower snake case, e.g., <code>destroy_empty</code>.</li>
<li><strong>Constant names</strong>: should be upper camel case and begin with an <code>E</code> if they represent error codes (e.g., <code>EIndexOutOfBounds</code>) and upper snake case if they represent a non-error value (e.g., <code>MIN_STAKE</code>).</li>
<li></li>
<li><strong>Generic type names</strong>: should be descriptive, or anti-descriptive where appropriate, e.g., <code>T</code> or <code>Element</code> for the Vector generic type parameter. Most of the time the &quot;main&quot; type in a module should be the same name as the module e.g., <code>option::Option</code>, <code>fixed_point32::FixedPoint32</code>.</li>
<li><strong>Module file names</strong>: should be the same as the module name e.g., <code>option.move</code>.</li>
<li><strong>Script file names</strong>: should be lower snake case and should match the name of the “main” function in the script.</li>
<li><strong>Mixed file names</strong>: If the file contains multiple modules and/or scripts, the file name should be lower snake case, where the name does not match any particular module/script inside.</li>
</ul>
<h2 id="imports"><a class="header" href="#imports">Imports</a></h2>
<ul>
<li>All module <code>use</code> statements should be at the top of the module.</li>
<li>Functions should be imported and used fully qualified from the module in which they are declared, and not imported at the top level.</li>
<li>Types should be imported at the top-level. Where there are name clashes, <code>as</code> should be used to rename the type locally as appropriate.</li>
</ul>
<p>For example, if there is a module:</p>
<pre><code class="language-move">module 0x1::foo {
    struct Foo { }
    const CONST_FOO: u64 = 0;
    public fun do_foo(): Foo { Foo{} }
    ...
}
</code></pre>
<p>this would be imported and used as:</p>
<pre><code class="language-move">module 0x1::bar {
    use 0x1::foo::{Self, Foo};

    public fun do_bar(x: u64): Foo {
        if (x == 10) {
            foo::do_foo()
        } else {
            abort 0
        }
    }
    ...
}
</code></pre>
<p>And, if there is a local name-clash when importing two modules:</p>
<pre><code class="language-move">module other_foo {
    struct Foo {}
    ...
}

module 0x1::importer {
    use 0x1::other_foo::Foo as OtherFoo;
    use 0x1::foo::Foo;
    ...
}
</code></pre>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<ul>
<li>Each module, struct, and public function declaration should be commented.</li>
<li>Move has doc comments <code>///</code>, regular single-line comments <code>//</code>, block comments <code>/* */</code>, and block doc comments <code>/** */</code>.</li>
</ul>
<h2 id="formatting"><a class="header" href="#formatting">Formatting</a></h2>
<p>The Move team plans to write an autoformatter to enforce formatting conventions. However, in the meantime:</p>
<ul>
<li>Four space indentation should be used except for <code>script</code> and <code>address</code> blocks whose contents should not be indented.</li>
<li>Lines should be broken if they are longer than 100 characters.</li>
<li>Structs and constants should be declared before all functions in a module.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
