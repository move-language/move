/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "A2_M" {
    code {
        codecopy(0, dataoffset("A2_M_deployed"), datasize("A2_M_deployed"))
        return(0, datasize("A2_M_deployed"))
    }
    object "A2_M_deployed" {
        code {
            mstore(0, memoryguard(160))
            if iszero(lt(calldatasize(), 4))
            {
                let selector := $Shr(calldataload(0), 224)
                switch selector
                default {}
            }
            $Abort(97)
            function $Abort(code) {
                mstore(0, code)
                revert(24, 8) // TODO: store code as a string?
            }
            function $Shr(x, y) -> r {
                r := shr(y, x)
            }
        }
    }
}


!! Succeeded compiling Yul


!! Unit tests

// test of M::h1
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "test_A2_M_h1" {
    code {
        mstore(0, memoryguard(160))
        A2_M_h1()
        return (0, 0)
        function A2_M_h1() {
            let t, x, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21, $t22, $t23, $t24, $t25, $t26, $t27, $t28, $t29, $t30, $t31, $t32, $t33, $t34, $t35, $t36, $t37, $t38, $t39, $t40, $t41, $t42, $t43, $t44, $t45, $t46, $t47, $t48, $t49, $t50, $t51, $t52, $t53, $t54, $t55, $t56, $t57, $t58, $t59, $t60, $t61, $t62, $t63, $t64, $t65, $t66, $t67, $t68, $t69, $t70, $t71, $t72, $t73, $t74, $t75, $t76, $t77
            let $locals := $Malloc(96)
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // $t16 := 96
                    $t16 := 96
                    // abort($t16)
                    $Abort($t16)
                }
                case 3 {
                    // label L0
                    // $t17 := borrow_local($t2)
                    $t17 := $MakePtr(false, add($locals, 32))
                    // $t18 := 0
                    $t18 := 0
                    // $t19 := vector::borrow<u8>($t17, $t18)
                    $t19 := A1_vector_borrow$u8$($t17, $t18)
                    // $t20 := read_ref($t19)
                    $t20 := $LoadU8($t19)
                    // $t21 := 97
                    $t21 := 97
                    // $t22 := ==($t20, $t21)
                    $t22 := $Eq($t20, $t21)
                    // if ($t22) goto L2 else goto L3
                    switch $t22
                    case 0  { $block := 5 }
                    default { $block := 6 }
                }
                case 4 {
                    // $t5 := 0x3
                    $t5 := 0x3
                    // $t0 := Evm::sign($t5)
                    mstore($locals, A2_Evm_sign($t5))
                    // $t6 := borrow_local($t0)
                    $t6 := $MakePtr(false, $locals)
                    // $t7 := [97, 98, 99]
                    $t7 := $Malloc(add(32, $ClosestGreaterPowerOfTwo(3)))
                    $MemoryStoreU64($t7, 3)
                    $MemoryStoreU64(add($t7, 8), $ClosestGreaterPowerOfTwo(3))
                    copy_literal_string_to_memory_2053440334(add($t7, 32))
                    // $t8 := pack M::T($t7)
                    {
                        let $mem := $Malloc(32)
                        $MemoryStoreU256(add($mem, 0), $t7)
                        $t8 := $mem
                    }
                    // move_to<M::T>($t8, $t6)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x3948ca0a, $LoadU256($t6))
                        if $AlignedStorageLoad($base_offset) {
                          $AbortBuiltin()
                        }
                        $AlignedStorageStore($base_offset, true)
                        {
                            let $dst := add($base_offset, 32)
                            let $src := $t8
                            {
                                let $linked_src_2300595445 := mload(add($src, 0))
                                let $linked_dst_2300595445 := $NewLinkedStorageBase(0x89204cf5)
                                let $size_2300595445 := $MemoryLoadU64($linked_src_2300595445)
                                let $data_size_2300595445 := mul($size_2300595445, 1)
                                $AlignedStorageStore($linked_dst_2300595445, mload($linked_src_2300595445))
                                let $data_src_2300595445 := add($linked_src_2300595445, 32)
                                let $data_dst_2300595445 := add($linked_dst_2300595445, 32)
                                for { let $offs_2300595445 := 0 } lt($offs_2300595445, $data_size_2300595445) { $offs_2300595445 := add($offs_2300595445, 32)} {
                                    $AlignedStorageStore(add($data_dst_2300595445, $offs_2300595445), mload(add($data_src_2300595445, $offs_2300595445)))
                                    $Free($linked_src_2300595445, add($data_size_2300595445, 32))
                                }
                                $AlignedStorageStore(add($dst, 0), $linked_dst_2300595445)
                            }
                            $Free($src, 32)
                        }
                    }
                    // $t9 := 0x3
                    $t9 := 0x3
                    // $t10 := borrow_global<M::T>($t9)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x3948ca0a, $t9)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t10 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t11 := borrow_field<M::T>.s($t10)
                    $t11 := $t10
                    // $t2 := read_ref($t11)
                    mstore(add($locals, 32), $LoadU256($t11))
                    if $IsStoragePtr($t11){
                        let $storage_ptr_2300595445
                        let $size_2300595445 := $StorageLoadU64(mload(add($locals, 32)))
                        let $capacity_2300595445 := $ClosestGreaterPowerOfTwo($size_2300595445)
                        $storage_ptr_2300595445 := $Malloc(add(32, mul($capacity_2300595445, 1)))
                        let $data_size_2300595445 := mul($size_2300595445, 1)
                        mstore($storage_ptr_2300595445, $AlignedStorageLoad(mload(add($locals, 32))))
                        $MemoryStoreU64(add($storage_ptr_2300595445, 8), $capacity_2300595445)
                        let $data_src_2300595445 := add(mload(add($locals, 32)), 32)
                        let $data_dst_2300595445 := add($storage_ptr_2300595445, 32)
                        for { let $offs_2300595445 := 0 } lt($offs_2300595445, $data_size_2300595445) { $offs_2300595445 := add($offs_2300595445, 32)} {
                            mstore(add($data_dst_2300595445, $offs_2300595445), $AlignedStorageLoad(add($data_src_2300595445, $offs_2300595445)))
                        }
                        mstore(add($locals, 32), $storage_ptr_2300595445)
                    }
                    // $t12 := borrow_local($t2)
                    $t12 := $MakePtr(false, add($locals, 32))
                    // $t13 := vector::length<u8>($t12)
                    $t13 := A1_vector_length$u8$($t12)
                    // $t14 := 3
                    $t14 := 3
                    // $t15 := ==($t13, $t14)
                    $t15 := $Eq($t13, $t14)
                    // if ($t15) goto L0 else goto L1
                    switch $t15
                    case 0  { $block := 2 }
                    default { $block := 3 }
                }
                case 5 {
                    // label L3
                    // $t23 := 97
                    $t23 := 97
                    // abort($t23)
                    $Abort($t23)
                }
                case 6 {
                    // label L2
                    // $t24 := borrow_local($t2)
                    $t24 := $MakePtr(false, add($locals, 32))
                    // $t25 := 1
                    $t25 := 1
                    // $t26 := vector::borrow<u8>($t24, $t25)
                    $t26 := A1_vector_borrow$u8$($t24, $t25)
                    // $t27 := read_ref($t26)
                    $t27 := $LoadU8($t26)
                    // $t28 := 98
                    $t28 := 98
                    // $t29 := ==($t27, $t28)
                    $t29 := $Eq($t27, $t28)
                    // if ($t29) goto L4 else goto L5
                    switch $t29
                    case 0  { $block := 7 }
                    default { $block := 8 }
                }
                case 7 {
                    // label L5
                    // $t30 := 98
                    $t30 := 98
                    // abort($t30)
                    $Abort($t30)
                }
                case 8 {
                    // label L4
                    // $t31 := borrow_local($t2)
                    $t31 := $MakePtr(false, add($locals, 32))
                    // $t32 := 2
                    $t32 := 2
                    // $t33 := vector::borrow<u8>($t31, $t32)
                    $t33 := A1_vector_borrow$u8$($t31, $t32)
                    // $t34 := read_ref($t33)
                    $t34 := $LoadU8($t33)
                    // $t35 := 99
                    $t35 := 99
                    // $t36 := ==($t34, $t35)
                    $t36 := $Eq($t34, $t35)
                    // if ($t36) goto L6 else goto L7
                    switch $t36
                    case 0  { $block := 9 }
                    default { $block := 10 }
                }
                case 9 {
                    // label L7
                    // $t37 := 99
                    $t37 := 99
                    // abort($t37)
                    $Abort($t37)
                }
                case 10 {
                    // label L6
                    // $t38 := [101, 102, 103, 104]
                    $t38 := $Malloc(add(32, $ClosestGreaterPowerOfTwo(4)))
                    $MemoryStoreU64($t38, 4)
                    $MemoryStoreU64(add($t38, 8), $ClosestGreaterPowerOfTwo(4))
                    copy_literal_string_to_memory_2788570470(add($t38, 32))
                    // $t39 := 0x3
                    $t39 := 0x3
                    // $t40 := borrow_global<M::T>($t39)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x3948ca0a, $t39)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t40 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t41 := borrow_field<M::T>.s($t40)
                    $t41 := $t40
                    // write_ref($t41, $t38)
                    if $IsStoragePtr($t41){
                        let $storage_ptr_2300595445 := $NewLinkedStorageBase(0x89204cf5)
                        let $size_2300595445 := $MemoryLoadU64($t38)
                        let $data_size_2300595445 := mul($size_2300595445, 1)
                        $AlignedStorageStore($storage_ptr_2300595445, mload($t38))
                        let $data_src_2300595445 := add($t38, 32)
                        let $data_dst_2300595445 := add($storage_ptr_2300595445, 32)
                        for { let $offs_2300595445 := 0 } lt($offs_2300595445, $data_size_2300595445) { $offs_2300595445 := add($offs_2300595445, 32)} {
                            $AlignedStorageStore(add($data_dst_2300595445, $offs_2300595445), mload(add($data_src_2300595445, $offs_2300595445)))
                        }
                        $t38 := $storage_ptr_2300595445
                    }
                    $StoreU256($t41, $t38)
                    // $t42 := 0x3
                    $t42 := 0x3
                    // $t43 := borrow_global<M::T>($t42)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x3948ca0a, $t42)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t43 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t44 := borrow_field<M::T>.s($t43)
                    $t44 := $t43
                    // $t3 := read_ref($t44)
                    mstore(add($locals, 64), $LoadU256($t44))
                    if $IsStoragePtr($t44){
                        let $storage_ptr_2300595445
                        let $size_2300595445 := $StorageLoadU64(mload(add($locals, 64)))
                        let $capacity_2300595445 := $ClosestGreaterPowerOfTwo($size_2300595445)
                        $storage_ptr_2300595445 := $Malloc(add(32, mul($capacity_2300595445, 1)))
                        let $data_size_2300595445 := mul($size_2300595445, 1)
                        mstore($storage_ptr_2300595445, $AlignedStorageLoad(mload(add($locals, 64))))
                        $MemoryStoreU64(add($storage_ptr_2300595445, 8), $capacity_2300595445)
                        let $data_src_2300595445 := add(mload(add($locals, 64)), 32)
                        let $data_dst_2300595445 := add($storage_ptr_2300595445, 32)
                        for { let $offs_2300595445 := 0 } lt($offs_2300595445, $data_size_2300595445) { $offs_2300595445 := add($offs_2300595445, 32)} {
                            mstore(add($data_dst_2300595445, $offs_2300595445), $AlignedStorageLoad(add($data_src_2300595445, $offs_2300595445)))
                        }
                        mstore(add($locals, 64), $storage_ptr_2300595445)
                    }
                    // $t45 := borrow_local($t3)
                    $t45 := $MakePtr(false, add($locals, 64))
                    // $t46 := vector::length<u8>($t45)
                    $t46 := A1_vector_length$u8$($t45)
                    // $t47 := 4
                    $t47 := 4
                    // $t48 := ==($t46, $t47)
                    $t48 := $Eq($t46, $t47)
                    // if ($t48) goto L8 else goto L9
                    switch $t48
                    case 0  { $block := 11 }
                    default { $block := 12 }
                }
                case 11 {
                    // label L9
                    // $t49 := 100
                    $t49 := 100
                    // abort($t49)
                    $Abort($t49)
                }
                case 12 {
                    // label L8
                    // $t50 := borrow_local($t3)
                    $t50 := $MakePtr(false, add($locals, 64))
                    // $t51 := 0
                    $t51 := 0
                    // $t52 := vector::borrow<u8>($t50, $t51)
                    $t52 := A1_vector_borrow$u8$($t50, $t51)
                    // $t53 := read_ref($t52)
                    $t53 := $LoadU8($t52)
                    // $t54 := 101
                    $t54 := 101
                    // $t55 := ==($t53, $t54)
                    $t55 := $Eq($t53, $t54)
                    // if ($t55) goto L10 else goto L11
                    switch $t55
                    case 0  { $block := 13 }
                    default { $block := 14 }
                }
                case 13 {
                    // label L11
                    // $t56 := 101
                    $t56 := 101
                    // abort($t56)
                    $Abort($t56)
                }
                case 14 {
                    // label L10
                    // $t57 := borrow_local($t3)
                    $t57 := $MakePtr(false, add($locals, 64))
                    // $t58 := 1
                    $t58 := 1
                    // $t59 := vector::borrow<u8>($t57, $t58)
                    $t59 := A1_vector_borrow$u8$($t57, $t58)
                    // $t60 := read_ref($t59)
                    $t60 := $LoadU8($t59)
                    // $t61 := 102
                    $t61 := 102
                    // $t62 := ==($t60, $t61)
                    $t62 := $Eq($t60, $t61)
                    // if ($t62) goto L12 else goto L13
                    switch $t62
                    case 0  { $block := 15 }
                    default { $block := 16 }
                }
                case 15 {
                    // label L13
                    // $t63 := 102
                    $t63 := 102
                    // abort($t63)
                    $Abort($t63)
                }
                case 16 {
                    // label L12
                    // $t64 := borrow_local($t3)
                    $t64 := $MakePtr(false, add($locals, 64))
                    // $t65 := 2
                    $t65 := 2
                    // $t66 := vector::borrow<u8>($t64, $t65)
                    $t66 := A1_vector_borrow$u8$($t64, $t65)
                    // $t67 := read_ref($t66)
                    $t67 := $LoadU8($t66)
                    // $t68 := 103
                    $t68 := 103
                    // $t69 := ==($t67, $t68)
                    $t69 := $Eq($t67, $t68)
                    // if ($t69) goto L14 else goto L15
                    switch $t69
                    case 0  { $block := 17 }
                    default { $block := 18 }
                }
                case 17 {
                    // label L15
                    // $t70 := 103
                    $t70 := 103
                    // abort($t70)
                    $Abort($t70)
                }
                case 18 {
                    // label L14
                    // $t71 := borrow_local($t3)
                    $t71 := $MakePtr(false, add($locals, 64))
                    // $t72 := 3
                    $t72 := 3
                    // $t73 := vector::borrow<u8>($t71, $t72)
                    $t73 := A1_vector_borrow$u8$($t71, $t72)
                    // $t74 := read_ref($t73)
                    $t74 := $LoadU8($t73)
                    // $t75 := 104
                    $t75 := 104
                    // $t76 := ==($t74, $t75)
                    $t76 := $Eq($t74, $t75)
                    // if ($t76) goto L16 else goto L17
                    switch $t76
                    case 0  { $block := 19 }
                    default { $block := 20 }
                }
                case 19 {
                    // label L17
                    // $t77 := 104
                    $t77 := 104
                    // abort($t77)
                    $Abort($t77)
                }
                case 20 {
                    // label L16
                    // return ()
                    $Free($locals, 96)
                    leave
                }
            }
        }

        function A1_vector_borrow$u8$(v_ref, i) -> e_ptr {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            if $GtEq(i, size) { $AbortBuiltin() }
            e_ptr := $IndexPtr(v_ptr, add(32, mul(i, 1)))
        }
        function A1_vector_length$u8$(v_ref) -> len {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            len := $LoadU64(v_ptr)
        }
        function A2_Evm_sign(addr) -> signer {
          signer := addr
        }
        function copy_literal_string_to_memory_2788570470(value) {
            $MemoryStoreU8(value, 101)
            value := add(value, 1)
            $MemoryStoreU8(value, 102)
            value := add(value, 1)
            $MemoryStoreU8(value, 103)
            value := add(value, 1)
            $MemoryStoreU8(value, 104)
            value := add(value, 1)
        }
        function copy_literal_string_to_memory_2053440334(value) {
            $MemoryStoreU8(value, 97)
            value := add(value, 1)
            $MemoryStoreU8(value, 98)
            value := add(value, 1)
            $MemoryStoreU8(value, 99)
            value := add(value, 1)
        }
        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $Malloc(size) -> offs {
            offs := mload(0)
            // pad to word size
            mstore(0, add(offs, shl(5, shr(5, add(size, 31)))))
        }
        function $Free(offs, size) {
        }
        function $MakePtr(is_storage, offs) -> ptr {
          ptr := or(is_storage, shl(1, offs))
        }
        function $IsStoragePtr(ptr) -> b {
          b := and(ptr, 0x1)
        }
        function $OffsetPtr(ptr) -> offs {
          offs := shr(1, ptr)
        }
        function $MaskForSize(size) -> mask {
          mask := sub(shl(shl(3, size), 1), 1)
        }
        function $ExtractBytes(word, start, size) -> bytes {
           switch size
           case 1 {
              // use the faster byte primitive
              bytes := byte(start, word)
           }
           default {
              // As we have big endian, we need to right shift the value from
              // where the highest byte starts in the word (32 - start), minus
              // the size.
              let shift_bits := shl(3, sub(sub(32, start), size))
              bytes := and(shr(shift_bits, word), $MaskForSize(size))
           }
        }
        function $InjectBytes(word, start, size, bytes) -> new_word {
           let shift_bits := shl(3, sub(sub(32, start), size))
           // Blend out the bits which we inject
           let neg_mask := not(shl(shift_bits, $MaskForSize(size)))
           word := and(word, neg_mask)
           // Overlay the bits we inject
           new_word := or(word, shl(shift_bits, bytes))
        }
        function $ToWordOffs(offs) -> word_offs, byte_offset {
          word_offs := shr(5, offs)
          byte_offset := and(offs, 0x1F)
        }
        function $OverflowBytes(byte_offset, size) -> overflow_bytes {
          let available_bytes := sub(32, byte_offset)
          switch gt(size, available_bytes)
          case 0 {
            overflow_bytes := 0
          }
          default {
            overflow_bytes := sub(size, available_bytes)
          }
        }
        function $MemoryLoadBytes(offs, size) -> val {
          // Lower bit where the value in the higher bytes ends
          let bit_end := shl(3, sub(32, size))
          val := shr(bit_end, mload(offs))
        }
        function $MemoryStoreBytes(offs, size, val) {
          let bit_end := shl(3, sub(32, size))
          let mask := shl(bit_end, $MaskForSize(size))
          mstore(offs, or(and(mload(offs), not(mask)), shl(bit_end, val)))
        }
        function $StorageLoadBytes(offs, size) -> val {
          let word_offs, byte_offs := $ToWordOffs(offs)
          let key := $StorageKey(0, word_offs)
          val := $ExtractBytes(sload(key), byte_offs, size)
          let overflow_bytes := $OverflowBytes(byte_offs, size)
          if $LogicalNot(iszero(overflow_bytes)) {
            key := $StorageKey(0, add(word_offs, 1))
            let extra_bytes := $ExtractBytes(sload(key), 0, overflow_bytes)
            val := or(shl(shl(3, overflow_bytes), val), extra_bytes)
          }
        }
        function $StorageStoreBytes(offs, size, bytes) {
          let word_offs, byte_offs := $ToWordOffs(offs)
          let key := $StorageKey(0, word_offs)
          let overflow_bytes := $OverflowBytes(byte_offs, size)
          switch overflow_bytes
          case 0 {
            sstore(key, $InjectBytes(sload(key), byte_offs, size, bytes))
          }
          default {
            // Shift the higher bytes to the right
            let used_bytes := sub(size, overflow_bytes)
            let higher_bytes := shr(used_bytes, bytes)
            let lower_bytes := and(bytes, $MaskForSize(overflow_bytes))
            sstore(key, $InjectBytes(sload(key), byte_offs, used_bytes, higher_bytes))
            key := $StorageKey(0, add(word_offs, 1))
            sstore(key, $InjectBytes(sload(key), 0, overflow_bytes, lower_bytes))
          }
        }
        function $StorageKey(group, word) -> key {
          mstore(32, word)
          mstore(64, shl(224, group))
          key := keccak256(32, 36)
        }
        function $MakeTypeStorageBase(category, type_hash, id) -> offs {
          offs := or(shl(252, category), or(shl(220, type_hash), shl(60, id)))
        }
        function $NewLinkedStorageBase(type_hash) -> offs {
          let key := $StorageKey(1, 1)
          let handle := sload(key)
          sstore(key, add(handle, 1))
          offs := $MakeTypeStorageBase(1, type_hash, handle)
        }
        function $IndexPtr(ptr, offs) -> new_ptr {
          new_ptr := $MakePtr($IsStoragePtr(ptr), add($OffsetPtr(ptr), offs))
        }
        function $LoadU8(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU8(offs)
          }
          default {
            val := $StorageLoadU8(offs)
          }
        }
        function $MemoryLoadU8(offs) -> val {
          val := $MemoryLoadBytes(offs, 1)
        }
        function $StorageLoadU8(offs) -> val {
          val := $StorageLoadBytes(offs, 1)
        }
        function $MemoryStoreU8(offs, val) {
          // Shortcut via special instruction
          mstore8(offs, val)
        }
        function $LoadU64(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU64(offs)
          }
          default {
            val := $StorageLoadU64(offs)
          }
        }
        function $MemoryLoadU64(offs) -> val {
          val := $MemoryLoadBytes(offs, 8)
        }
        function $StorageLoadU64(offs) -> val {
          val := $StorageLoadBytes(offs, 8)
        }
        function $MemoryStoreU64(offs, val) {
          $MemoryStoreBytes(offs, 8, val)
        }
        function $LoadU256(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU256(offs)
          }
          default {
            val := $StorageLoadU256(offs)
          }
        }
        function $MemoryLoadU256(offs) -> val {
          val := $MemoryLoadBytes(offs, 32)
        }
        function $StorageLoadU256(offs) -> val {
          val := $StorageLoadBytes(offs, 32)
        }
        function $StoreU256(ptr, val) {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            $MemoryStoreU256(offs, val)
          }
          default {
            $StorageStoreU256(offs, val)
          }
        }
        function $MemoryStoreU256(offs, val) {
          $MemoryStoreBytes(offs, 32, val)
        }
        function $StorageStoreU256(offs, val) {
          $StorageStoreBytes(offs, 32, val)
        }
        function $AlignedStorageLoad(offs) -> val {
          let word_offs := shr(5, offs)
          val := sload($StorageKey(0, word_offs))
        }
        function $AlignedStorageStore(offs, val) {
          let word_offs := shr(5, offs)
          sstore($StorageKey(0, word_offs), val)
        }
        function $GtEq(x, y) -> r {
            r := or(gt(x, y), eq(x, y))
        }
        function $Eq(x, y) -> r {
            r := eq(x, y)
        }
        function $LogicalNot(x) -> r {
            r := iszero(x)
        }
        function $ClosestGreaterPowerOfTwo(x) -> r {
            r := or(r, shr(1, x))
            r := or(r, shr(2, r))
            r := or(r, shr(4, r))
            r := or(r, shr(8, r))
            r := or(r, shr(16, r))
            r := or(r, shr(32, r))
            r := add(x, 1)
        }
    }
}
===> Test result of M::h1: Succeed(Stopped) (used_gas=166469): []

// test of M::test_same_literals
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "test_A2_M_test_same_literals" {
    code {
        mstore(0, memoryguard(160))
        A2_M_test_same_literals()
        return (0, 0)
        function A2_M_test_same_literals() {
            let $t0, $t1, $t2, $t3
            // $t0 := true
            $t0 := true
            // $t1 := [101, 114, 114, 111, 114, 95, 109, 101, 115, 115, 97, 103, 101]
            $t1 := $Malloc(add(32, $ClosestGreaterPowerOfTwo(13)))
            $MemoryStoreU64($t1, 13)
            $MemoryStoreU64(add($t1, 8), $ClosestGreaterPowerOfTwo(13))
            copy_literal_string_to_memory_3855568786(add($t1, 32))
            // Evm::require($t0, $t1)
            A2_Evm_require($t0, $t1)
            // $t2 := true
            $t2 := true
            // $t3 := [101, 114, 114, 111, 114, 95, 109, 101, 115, 115, 97, 103, 101]
            $t3 := $Malloc(add(32, $ClosestGreaterPowerOfTwo(13)))
            $MemoryStoreU64($t3, 13)
            $MemoryStoreU64(add($t3, 8), $ClosestGreaterPowerOfTwo(13))
            copy_literal_string_to_memory_3855568786(add($t3, 32))
            // Evm::require($t2, $t3)
            A2_Evm_require($t2, $t3)
            // return ()
        }

        function A2_Evm_require(cond, message) {
            let $t2
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L0
                    // Evm::abort_with($t1)
                    A2_Evm_abort_with(message)
                    // goto L2
                    $block := 3
                }
                case 3 {
                    // label L2
                    // return ()
                    leave
                }
                case 4 {
                    // $t2 := !($t0)
                    $t2 := $LogicalNot(cond)
                    // if ($t2) goto L0 else goto L2
                    switch $t2
                    case 0  { $block := 3 }
                    default { $block := 2 }
                }
            }
        }

        function A2_Evm_abort_with(message) {
          let head := $Malloc(32)
          // store the function selector for Error(string)
          mstore(head, 3963877391197344453575983046348115674221700746820753546331534351508065746944)
          let pos := add(head, 4)
          mstore(pos, 32)
          pos := add(pos, 32)
          let size := $MemoryLoadU64(message)
          mstore(pos, size)
          pos := add(pos, 32)
          $CopyMemory(add(message, 32), pos, size)
          size := $RoundUp(size)
          let end := add(pos, size)
          revert(head, sub(end, head))
        }
        function copy_literal_string_to_memory_3855568786(value) {
            $MemoryStoreU8(value, 101)
            value := add(value, 1)
            $MemoryStoreU8(value, 114)
            value := add(value, 1)
            $MemoryStoreU8(value, 114)
            value := add(value, 1)
            $MemoryStoreU8(value, 111)
            value := add(value, 1)
            $MemoryStoreU8(value, 114)
            value := add(value, 1)
            $MemoryStoreU8(value, 95)
            value := add(value, 1)
            $MemoryStoreU8(value, 109)
            value := add(value, 1)
            $MemoryStoreU8(value, 101)
            value := add(value, 1)
            $MemoryStoreU8(value, 115)
            value := add(value, 1)
            $MemoryStoreU8(value, 115)
            value := add(value, 1)
            $MemoryStoreU8(value, 97)
            value := add(value, 1)
            $MemoryStoreU8(value, 103)
            value := add(value, 1)
            $MemoryStoreU8(value, 101)
            value := add(value, 1)
        }
        function $Malloc(size) -> offs {
            offs := mload(0)
            // pad to word size
            mstore(0, add(offs, shl(5, shr(5, add(size, 31)))))
        }
        function $MaskForSize(size) -> mask {
          mask := sub(shl(shl(3, size), 1), 1)
        }
        function $ToWordOffs(offs) -> word_offs, byte_offset {
          word_offs := shr(5, offs)
          byte_offset := and(offs, 0x1F)
        }
        function $MemoryLoadBytes(offs, size) -> val {
          // Lower bit where the value in the higher bytes ends
          let bit_end := shl(3, sub(32, size))
          val := shr(bit_end, mload(offs))
        }
        function $MemoryStoreBytes(offs, size, val) {
          let bit_end := shl(3, sub(32, size))
          let mask := shl(bit_end, $MaskForSize(size))
          mstore(offs, or(and(mload(offs), not(mask)), shl(bit_end, val)))
        }
        function $MemoryStoreU8(offs, val) {
          // Shortcut via special instruction
          mstore8(offs, val)
        }
        function $MemoryLoadU64(offs) -> val {
          val := $MemoryLoadBytes(offs, 8)
        }
        function $MemoryStoreU64(offs, val) {
          $MemoryStoreBytes(offs, 8, val)
        }
        function $CopyMemory(src, dst, size) {
          let num_words, overflow_bytes := $ToWordOffs(size)
          let i := 0
          for { } lt(i, mul(num_words, 32)) { i := add(i, 32) } {
            mstore(add(dst, i), mload(add(src, i)))
          }
          if overflow_bytes {
            let mask := $MaskForSize(sub(32, overflow_bytes))
            let overflow_offs := mul(num_words, 32)
            let dst_word := and(mload(add(dst, overflow_offs)), mask)
            let src_word := and(mload(add(src, overflow_offs)), not(mask))
            mstore(add(dst, overflow_offs), or(dst_word, src_word))
          }
        }
        function $LogicalNot(x) -> r {
            r := iszero(x)
        }
        function $ClosestGreaterPowerOfTwo(x) -> r {
            r := or(r, shr(1, x))
            r := or(r, shr(2, r))
            r := or(r, shr(4, r))
            r := or(r, shr(8, r))
            r := or(r, shr(16, r))
            r := or(r, shr(32, r))
            r := add(x, 1)
        }
        function $RoundUp(value) -> result {
            result := and(add(value, 31), not(31))
        }
    }
}
===> Test result of M::test_same_literals: Succeed(Returned) (used_gas=1078): []
