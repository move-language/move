//# publish
module 0x42.M1 {
    struct S<T: copy> { t: T }

    // note: T does not have copy
    // if this worked, it would be very bad because `T` can be (e.g.) a Coin
    public copy_inner<T>(s: &Self.S<T>): T { // should get flagged w/ constraint not satisfied
    label b0:
        return *&move(s).S<T>::t;
    }
}

//# publish
module 0x42.M2 {
    struct S<T: copy> has copy { t: T }

    // note: T does not have copy
    // if this worked, it would be very bad because `T` can be (e.g.) a Coin
    public copy_direct<T>(s: &Self.S<T>): Self.S<T> { // should get flagged w/ constraint not satisfied
    label b0:
        return *move(s);
    }
}

//# publish
module 0x42.M3 {
    struct S<T: store> has store { t: T }

    // note: T does not have store
    // if this worked, it would be very bad because `T` can be (e.g.) a hot potato
    public store_inner<T>(s: &mut Self.S<T>, t: T) { // should get flagged w/ constraint not satisfied
    label b0:
        *&mut move(s).S<T>::t = move(t);
        return;
    }
}

//# publish
module 0x42.M4 {
    struct S<T: copy> { t: T }

    public bad_sig<T>(s: &Self.S<T>) { // should get flagged w/ constraint not satisfied
    label b0:
        return;
    }

    public call(): Self.S<u64> {
    let x: Self.S<u64>;
    label b0:
        x = S<u64> { t: 10 };
        Self.bad_sig(&x);
        return move(x);
    }
}

//# publish
module 0x42.M5 {
    struct S<T: copy> { t: T }

    public bad_sig<T>(s: &Self.S<T>) { // should get flagged w/ constraint not satisfied
    label b0:
        return;
    }

    public call(s: signer): Self.S<signer> {
    let x: Self.S<signer>;
    label b0:
        x = S<u64> { t: move(s) };
        Self.bad_sig(&x);
        return move(x);
    }
}
