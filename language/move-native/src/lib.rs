// Copyright (c) The Diem Core Contributors
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0

//! A Move native runtime prototype.
//!
//! This crate is part of the Solana project to port Move to LLVM and SBF.
//!
//! It contains three types of definitions
//!
//! - Types with layouts known to the compiler for the purposes of calling
//!   runtime functions. These have simple C-ABI layouts.
//!   ([`rt_types`] module).
//! - "Native" library functions required by the Move standard library, calls to
//!   which are generated by the LLVM backend.
//! - ([`std`] module).
//! - Runtime functions specific to the LLVM port as necessary to dynamically
//!   implement Move semantics.
//!   ([`rt`] module).
//!
//! The basic strategy is to define
//! simple data types for primitives like scalars and vectors, and runtime types
//! like type descriptors; and naming and calling conventions for translating
//! Move native calls to C-ABI calls. The native implementations convert the
//! Move types to existing Rust types like `Vec` to do their work.
//!
//! It contains several modules dividing the crate by concerns:
//!
//! - [`rt_types`] - the types whose structure is known to both
//!   LLVM and the runtime.
//! - [`rt`] - runtime calls emitted by the compiler
//! - [`std`] - the native functions called declared by Move `std`.
//! - [`conv`] - conversions between Move types and Rust types.
//! - [`target_defs`] - Solana-specific definitions that differ from Move VM
//!   or might reasonably differ for non-Solana targets.
//! - [`shared`] - reexports shared with the compiler.
//! - [`vector`] - implementations of vector ops.
//! - [`structs`] - implementations of struct ops.
//! - [`serialization`] - serialization and deserialization.
//!
//!
//! # Native functions background
//!
//! Native functions in Move are functions that the standard library relies on
//! the runtime to provide. They are declared with the `native` keyword and no
//! implementation. They are similar to `extern` functions in Rust.
//!
//! Here are some examples:
//!
//! ```move
//!    native public fun sha2_256(data: vector<u8>): vector<u8>;
//!
//!    /// Add element `e` to the end of the vector `v`.
//!    native public fun push_back<Element>(v: &mut vector<Element>, e: Element);
//!
//!    /// Pop an element from the end of vector `v`.
//!    /// Aborts if `v` is empty.
//!    native public fun pop_back<Element>(v: &mut vector<Element>): Element;
//!
//!    /// Return the binary representation of `v` in BCS (Binary Canonical Serialization) format
//!    native public fun to_bytes<MoveValue>(v: &MoveValue): vector<u8>;
//! ```
//!
//! In the Move VM these are implemented in Rust and registered with the VM at
//! runtime. These implementations are tightly tied to VM internals, and include
//! features like gas accounting that are irrelevant for the LLVM port. They are
//! not directly reusable by the LLVM port at this time.
//!
//!
//! # Generics and type interpretation
//!
//! The translation between Move native declarations and the C ABI is relatively
//! straightforward, with conventions described further in this document.
//!
//! The big complication is that many natives are generic, so there are choices
//! to be made about how to interpret type descriptors.
//!
//! This implementation interprets types at runtime by passing a [`MoveType`]
//! reference for every generic type. The `MoveType` definition closely mirrors
//! the Move compiler's `runtime_type::Type` definition.
//!
//! Native calls mostly need to know about size and
//! alignment of types to implement things like generic vector operations.
//! There are though functions for serialization and debug printing that
//! require further interpretation of arbitrary Move types.
//!
//! Embedding full type interpreters into the runtime means that every Move
//! program will contain code for interpreting every possible type, including
//! those it does not need. There may be ways to mitigate this bloat with clever
//! structure and LTO, but it is unclear.
//!
//!
//! # `no-std`
//!
//! For portability it may be desirable to not depend on `std`,
//! and at present this crate does not depend on `std` except for
//! its own unit tests.
//!
//! In the future specific targets may need to depend on `std`,
//! and that support can be isolated to the target-specific `target_defs`
//! module. For Solana specifically, we will probably link to `solana_program`,
//! which links to `std.
//!
//! When compiled as a Move runtime, and not for e.g. a host or testing,
//! this library is compiled as a "staticlib" crate type, which results
//! in an archive library that does not contain the Rust standard library.
//!
//! The crate's manifest though does not declare it as a staticlib.
//! If it did, then workspace operations like `cargo check` would attempt
//! to build it as a staticlib for the host, and this library does not declare
//! the lang-items necessary to build a staticlib for the host.
//! Instead, the build process for rbpf runs `cargo rustc --crate-type staticlib`.
//!
//!
//! # Platform compatibility
//!
//! Some definitions are different on Solana than on Move VM.
//!
//! - An address is 32 bytes to match Solana pubkeys. On Move VM an address is
//!   16 bytes by default but can be configured as 20 or 32 bytes at compile
//!   time.
//!
//!
//! # Naming conventions
//!
//! Within the Move VM natives are identified by a module name plus a function
//! name, like "vector" + "push_back". They do not appear to additionally be
//! identified by a library name like "std".
//!
//! Our native symbol names are a concatenation of the prefix "move_native_",
//! plus the module name and function name. So the vector `push_back` function
//! symbol is
//!
//! > `move_native_vector_push_back`
//!
//! In Rust code, native functions are defined under the `std` module, in
//! submodules that mirror the module heirarchy of the Move standard library,
//! and their final symbol names are given through the `export_name` attribute.
//!
//! Runtime functions needed by the compiler are prefixed "move_rt_",
//! like `move_rt_abort`.
//!
//!
//! # Data types
//!
//! Data types known to both the compiler and the runtime are defined in [`rt_types`].
//! They are all declared with explicit `repr` attributes to have a defined layout that
//! is easy to codegen.
//!
//! The most important types for the compiler are the vector type,
//! [`MoveUntypedVector`] here, and the type descriptor, here [`MoveType`].
//!
//! `MoveType` is similar to `move_vm_types::runtime_types::Type`, but with a
//! structure that does not rely on Rust-specific type layout. `MoveType`
//! contains recursive `&'static` references to other `MoveType`s, necessitating
//! that binaries contain a static table of all needed type descriptors.
//!
//! Generic values are represented by references or pointers to [`AnyValue`],
//! which is simply a transparent wrapper around a u8, pointers to which must
//! be unsafely cast based on an accompanying `MoveType`.
//!
//! Move references as interpreted by `TypeDesc` are assumed to always be
//! pointers - no fat pointers.
//!
//!
//! ## Vectors and strings
//!
//! Move vectors are operated on by casting to Rust vectors and reusing the Rust
//! methods. Move vectors have the same layout as Rust vecs.
//!
//! Move strings are a library type and not known to the Move compiler†.
//! They are a wrapper around byte vectors, and native string calls are
//! operations on `MoveByteVector`.
//!
//! Vectors must be allocated with the `vec::empty` Rust function,
//! the [`move_native_vec_empty`] native Move function, or the [`move_rt_vec_empty`]
//! runtime call; and destroyed with `vec::destroy_empty`, [`move_native_vec_destroy_empty`],
//! or [`move_rt_vec_destroy`].
//!
//! † - note that although `String` is a library type, the ASCII `String` (move
//! has UTF-8 and ASCII strings) is exposed to the runtime via the `TypeName`
//! library type, which is passed by value in the [`move_native_type_name_get`]
//! native function, the code generator and the runtime need to agree on its
//! layout.
//!
//!
//! ## Structs
//!
//! Structs are difficult for the runtime to handle. Since they have arbitrary
//! layout the runtime has to interpret them dynamically, unsafely.
//!
//! The struct type descriptor specifies the struct's size, including
//! post-padding as needed for side-by-side layout in arrays, and its alignment;
//! and it specifies the types and offsets of every field.
//!
//! Requirements:
//!
//! - Size must be > 0
//! - Alignment must be > 0
//! - Alignment must be a power of 2
//! - Size rounded up to alignment must not overflow a pointer-sized signed integer
//!
//!
//! # Calling conventions
//!
//! The calling conventions are straightforword, following the C ABI, with some
//! extra patterns necessary for things like Move type parameters and unsized
//! generic values.
//!
//! - type parameters
//!   - passed as `&MoveType`
//! - by-ref immutable generic types
//!   - passed by `&AnyValue`
//! - by-ref mutable generic types
//!   - passed by `*mut AnyValue`
//!   - writing to this incorrectly may produce unsoundness
//! - by-value generic types
//!   - passed by `*mut AnyValue`
//!   - examples: `write_to_event_store`
//! - by-value generic return types
//!   - stack-allocated return pointer of `*mut AnyValue`
//!   - examples: `pop_back`
//!
//!
//! # Panic handling and safety
//!
//! This crate does not handle panics at the FFI boundary. When used in a
//! runtime context it should be compiled such that panics trigger an abort.
//!
//! This code has not been scrutinized for panic safety, and some code paths
//! rely on destructors for correctness.
//!
//!
//! # References
//!
//! Useful Move code to read.
//!
//! - `move-stdlib::natives`
//! - `move-vm-types::loaded_data::Type`
//! - `move-vm-types::values::Value`
//! - `move-core-types::value`

#![no_std]

extern crate alloc;

/// Types literally shared with the compiler through crate linkage.
pub mod shared {
    pub use crate::rt_types::{TypeDesc, MOVE_TYPE_DESC_SIZE, MOVE_UNTYPED_VEC_DESC_SIZE};
}

/// Types known to the compiler.
mod rt_types;

/// Runtime calls emitted by the compiler.
/// Reference: move/language/documentation/book/src/abort-and-assert.md
mod rt;

/// Implementations of native calls for `std`.
mod std;

/// Conversion from move types to rust types.
mod conv;

/// Move vector support, used by both `rt` and `std`.
mod vector;

/// Move struct support.
mod structs;

/// Compatibility with the target platform, e.g. Solana.
mod target_defs;

/// Serialization and deserialization of move types,
/// support for the `bcs::to_bytes` standard library function.
mod serialization;

#[cfg(test)]
mod tests;
